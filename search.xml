<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>web前端复习提纲</title>
    <url>/web%E5%89%8D%E7%AB%AF/web%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2+2023%E5%9B%9E%E5%BF%86/</url>
    <content><![CDATA[<h2 id="web前端复习提纲-2023回忆">web前端复习提纲+2023回忆</h2>
<blockquote>
<p>参考自 zhy 的博客 <a href="https://spricoder.github.io/2021/01/19/2020-Web-Front-End-development/2020-Web-Front-End-development-Exam01-Summary/">2020-Web前端开发-Exam01-Summary - SpriCoder的博客</a></p>
<p>feat: 新增若干内容</p>
</blockquote>
<h1>1. 基础知识</h1>
<h2 id="1-1-Internet">1.1. Internet</h2>
<p>Internet 是在一个通信网络中连接的计算机的大规模集合，通过装置连接起来，相互之间可以通信。</p>
<h3 id="1-1-1-IP">1.1.1. IP</h3>
<p>根据端到端的设计原则，IP 只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。</p>
<h3 id="1-1-2-URI、URL、URN">1.1.2. URI、URL、URN</h3>
<ol>
<li class="lvl-3">
<p>URI(统一资源标识符，Uniform Resource Identifier) 允许资源驻留在 Internet 上的任何位置</p>
</li>
<li class="lvl-3">
<p>URL(统一资源定位符，Uniform Resource Locator) 显示资源副本的位置</p>
</li>
<li class="lvl-3">
<p>URN(统一资源名称，Uniform Resource Name) 是资源的唯一名称</p>
</li>
<li class="lvl-3">
<p><strong>URL、URN 是 URI 的子集，其中 URL 和 URN 有交集。</strong></p>
</li>
</ol>
<span id="more"></span>
<h3 id="1-1-3-DNS">1.1.3. DNS</h3>
<ol>
<li class="lvl-3">
<p>DNS 之前，转换是通过 FTP 到中央服务器上下载 hosts.txt 文件</p>
</li>
<li class="lvl-3">
<p>DNS(Domain Name System) 是一个分布式数据库，本地负责控制整个数据库的部分段，客户向 DNS 服务器请求，得到从域名到 IP 地址的转化。</p>
</li>
<li class="lvl-3">
<p>DNS 是<strong>唯一同时使用 TCP 和 UDP 的</strong></p>
<ul class="lvl-2">
<li class="lvl-5">在 DNS 域中的<strong>主备冗余机制</strong>中，进行<strong>同步通信时使用 TCP 协议</strong>，原因在于其可靠性</li>
<li class="lvl-5">在用户通过浏览器访问 DNS 服务器<strong>请求 IP 地址</strong>时使用 <strong>UDP</strong> 协议</li>
</ul>
</li>
<li class="lvl-3">
<p>工作过程：</p>
<ol>
<li class="lvl-6">客户向域名服务器发起查询请求</li>
<li class="lvl-6">域名服务器本地查询结果
<ol>
<li class="lvl-9">如果找到，则返回</li>
<li class="lvl-9">如果未找到则发送到根域名服务器，根域名服务器查询根域名解析，将包含下一级域名信息的 DNS 地址返回给客户的域名服务器。</li>
</ol>
</li>
<li class="lvl-6">客户的域名服务器根据根域名服务器解析的地址访问下一级 DNS，如此递归逐级查询，直到找到位置。<strong>【迭代查询和递归查询】</strong></li>
<li class="lvl-6">客户的域名 DNS 服务器将查询结果返回客户机。</li>
<li class="lvl-6">客户根据 IP 地址访问目标机。</li>
</ol>
</li>
</ol>
<h3 id="1-1-4-Http1-1、-2、-3-协议">1.1.4. Http1.1、/2、/3 协议</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP1.0</td>
<td><strong>非持续</strong>连接，每一次请求/响应建立并拆除一次连接，即短链接，2 个 RTT 时间，使用 TCP 链接；http 1.0中默认是关闭的，需要在http头加入**“Connection: Keep-Alive”**，才能启用Keep-Alive</td>
</tr>
<tr>
<td>HTTP1.1</td>
<td>支持 keepalive <strong>持久连接</strong>，即长连接，在<strong>相同 TCP</strong> 上通讯，http 1.1中默认启用Keep-Alive，如果加入**&quot;Connection: close &quot;<strong>，才关闭；支持流水线请求，可以不等反馈发送很多信息，不应该与任何服务器或代理保持超过2个连接，目前的主要版本<br />报文</strong>头部不会被压缩**【body 可以】，即使两个 header 非常相似也在重复传输</td>
</tr>
<tr>
<td>HTTP2.0</td>
<td>⼆进制协议而不是⽂本协议；支持 HTTP1.1，在<strong>数据如何封装成帧上有区别</strong>，<strong>头部压缩</strong>，请求和响应<strong>多路复用</strong></td>
</tr>
<tr>
<td>HTTP3.0</td>
<td>和 HTTP2 完全不同，使用 <strong>UDP 协议</strong>，通过重传保证效率<br />**为什么需要 3：**TCP队头阻塞问题；TCP握手时长；IP地址会发生变化 TCP 协议是根据四元组来确定⼀个连接的，需要重新建立连接</td>
</tr>
</tbody>
</table>
<h4 id="1-1-4-1-结构">1.1.4.1. 结构</h4>
<p>HTTP 请求和响应具有相似的结构，由以下部分组成：</p>
<ol>
<li class="lvl-3">
<p>⼀行起始行用于描述要执行的<strong>请求类型</strong>，或者是<strong>对应的状态</strong>，成功或失败。这个起始行总是单行的。</p>
</li>
<li class="lvl-3">
<p>⼀个可选的 <strong>HTTP 头</strong>集合指明请求或描述消息正文。</p>
</li>
<li class="lvl-3">
<p>⼀个<strong>空行指示</strong>所有关于请求的<strong>元数据已经发送完毕</strong>。</p>
</li>
<li class="lvl-4">
<p>⼀个<strong>可选</strong>的包含请求相关数据的<strong>正文</strong> (比如 HTML 表单内容)，或者响应相关的文档。正文的大小有起始行的 HTTP 头来指定。</p>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223163423238.png" alt="image-20230223163423238"></p>
</li>
</ol>
<h4 id="1-1-4-2-请求方法">1.1.4.2. 请求方法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>GET ：从服务器获取URL对应的资源</p>
</li>
<li class="lvl-2">
<p>HEAD ：除了服务器响应中<strong>不能包含消息体</strong>，该方法与GET⼀样。HEAD请求方法作用是<strong>只请求头部</strong></p>
</li>
<li class="lvl-2">
<p>POST ：被设计用来注解、修改URL所对应的资源</p>
</li>
<li class="lvl-2">
<p>PUT ：被设计用来修改或创建资源。当URL对应的资源存在时，则提交的作为新版本，否则新建资源</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2">区别：PUT 方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个 POST 可能会带来额外的影响，比如多次提交订单。</li>
</ul>
</blockquote>
</li>
<li class="lvl-2">
<p>DELETE ：被设计用来删除URL对应的资源</p>
</li>
<li class="lvl-2">
<p>TRACE ：主要用来测试。服务器将最终接收到的请求本身发送回来，作为客户端诊断依据</p>
</li>
<li class="lvl-2">
<p>OPTIONS ：客户端<strong>查询</strong>服务器对与某 URL <strong>允许的通信选项</strong></p>
</li>
<li class="lvl-2">
<p>CONNECT ：保留的方法名，用于代理切换隧道</p>
</li>
</ul>
<h4 id="1-1-4-3-HTTP-头域-头部">1.1.4.3. HTTP 头域/头部</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>通用头标：即可用于请求，也可用于响应，是作为⼀个整体而不是特定资源与事务相关联。</p>
</li>
<li class="lvl-2">
<p>请求头标：允许客户端传递关于自身的信息和希望的响应形式。</p>
</li>
<li class="lvl-2">
<p>响应头标：服务器和于传递自身信息的响应。</p>
</li>
<li class="lvl-2">
<p>实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。</p>
</li>
</ul>
<h4 id="1-1-4-4-响应状态行">1.1.4.4. 响应状态行</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>http协议版本</p>
</li>
<li class="lvl-2">
<p>状态码（三位数字）</p>
</li>
<li class="lvl-2">
<p>状态描述</p>
</li>
</ul>
<p>如 <code>HTTP/1.1 200 OK</code></p>
<p><strong>状态码</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信息响应 (100–199)</p>
</li>
<li class="lvl-2">
<p>成功响应 (200–299)</p>
</li>
<li class="lvl-2">
<p>重定向消息 (300–399)</p>
</li>
<li class="lvl-2">
<p>客户端错误响应 (400–499)</p>
</li>
<li class="lvl-2">
<p>服务端错误响应 (500–599)</p>
</li>
</ul>
<p><strong>常用状态码</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>200 OK</p>
</li>
<li class="lvl-2">
<p>301 Moved Permanently 搜索引擎会删除原页面，收录重定向的页面，并转移权重</p>
</li>
<li class="lvl-2">
<p>302 Found 是一种临时性的重定向，大部分搜索引擎把它作为内部的重定向，不会缓存重定向的结果</p>
</li>
<li class="lvl-2">
<p>400 Bad Request</p>
</li>
<li class="lvl-2">
<p>401 Unauthorized</p>
</li>
<li class="lvl-2">
<p>403 forbidden</p>
</li>
<li class="lvl-2">
<p>404 Not Found 搜索引擎放弃对该链接的索引</p>
</li>
<li class="lvl-2">
<p>500 Internal Server Error</p>
</li>
</ul>
<h2 id="1-2-网络机器人">1.2. 网络机器人</h2>
<ol>
<li class="lvl-3">
<p>网络爬虫是以<strong>自动方式</strong>爬取万维网上信息的计算机程序；主要是用来从网页搜集信息/支持搜索引擎/开展数据分析等等</p>
</li>
<li class="lvl-3">
<p>传统爬虫：传统爬虫从一个或若干初始网页的 URL 开始，获得初始网页上的 URL ，在抓取网页的过程中不断从<strong>当前页面上抽取新的 URL 放入队列</strong> 直到满足系统的一定停止条件</p>
</li>
<li class="lvl-3">
<p><strong>网络爬虫排除标准</strong>：</p>
<p>Robots Exclusion Protocol，网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些不能抓取。</p>
<p>robots 是一个协议。robots.txt 文件是一个文本文件，放置在网站根目录下</p>
</li>
</ol>
<h2 id="1-3-web">1.3. web</h2>
<h3 id="1-3-1-Web-的发展">1.3.1. Web 的发展</h3>
<ol>
<li class="lvl-3">
<p>Web x.0 表示 的是一个阶段，是促成这个阶段的各种技术和相关产品服务的一个称呼</p>
</li>
<li class="lvl-3">
<p>Web1.0 网站提供给用户的内容是网站编辑<strong>进行编辑处理后提供的</strong>，用户阅读网站提供的内容。这个过程是<strong>网站到用户的单向行为</strong>，比如搜狐等，静态网页为主。</p>
</li>
<li class="lvl-3">
<p>Web2.0 则是以加强了<strong>网站与用户</strong>之间的互动，网站内容<strong>基于用户提</strong>供，网站的诸多功能也由<strong>用户参与建设</strong>，实现了网站与用户<strong>双向的交流与参与</strong>，比如博客中国等。</p>
</li>
<li class="lvl-3">
<p>web3.0 是以<strong>主动性、数字最大化、多维化</strong>等为特征的，以<strong>服务</strong>为内容的第三代互联网系统。</p>
</li>
</ol>
<h3 id="1-3-2-Web-前端的发展趋势">1.3.2. Web 前端的发展趋势</h3>
<ol>
<li class="lvl-3">
<p>静态页面 到 动态页面</p>
</li>
<li class="lvl-3">
<p>Ajax 到 JIT(即时编译)，REST，SPA(单页Web应用)</p>
</li>
<li class="lvl-3">
<p>交互、UI、逻辑 到 Nodejs 大前端、同构（同一份代码在浏览器端和服务器端都可以运行）趋势</p>
</li>
</ol>
<h3 id="1-3-3-MEAN">1.3.3. MEAN</h3>
<ol>
<li class="lvl-3">
<p>Mean：Mongo Express Angular Node，是一个 Javascript 平台的现代 Web 开发框架总称</p>
<ol>
<li class="lvl-6">MongoDB 是一个使用JSON 风格存储的数据库，非常适合 javascript。(JSON 是 JS 数据格式 )</li>
<li class="lvl-6">ExpressJS 是一个 Web 应用框架，提供有帮助的组件和模块帮助建立一个网站应用。</li>
<li class="lvl-6">AngularJS 是一个前端 MVC 框架。</li>
<li class="lvl-6">Node.js 是一个<strong>并发异步</strong> <strong>事件驱动</strong>的 Javascript 服务器后端开发平台。</li>
</ol>
</li>
</ol>
<h1>2. 浏览器端</h1>
<h2 id="2-1-HTML-XHTML">2.1. HTML/XHTML</h2>
<ol>
<li class="lvl-3">
<p>HTML：标记语言，结构化特征。</p>
</li>
<li class="lvl-3">
<p><a href = "https://www.cnblogs.com/web-wjg/p/7240985.html">优雅降级与渐进增强</a></p>
<ol>
<li class="lvl-6"><strong>渐进增强（Progressive Enhancement）</strong>：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</li>
<li class="lvl-6"><strong>优雅降级（Graceful Degradation）</strong>：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 <strong>CSS3 的特性构建了一个应用</strong>，然后逐步针对各大浏览器进行 hack 使其可以在<strong>低版本浏览器上正常浏览。</strong></li>
<li class="lvl-6"><strong>向上兼容</strong>和<strong>向下兼容</strong>的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容</li>
</ol>
</li>
</ol>
<h3 id="2-1-1-结构、表现、行为">2.1.1. 结构、表现、行为</h3>
<p><strong>结构：</strong></p>
<ol>
<li class="lvl-3">
<p>DOCTYPE：声明了使用的文档类型定义（DTD）</p>
</li>
<li class="lvl-3">
<p>Head：包含元数据，一般只需要 title 标签</p>
</li>
<li class="lvl-3">
<p>Body：需要渲染的文本</p>
</li>
</ol>
<p><strong>HTML 工作流程</strong>：</p>
<ol>
<li class="lvl-3">
<p>HTML 通过标记符标记要显示的网页的各个部分，通过添加标记符来确定内容格式，从而令浏览器知道如何显示网页</p>
</li>
<li class="lvl-3">
<p>浏览器按顺序阅读 HTML 文件，然后<strong>根据 HTML 标记符解释和显示各种内容</strong>，这就是语法分析过程</p>
</li>
<li class="lvl-3">
<p>HTML 中的超链接功能使得网页之间能够链接起来从而提供跳转功能</p>
</li>
</ol>
<h3 id="2-1-2-基本语法、常用标记">2.1.2. 基本语法、常用标记</h3>
<p><strong>常用标记</strong>：</p>
<p><strong>块级元素</strong>：<code>&lt;h1&gt;~&lt;h6&gt;,&lt;p&gt;,&lt;div&gt;,&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;</code></p>
<p><strong>行内元素</strong>：<code>&lt;a&gt;,&lt;strong&gt;,&lt;b&gt;,&lt;em&gt;,&lt;del&gt;,&lt;span&gt;</code></p>
<ol>
<li class="lvl-3">
<p>注释</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>上线产品不要包含注释：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>注释（明文传播）会提高页面被解读的风险</p>
</li>
<li class="lvl-5">
<p>注释会增加传输带宽消耗</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>title</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>描述网页标题</p>
</li>
<li class="lvl-5">
<p>位于 head 标签之间</p>
</li>
<li class="lvl-5">
<p>精简且语义化强的描述能吸引爬虫</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>meta</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>描述网页<strong>元数据</strong></p>
</li>
<li class="lvl-5">
<p>位于 head 标签之间</p>
</li>
<li class="lvl-5">
<p>其 Charset 属性在实际中非常重要</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>p</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>用于表示段落，位于 body 之间</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>br</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>在 HTML 中，&lt;br&gt;标签没有结束标签。</p>
</li>
<li class="lvl-5">
<p>在 XHTML 中，&lt;br&gt; 标签必须被正确地关闭，比如这样：&lt;br /&gt;。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>a</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>指向其他页面的链接</p>
</li>
<li class="lvl-5">
<p>使用 href 属性来指定目的 url，可以是绝对路径或相对路径</p>
</li>
<li class="lvl-5">
<p>行级元素，<strong>要在 p 或 h1 等块级元素中</strong></p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>img</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>向页面中插入图片</p>
</li>
<li class="lvl-5">
<p>src 属性指定了图片 url</p>
</li>
<li class="lvl-5">
<p>xhtml 还需要 alt 属性</p>
</li>
<li class="lvl-5">
<p>在 a 标签之间放置会变为链接</p>
</li>
<li class="lvl-5">
<p>.git 和 .png 无损，.jpeg 和 .webp 有损</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>table，tr，td，th，caption</p>
<ul class="lvl-2">
<li class="lvl-5">table 代表表体</li>
<li class="lvl-5">caption 是标题</li>
<li class="lvl-5">tr 表示一行，th 表示表头，td 表示值</li>
</ul>
</li>
<li class="lvl-3">
<p>quotation</p>
<ul class="lvl-2">
<li class="lvl-5">blockquote 是段落引用，可以用于 p 标签外将段落变为引用格式（斜体）</li>
<li class="lvl-5">q 是行内引用，可以用于单词两边，效果是添加上双引号</li>
</ul>
<p><strong>为什么不直接用引号而用 &lt;q&gt;</strong>：</p>
<ol>
<li class="lvl-6">
<p><strong>XHTML</strong> 不应该包含字面引号字符，它们应该被写成 &amp;quot</p>
</li>
<li class="lvl-6">
<p>用 &lt;q&gt; 能让我们将 <strong>CSS 样式应用于引号</strong></p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>form</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>用于在网页上创建 GUIs，目的通常是向用户请求信息</p>
</li>
<li class="lvl-6">
<p>其参数指定 js 如何将信息传至服务器</p>
<ul class="lvl-4">
<li class="lvl-8"><strong>action</strong> 指定 submit 按下后数据送往的<strong>地点</strong></li>
<li class="lvl-8"><strong>method</strong> 默认为 <strong>GET</strong>，能以 ?{form_data} 形式传出，data 全为 ASCII 码且不超过 100 字符；POST 将 data 放置于 body 部分</li>
<li class="lvl-8"><strong>target</strong> 指定<strong>响应页面的打开方式（当前或新窗口）</strong></li>
</ul>
</li>
<li class="lvl-6">
<p>form 元素有 button，checkbox，text，radio</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>input</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>强大，但从语义化角度讲<strong>不是好的设计</strong>，因为<strong>具体样式渲染要等读到 type 属性值</strong>才能确定</p>
</li>
<li class="lvl-6">
<p>不需要 JS，H5 新增原生日期、颜色选择器以及其他新类型，提供客户端表单验证机制和旋转框、滑块</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>canvas</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>提供本地绘画功能</p>
</li>
<li class="lvl-6">
<p>可用于图表、图像、动画和像素处理等</p>
</li>
<li class="lvl-6">
<p>支持 2D 和 3D 效果</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>video&amp;audio</p>
<ul class="lvl-2">
<li class="lvl-6">提供非插件式视频&amp;音频支持，可以用 JS 进行操作，CSS 进行渲染</li>
<li class="lvl-6">能像添加图片一样添加</li>
<li class="lvl-6">可以使用内容，有完整的 JS API 供使用</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-html-语义化">2.1.3. html 语义化</h3>
<ol>
<li class="lvl-3">
<p><strong>语义化：根据结构化内容选择合适标签</strong></p>
<ol>
<li class="lvl-6">简单来说就是用特定的标签体现相对应的功能</li>
<li class="lvl-6">将内容和功能展示分离</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>为什么？</strong></p>
<ol>
<li class="lvl-6">有利于 SEO(Search Engine Optimization)</li>
<li class="lvl-6">开发维护体验好</li>
<li class="lvl-6">用户体验好</li>
<li class="lvl-6">更好的可访问性，方便任何设备对代码解析。</li>
</ol>
</li>
</ol>
<h3 id="2-1-4-html5-新特性——为什么选择-H5">2.1.4. html5 新特性——为什么选择 H5</h3>
<ol>
<li class="lvl-3">
<p><strong>语义化</strong>的元素（如header，nav，article，aside，footer标签）</p>
</li>
<li class="lvl-3">
<p><strong>表单验证</strong>功能：<code>&lt;input type=email required&gt;</code></p>
</li>
<li class="lvl-3">
<p><strong>语法简化</strong>：简化了解析的标题<code>&lt;!DOCTYPE html&gt;</code></p>
</li>
<li class="lvl-3">
<p><strong>统一</strong>：支持所有语言。</p>
</li>
<li class="lvl-3">
<p><strong>减少对外部插件的需求</strong> ( 比如 Flash)：支持很多复杂的特性 ( 视频音频图像 ) 而不需要安装插件，<strong>原生支持</strong></p>
<ol>
<li class="lvl-6">插件可能安装失败、被禁用、被屏蔽，或者成为被攻击的对象。</li>
</ol>
</li>
<li class="lvl-3">
<p>默认的<strong>安全性</strong>：HTML 为 iframe 元素添加了 sandbox 属性，防止不信任的 Web 页面某些操作。</p>
</li>
<li class="lvl-3">
<p>平滑降级：旧浏览器中新的表单控件会<strong>平滑降级</strong>，将 input $\rightarrow$ text</p>
</li>
<li class="lvl-3">
<p>不建议过多的使用 div，因为其是无语言元素</p>
</li>
<li class="lvl-3">
<p><strong>新输入类型-color、date</strong></p>
</li>
<li class="lvl-4">
<p><strong>audio&amp;video</strong> 标签</p>
</li>
<li class="lvl-4">
<p><strong>Canvas</strong> 像素级操作，放大缩小会变形</p>
</li>
<li class="lvl-4">
<p><strong>SVG</strong> 矢量量图</p>
</li>
<li class="lvl-4">
<p>新元素：article section footer nav mark</p>
</li>
<li class="lvl-4">
<p>更优秀的<strong>错误处理</strong></p>
</li>
<li class="lvl-4">
<p>早前本地存储使用的是 <strong>cookie</strong>，但是Web 存储更加的安全与快速</p>
<p><strong>客户端存储数据的两个对象</strong>为：【js可以从这里面获取需要的数据】</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>localStorage</strong> - 用于<strong>长久</strong>保存整个网站的数据，保存的数据<strong>没有过期时间</strong>，直到手动去除。</p>
</li>
<li class="lvl-6">
<p><strong>sessionStorage</strong> - 用于<strong>临时</strong>保存同一窗口(或标签页)的数据，在<strong>关闭窗口</strong>或标签页之后将会<strong>删除</strong>这些数据。</p>
</li>
</ul>
<p>HTML5 引⼊了<strong>应用程序缓存</strong>，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。通过创建 <strong>cache manifest</strong> 文件，可以轻松地创建 <strong>web 应用的离线版本</strong></p>
</li>
</ol>
<h3 id="2-1-5-向前兼容-IE">2.1.5. 向前兼容 IE</h3>
<p>越来越多的站点开始使用HTML5标签。但情况是还有很多人在使用IE6，IE7，IE8。为了让所有网站浏览者都能正常的访问网站，有两种解决办法：</p>
<ol>
<li class="lvl-3">
<p>为<strong>网站创建多套模板</strong>，通过程序对User-Agent的判断给<strong>不同的浏览器用户显示不同的页面</strong>，比如<strong>优酷网</strong>就是采用的这种模式。</p>
</li>
<li class="lvl-3">
<p>使用<strong>Javascript</strong>来<strong>使不支持HTML5的浏览器支持HTML标签</strong>。很多网站采用的这种方式。</p>
</li>
</ol>
<p>针对IE浏览器比较好的解决方案是<strong>html5shiv</strong>。<strong>html5shiv主要解决HTML5提出的新的元素不被IE6-8识别</strong>。</p>
<h2 id="2-2-CSS">2.2. CSS</h2>
<p>Cascading Style Sheets</p>
<p>$css \rightarrow css2 \rightarrow css2.1 \rightarrow css3$</p>
<p>css 由<strong>选择器+声明块</strong>组成。</p>
<h3 id="2-2-1-CSS-优势">2.2.1. CSS 优势</h3>
<ol>
<li class="lvl-3">
<p>丰富的<strong>样式定义</strong></p>
</li>
<li class="lvl-3">
<p><strong>灵活</strong>：易于使用和修改</p>
</li>
<li class="lvl-3">
<p><strong>简洁、清晰</strong></p>
</li>
<li class="lvl-3">
<p>多页面应用</p>
</li>
<li class="lvl-3">
<p><strong>多设备兼容性</strong>：样式表允许针对多种不同类型的设备进行优化内容。</p>
</li>
<li class="lvl-3">
<p><strong>减少开发成本与维护成本</strong></p>
</li>
<li class="lvl-3">
<p><strong>提高页面性能</strong></p>
</li>
</ol>
<h3 id="2-2-2-CSS-2-1，3-新特性">2.2.2. CSS 2.1，3 新特性</h3>
<ol>
<li class="lvl-3">
<blockquote>
<p>CSS 2.1：<strong>选择器、媒体类型、盒模型</strong>、tables、分级媒体。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>CSS 3：<strong>模块化、使用特定于浏览器的前缀</strong>[<em>确保这种属性只在特定的浏览器渲染引擎下才能识别和生效</em>]、<strong>web字体、显著提高性能</strong>，比如<strong>圆角、渐变、变换和过渡</strong>等。</p>
</li>
</ol>
<h3 id="2-2-3-选择器">2.2.3 选择器</h3>
<ol>
<li class="lvl-3">
<p><strong>id选择器</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>标有特定 id 的 HTML 元素指定特定的样式。</p>
<ul class="lvl-2">
<li class="lvl-5">下面的样式规则将应用于有<strong>属性id=“para1&quot;的元素</strong>
<ul class="lvl-4">
<li class="lvl-7"><code>#para1 &#123;text-align:center;color:red;&#125;</code></li>
<li class="lvl-7"><code>&lt;p id='para1'&gt;&lt;/p&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>class选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>class 选择器在 <strong>HTML</strong> 中以 <strong>class 属性</strong>表示, 在 CSS  中，<strong>类选择器以一个点 . 号显示</strong></p>
<ul class="lvl-4">
<li class="lvl-7">在以下的例⼦中，所有拥有 center 类的 HTML 元素均为居中
<ul class="lvl-6">
<li class="lvl-9">.center {text-align:center;}</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-5">
<p>可以在前面加上<strong>标签限定</strong></p>
<ul class="lvl-4">
<li class="lvl-7">
<p>如 <code>span.classy &#123;&#125;</code> 就只作用于下面的 HTML 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;classy&quot;</span>&gt;</span>Here&#x27;s a span with some text.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>标签选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">指定所有的该标签的样式</li>
</ul>
<ul class="lvl-2">
<li class="lvl-5">
<p>p{color:red;text-align:center;}选择 p 标签</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>属性选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>这组选择器根据一个元素上的某个标签的属性<strong>是否存在</strong>以选择元素的不同方式：</p>
<ul class="lvl-4">
<li class="lvl-7">[title]{color:blue;}</li>
</ul>
</li>
<li class="lvl-5">
<p>或者根据一个<strong>标签</strong>的特定属性是否存在来选择：</p>
<ul class="lvl-4">
<li class="lvl-7">&lt;h1 title=“Hello world”&gt;Hello world&lt;/h1&gt;</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>伪类选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>使用 <code>:</code></p>
</li>
<li class="lvl-5">
<p>CSS伪类是用来添加一些<strong>选择器的特殊效果</strong>（如 hover、点击等）</p>
</li>
<li class="lvl-5">
<p>如下设置不同状态的链接的颜色</p>
<ul class="lvl-4">
<li class="lvl-7">a:link {color:#000000;} /* 未访问链接*/</li>
<li class="lvl-7">a:visited {color:#00FF00;} /* 已访问链接 */</li>
<li class="lvl-7">a:hover {color:#FF00FF;} /* ⿏标移动到链接上 */</li>
<li class="lvl-7">a:active {color:#0000FF;} /* ⿏标点击时 */</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>伪元素选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>使用 <code>::</code></p>
</li>
<li class="lvl-5">
<p>伪元素，选择一个元素的<strong>某个部分</strong>而不是元素自己。例如，<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 每一个 &lt;p&gt; 元素的第一行。 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>组合选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>后代选择器(以空格分隔)，所有的后代</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163406345.png" alt="image-20230222163406345"></p>
</li>
<li class="lvl-5">
<p>子元素选择器(以大于号分隔）【标签元素的<strong>第一代子元素</strong>】</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163325138.png" style="zoom:50%;" />
<blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221126211305232.png" alt="image-20221126211305232"></p>
<p>div input后代选择器会把放在 <p> 中的 input 也选中，而div&gt;input子元素选择器只会选中 input type=text</p>
</blockquote>
</li>
<li class="lvl-5">
<p>相邻兄弟选择器（以加号分隔）</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163629160.png" alt="image-20230222163629160" style="zoom: 50%;" />
</li>
<li class="lvl-5">
<p>后续兄弟选择器（波浪号分隔)</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163638709.png" alt="image-20230222163638709" style="zoom:50%;" />
</li>
</ul>
<p>相邻只选择后面的<strong>一个</strong>，后续则选择后续的<strong>所有</strong></p>
</li>
</ol>
<h3 id="2-2-4-层叠">2.2.4 层叠</h3>
<ol>
<li class="lvl-3">
<p>样式表的三个层次，按照从底层到高层的顺序，分别为</p>
<ol>
<li class="lvl-6"><strong>行内样式表</strong></li>
<li class="lvl-6"><strong>嵌入样式表</strong></li>
<li class="lvl-6"><strong>外部样式表</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>浏览器能够像获取其他文档那样获取样式表文件。标签<code>&lt;link&gt;</code>用于指定外部样式表。</p>
</li>
<li class="lvl-3">
<p><strong>规则</strong>：</p>
<ol>
<li class="lvl-6">使用建议：外部 &gt; 内部 &gt; 内联</li>
<li class="lvl-6">一般不使用内联，因为只能声明一个元素，<strong>不能复用</strong></li>
<li class="lvl-6"><strong>外部样式表是最好的</strong>，可复用</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>CSS 来源优先级</strong>：【从上到下是由低到高】</p>
<ol>
<li class="lvl-6">用户代理样式表中的常规声明（<strong>例如，浏览器的默认样式，在没有设置其他样式时使用</strong>）</li>
<li class="lvl-6">用户样式表中的常规声明（<strong>由用户设置的自定义样式</strong>）</li>
<li class="lvl-6">作者样式表中的常规声明（<strong>这些是我们 web 开发人员设置的样式</strong>）。</li>
<li class="lvl-6">作者样式表中的 !important 声明</li>
<li class="lvl-6">用户样式表中的 !important 声明</li>
<li class="lvl-6">用户代理样式表中的 !important 声明</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>样式冲突的处理规则</strong>：</p>
<ol>
<li class="lvl-6">
<p><strong>资源顺序</strong></p>
<ul class="lvl-4">
<li class="lvl-8">当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，<strong>CSS 中最后的那个声明将会被应用到元素上</strong></li>
</ul>
</li>
<li class="lvl-6">
<p><strong>优先级</strong></p>
<ul class="lvl-4">
<li class="lvl-8">
<p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的<strong>每一种选择器的类型的数值</strong>决定。</p>
</li>
<li class="lvl-8">
<p><strong>左面的最大</strong>，数位之间没有进制，级别之间不可超越。</p>
</li>
<li class="lvl-8">
<p><strong>ID属性</strong>的数量——<strong>类</strong>和<strong>属性选择器</strong>和<strong>伪类</strong>的数量——<strong>元素名</strong>和<strong>伪元素</strong>的数量</p>
</li>
<li class="lvl-8">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221128151322960.png" alt="image-20221128151322960"></p>
<p>(上图最后：<code>:not()</code> 伪类的优先级将由其逗号分割的参数中<strong>优先级最高的选择器指定</strong>)</p>
</li>
<li class="lvl-8">
<p><strong>每个!important值：无穷大</strong></p>
<blockquote>
<p>内联样式和 !important 都被认为是非常不好的做法，但是有时你可以在 CSS 文件里用 !important 去覆盖内联样式。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>继承</strong>：</p>
<p>可以被继承： <code>color</code>、<code>text-align</code> 和 <code>font-family</code></p>
<p>不会被继承：<code>width</code>、<code>margin</code>、<code>padding</code> 和 <code>border</code></p>
</li>
</ol>
<h3 id="2-2-5-CSS-盒模型">2.2.5. CSS 盒模型</h3>
<ol>
<li class="lvl-3">
<p>所有元素都是一个盒子</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123110911988.png" alt="image-20221123110911988"></p>
</li>
<li class="lvl-3">
<p>元素总宽度 $=width + border_{left} + border_{right} + magin_{left} + magin_{right} + padding_{left} + padding_{right}$</p>
</li>
<li class="lvl-3">
<p>元素总高度 $=height + border_{top} + border_{bottom} + magin_{top} + magin_{bottom} + padding_{top} + padding_{bottom}$</p>
</li>
<li class="lvl-3">
<p>Internet Explorer 默认使用的<strong>怪异盒模型</strong>，与上面的不同的是 height 和 weight 包含了填充和边框。</p>
<p>通过设置 <code>box-sizing: border-box</code> 可以告诉浏览器使用怪异盒模型</p>
</li>
</ol>
<h3 id="2-2-6-布局">2.2.6. 布局</h3>
<p><strong>正常流：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从左到右，从上到下</p>
</li>
<li class="lvl-2">
<p>如果两个相邻的元素都设置了 margin 并且两个 margin 有重叠，那么更大的设置会被保留，小的则会消失 — 这被称为<strong>外边距叠加。</strong></p>
</li>
</ul>
<p><strong>脱离正常流</strong>：</p>
<ol>
<li class="lvl-3">
<p>absolute：相对<strong>最近绝对定位的祖先</strong>，如果没有那么选择文档主体</p>
</li>
<li class="lvl-3">
<p>relative：相对其正常流中的位置进行定位</p>
</li>
<li class="lvl-3">
<p>fixed：相对视口定位，滚动页面也不改位置</p>
</li>
<li class="lvl-3">
<p>static：HTML 元素默认 static，静态定位元素不受 top 等的影响</p>
</li>
<li class="lvl-3">
<p>sticky：它的行为就像 <strong>position:relative;</strong> 而当<strong>页面滚动超出目标区域</strong>时，它的表现就像 <strong>position:fixed;</strong>，它会固定在目标位置。</p>
</li>
<li class="lvl-3">
<p>float：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222174237171.png" alt="image-20230222174237171"></p>
</li>
</ol>
<h3 id="2-2-7-Formatting-Context-格式化上下文">2.2.7. Formatting Context 格式化上下文</h3>
<p>页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作 用。</p>
<ol>
<li class="lvl-3">
<p><strong>Block Formatting Context</strong> 块级格式化上下文 ref:<a href="https://juejin.cn/post/6950082193632788493">什么是BFC</a></p>
<p><code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素<strong>不会影响到外面</strong>的布局</p>
<ol>
<li class="lvl-6">
<p>触发<code>BFC</code>的<code>CSS</code>属性</p>
<ul class="lvl-4">
<li class="lvl-8">overflow 值不为 visible、clip 的块元素</li>
<li class="lvl-8">display: inline-block</li>
<li class="lvl-8">position: absolute</li>
<li class="lvl-8">position: fixed</li>
<li class="lvl-8">display: table-cell</li>
<li class="lvl-8">display: flex</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>BFC 规则</strong>：</p>
<ul class="lvl-4">
<li class="lvl-8">
<p><code>BFC</code>内部块级元素会在垂直方向一个接一个的排列</p>
</li>
<li class="lvl-8">
<p><code>BFC</code>就是页面中的一个<strong>隔离的独立容器</strong>，容器里的标签不会影响到外部标签</p>
</li>
<li class="lvl-8">
<p>垂直方向的距离由margin决定， 属于同一个<code>BFC</code>的两个相邻的标签<strong>外边距会发生重叠</strong></p>
</li>
<li class="lvl-8">
<p>计算<code>BFC</code>的高度时，<strong>浮动元素也参与计算</strong></p>
</li>
<li class="lvl-8">
<p>BFC的区域<strong>不会与float box重叠</strong></p>
</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>用途</strong>：</p>
<ul class="lvl-4">
<li class="lvl-8"><strong>高度塌陷</strong>：将父元素设置为 BFC【如设置 display: inline-block】可以解决了父元素未设置高度，而子元素设置浮动后，造成子元素脱离文档流无法把父元素撑开，父元素高度为 0 的问题。</li>
<li class="lvl-8"><strong>外边距重叠</strong>：如果想要消除两个相邻标签的外边距重叠，那么可以为其中一个元素包裹一个盒子形成一个完全独立的空间【如用 div 包裹】，里面元素不受外面布局影响</li>
<li class="lvl-8"><strong>排开外部浮动，避免重叠</strong>【实现多栏布局】：由于 BFC 不会和浮动块重叠，当一个块浮动时会覆盖原本在那个位置的，把原本那个位置的块设置为 BFC【如 display:flex】可以使原来的块移动到浮动元素的右边而不重叠</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<blockquote>
<p><strong>Inline Formatting Contexts 行内格式化上下文</strong> ref:<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122">IFC</a></p>
<ol>
<li class="lvl-3">
<p>触发条件：块级元素中仅包含行内元素</p>
</li>
<li class="lvl-3">
<p>规则：</p>
<ol>
<li class="lvl-6"><strong>横向</strong>的margin、border、padding属性对于这些行内元素都是有效的</li>
<li class="lvl-6">一个IFC内的元素都是⽔平排列的</li>
</ol>
</li>
<li class="lvl-3">
<p>IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</p>
</li>
<li class="lvl-3">
<p>用途：</p>
<ol>
<li class="lvl-6">
<p>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</p>
</li>
<li class="lvl-6">
<p>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。<strong>如下面的文本就能和图片垂直居中</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222190957264.png" alt="image-20230222190957264"></p>
</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="2-2-8-响应式网页设计，主要手段">2.2.8. 响应式网页设计，主要手段</h3>
<ol>
<li class="lvl-3">
<p>响应式网页设计 (RWD，Responsive Web Design)，可以自动识别屏幕宽度、并作出相应调整网页。</p>
</li>
<li class="lvl-3">
<p>曾经流行，不再是必不可少，原因：</p>
<ul class="lvl-2">
<li class="lvl-5">公司研发⼈员越来越充足，可以在pc端和移动端实现<strong>两套布局</strong>，分项目进行维护。</li>
</ul>
<p>仍有存在的价值：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>物联网领域，任何设备界面的响应布局。</p>
</li>
<li class="lvl-5">
<p>体现了CSS的<strong>灵活性</strong>。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>优点</strong>：网站可用性大大提升、简化服务器端、易维护、只提供给搜索引擎一个入口、可<strong>支持未知</strong>设备。</p>
</li>
<li class="lvl-3">
<p><strong>缺点</strong>：<strong>兼容设备导致性能低下</strong>、代码<strong>冗余</strong> ( 加载时间变长 )，<strong>限制应用复杂性</strong> ( 折衷的设计方案 )、<strong>用户混淆</strong> ( 改变了网站布局 )</p>
</li>
<li class="lvl-3">
<p>主要手段：</p>
<ol>
<li class="lvl-6">CSS <strong>媒体查询</strong> ( 不同屏幕分辨率，不同 CSS 规则 )</li>
<li class="lvl-6">不使用绝对大小，而使用<strong>相对大小</strong>:<code>width:20%/auto</code>、<code>px/em</code>【em 相对于当前对象内文本的字体尺寸。如当前对文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸 16px。】</li>
<li class="lvl-6"><strong>流动布局</strong></li>
<li class="lvl-6">图片<strong>自动缩放</strong></li>
</ol>
</li>
</ol>
<h2 id="2-3-javascript-重要">2.3. javascript 重要</h2>
<h3 id="2-3-1-基本语法">2.3.1. 基本语法</h3>
<blockquote>
<p>可以写在 body 中、head 中或外部文件中</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- body --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- head --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;My First JavaScript Function&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">   ! script commands and comments</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>JavaScript 拥有动态类型：这意味着相同的变量可用作不同的类型</p>
</li>
<li class="lvl-3">
<p><strong>大小写敏感</strong> (HTML 大小写不敏感)</p>
</li>
<li class="lvl-3">
<p>不指定类型，但有类型：<strong>Number, Boolean, String, Array, Object, Function, Null, Undefined</strong></p>
<ul class="lvl-2">
<li class="lvl-5">typeof()可以知道类型</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Number</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">数值在内部都是通过<strong>IEEE 754 64位双精度浮点型的形式</strong>表示的 (没有 int  double 的区别)</li>
<li class="lvl-5">运算符有<strong>自动的类型转换</strong>，Ex. “2” * 3 is 6</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>String</strong></p>
<ol>
<li class="lvl-6">没有 char 类型，一个字符也是存成 String</li>
<li class="lvl-6">+可以用来连接字符串</li>
<li class="lvl-6"><strong>1+1 is 2, but “1”+1 is “11”</strong></li>
<li class="lvl-6">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130104151749.png" alt="image-20221130104151749" style="zoom:50%;" />
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>Boolean</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>任何值都可以用作布尔值</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>false：0, -0, 0.0, NaN, “”, null, undefined</p>
</li>
<li class="lvl-7">
<p>true：其他的所有</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>将值显式转换为布尔值</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>var boolValue = Boolean(otherValue);</p>
</li>
<li class="lvl-7">
<p>var boolValue = <strong>!!</strong>(otherValue);</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130104636619.png" alt="image-20221130104636619"></p>
</li>
<li class="lvl-3">
<p><strong>逻辑运算符</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>大多数逻辑运算符会<strong>自动转换类型</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130104954720.png" alt="image-20221130104954720"></p>
<p>平常业务中比较建议尽量不要使用 == 和 !=。这两个比较的时候<strong>会做一些强制的类型转换</strong></p>
<p>务必使用 <strong>=== 和 !==</strong>。【严格的相等检查，不会进行类型转换，<strong>同时比较类型和值</strong>】</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>Ex. “5.0” === 5 is false</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Arrays</strong>：</p>
<ol>
<li class="lvl-6">两种初始化方式
<ul class="lvl-4">
<li class="lvl-8">var empty=[];</li>
<li class="lvl-8">var mycars=new Array();
<ul class="lvl-6">
<li class="lvl-10"><strong>var mycars=new Array(1, ‘22’, true)</strong>;也可以直接赋值，且数组中元素的类型可以不一样</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-6">不需要指定长度，在添加元素时根据需要自动增加</li>
</ol>
</li>
<li class="lvl-4">
<p><strong>Function</strong>：</p>
<ol>
<li class="lvl-7">
<p>function functionName(parameters) { // }</p>
</li>
<li class="lvl-7">
<p>箭头=&gt;函数，如：</p>
<p>(arg1, arg2) =&gt; {// code}</p>
</li>
<li class="lvl-7">
<p>匿名方法</p>
<p>(function (x,y) {return x+y}) (2,3);</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-3-2-严格模式">2.3.2. 严格模式</h3>
<ol>
<li class="lvl-3">
<p><strong>脚本或函数头</strong>使用添加<code>use strict;</code>的目的是指代码在严格条件下执行。</p>
</li>
<li class="lvl-3">
<p><strong>为什么使用严格模式</strong></p>
<ol>
<li class="lvl-6">消除 js 语法的一些<strong>不合理、不严谨的地方</strong>，减少怪异的行为</li>
<li class="lvl-6">消除代码运行的<strong>不安全</strong></li>
<li class="lvl-6">提供编译器效应，<strong>增加运行效率</strong></li>
<li class="lvl-6">为<strong>未来版本的 js 做好铺垫</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>严格模式限制：</p>
<ol>
<li class="lvl-6"><strong>变量必须声明后使用</strong></li>
<li class="lvl-6"><strong>函数参数不可以同名</strong></li>
<li class="lvl-6"><strong>不可以使用 with 语句</strong></li>
<li class="lvl-6">不能<strong>对只读属性赋值</strong></li>
<li class="lvl-6">不能使用<strong>前缀 0 表示八进制</strong></li>
<li class="lvl-6"><strong>不可以删除不可删除属性</strong></li>
<li class="lvl-6">不可以使用 delete prop 删除变量，只能删除属性 delete global[prop]</li>
<li class="lvl-6">eval 不会从它的外层作用域引入变量</li>
<li class="lvl-6">eval 和 arguments 不可以被重新赋值</li>
<li class="lvl-7">arguments 不会自动反应函数参数变化</li>
<li class="lvl-7">不能使用 <code>arguments.callee</code>和<code>.caller</code></li>
<li class="lvl-7">禁止<code>this</code><strong>指向全局对象</strong></li>
<li class="lvl-7">不能使用 fn<code>.caller</code>和<code>.arguments</code>获取函数调用的堆栈</li>
<li class="lvl-7">增加了保留字<code>protected</code>、<code>static</code>和<code>interface</code></li>
</ol>
</li>
</ol>
<h3 id="2-3-3-函数">2.3.3. 函数</h3>
<ol>
<li class="lvl-3">
<p>头等函数 (first-class function) 是指在程序设计语言中，函数被当作头等公民。</p>
</li>
<li class="lvl-3">
<p>函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中。在这样的语言中，函数的名字没有特殊含义，它们被当作具有函数类型的普通的变量对待。</p>
</li>
<li class="lvl-3">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223102211209.png" alt="image-20230223102211209" style="zoom:50%;" />
</li>
<li class="lvl-3">
<p><strong>匿名函数</strong>：</p>
<ol>
<li class="lvl-6">
<p>匿名函数就是声明一个函数不起名字。</p>
</li>
<li class="lvl-6">
<p>如果匿名函数只要一处调用，那么在调用处声明，调用完就销毁了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子：声明</span></span><br><span class="line"><span class="keyword">var</span> double = <span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="keyword">return</span> <span class="number">2</span> * x;&#125;</span><br><span class="line"><span class="comment">// 声明后立即调用</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(x + y);</span><br><span class="line">&#125;)(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="2-3-4-事件驱动编程">2.3.4. 事件驱动编程</h3>
<ol>
<li class="lvl-3">
<p>JavaScript <strong>事件</strong>允许脚本<strong>响应用户与网页上元素的交互</strong>，通过<strong>回调编程</strong>。JS 是采用<strong>事件驱动的机制来响应用户操作的</strong></p>
</li>
<li class="lvl-3">
<p>事件驱动编程是一种<strong>编程范式</strong>，其中程序流由<strong>事件决定</strong>，诸如用户操作(鼠标点击、按键)、传感器输出或来自其他程序/线程的消息</p>
</li>
<li class="lvl-3">
<p>在事件驱动应用中，会有 <strong>listener</strong> 主循环<strong>监听</strong>事件【事件需要<strong>注册</strong>才会被监听】，并且在被触发时调用一个 **callback **方法</p>
</li>
<li class="lvl-3">
<p><strong>语法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><code>element.addEventListener(event, function, useCapture);</code></p>
<ul class="lvl-4">
<li class="lvl-7">第⼀个参数是事件类型 (如&quot;click&quot; 或&quot;mousedown&quot;).</li>
<li class="lvl-7">第⼆个参数是我们想在事件发生时调用的回调函数.</li>
<li class="lvl-7">第三个参数是⼀个布尔值，是否在<strong>捕获</strong>时执行事件处理函数【<em>详见 DOM</em>】，是可选参数，默认 <code>false</code> 表示在事件<strong>冒泡</strong>阶段调用事件处理函数；如果参数为<code>true</code>，则表示在事件<strong>捕获</strong>阶段调用处理函数。</li>
</ul>
</li>
<li class="lvl-5">
<p><code>removeEventListener()</code> 方法删除已由 <code>addEventListener()</code> 方法注册的事件处理程序</p>
</li>
<li class="lvl-5">
<pre><code class="language-js">document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,  myFunction, true); document.getElementById(&quot;myDiv&quot;).removeEventListener(&quot;mousemove&quot;, myFunction);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3.5. 面向对象</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223104423246.png&quot; alt=&quot;image-20230223104423246&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">1. 用 JavaScript 实现类 JavaScritpt 没有专门的机制实现类，这里是借助**它的函数允许嵌套**的机制来实现类的。一个函数可以包含变量，又可以包含其它函数，这样，变量可以作为属性，内部的函数就可以作为成员方法了。因此外层函数本身就可以作为一个类了。</span><br><span class="line">2. 类声明：`function myClass() &#123; //此处相当于构造函数 &#125;`，这里 myClass 就是一个类。其实可以把它看成类的构造函数。至于非构造函数的部分，以后会详细描述。</span><br><span class="line">3. 类新建：`var obj1 = new myClass();`，JavaScript 提供了一个方法可以获得对象实例。即 new 操作符。其实 JavaScript 中，类和函数是同一个概念，当用 new 操作一个函数时就返回一个对象。</span><br><span class="line">4. 对象的成员的引用在 JavaScript 中引用一个类的属性或方法的方法有以下三种。</span><br><span class="line">   1. 点号操作符：这是一种最普遍的引用方式，就不累赘。即如下形式：`对象名.属性名; 对象名.方法名;`</span><br><span class="line">   2. 方括号引用：JavaScript 中允许用方括号引用对象的成员。如下：`对象名[&quot;属性名&quot;]; 对象名[&quot;方法名&quot;];`</span><br><span class="line">      1. 这里方括号内是代表属性或方法名的字符串，不一定是字符串常量。也可以使用变量。这样就可以使用**变量**传递属性或方法名。为编程带来了方便。在某些情况下，代码中不能确定要调用那个属性或方法时，就可以采用这种方式。否则，如果使用点号操作符，还需要使用条件判断来调用属性或方法。</span><br><span class="line">      2. 另外，使用方括号引用的属性和方法名还可以以**数字**开头，或者出现**空格**，而使用点号引用的属性和方法名则遵循标示符的规则。但一般不提倡使用非标示符的命名方法。</span><br><span class="line">   3. 迭代器遍历：`for item in obj`</span><br><span class="line">5. prototype 属性：每个构造函数有一个`prototype`属性，指向另一个**原型对象**，这个对象的所有属性和方法会被**所有对象实例所共享**</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// 每个实例对象的 type 和 eat 都是一样的，每次生成一些示例其实是重复的内容，多占用内存</span><br><span class="line">functlon Cat(name,color)&#123;</span><br><span class="line">   this.name = nane;</span><br><span class="line">   this.color = color;</span><br><span class="line">   this.type = &quot;猫科动物&quot;;</span><br><span class="line">   this.eat = function()&#123;alert(&quot;吃老鼠&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">// 使用 prototype 对象，那么创建的每个对象就不会重复相同的内容</span><br><span class="line">function Cat(name ,color)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.color = color ;</span><br><span class="line">)</span><br><span class="line">Cat.prototype.type = &quot;猫科动物&quot;;</span><br><span class="line">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-6-作用域、作用域链、闭包及其用途">2.3.6. 作用域、作用域链、闭包及其用途</h3>
<ol>
<li class="lvl-3">
<p>作用域是在<strong>运行时</strong>代码中的某些特定部分中变量、函数和对象的<strong>可访问性</strong>。<strong>子作用域可以访问父作用域， 反过来则不行</strong></p>
<ol>
<li class="lvl-6">
<p>最大作用：隔离变量，不同作用域下同名变量不会有冲突。</p>
</li>
<li class="lvl-6">
<p><strong>JS 作用域类型</strong></p>
<ol>
<li class="lvl-9">
<p><strong>全局作用域</strong>：</p>
<ul class="lvl-6">
<li class="lvl-11">最外层函数和最外层函数外声明的变量</li>
<li class="lvl-11"><strong>所有未定义直接赋值的变量</strong>，即自动全局</li>
<li class="lvl-11">所有 window 对象的属性</li>
</ul>
</li>
<li class="lvl-9">
<p><strong>模块作用域</strong>：</p>
<ul class="lvl-6">
<li class="lvl-11">模块模式中运行代码的作用域</li>
</ul>
</li>
<li class="lvl-9">
<p><strong>函数作用域</strong>：</p>
<ul class="lvl-6">
<li class="lvl-11">
<p>只能在函数中访问</p>
</li>
<li class="lvl-11">
<p>函数中可以访问全局等外部的，但是外部不可以访问内部的</p>
</li>
<li class="lvl-11">
<p><strong>ES6 之前</strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们<strong>不会创建一个新的作用域</strong>。在块语句中定义的变量将<strong>保留在它们当前存在的作用域中</strong>。即 <strong>变量提升</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name1 = <span class="string">&#x27;Tim&#x27;</span>;<span class="comment">// 是在全局作用域中的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1);<span class="comment">// &#x27;Tim&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name2 = <span class="string">&#x27;Ray&#x27;</span>;<span class="comment">// 是在函数作用域中的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-11">
<p><strong>函数提升</strong>：<strong>函数声明会被提升到顶部，但函数表达式不会</strong>，只是函数表达式左边的变量会被提升，在声明之前访问 baz 是 undefined，因此报错不是一个函数</p>
<ul class="lvl-8">
<li class="lvl-13">
<pre><code class="language-js">/* 函数声明 */
foo(); // &quot;bar&quot;
function foo() &#123;
 console.log(&quot;bar&quot;);
&#125;
/* 函数表达式 */
baz(); // 类型错误：baz 不是⼀个函数
var baz = function() &#123;
 console.log(&quot;bar2&quot;);
&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. **ES6**出现：**块级作用域**：&#123;&#125;创建</span><br><span class="line"></span><br><span class="line">   - 块级作用域可通过**新增命令 let 和 const 声明**，所声明的变量在指定块的作用域外无法被访问。</span><br><span class="line"></span><br><span class="line">   - **TDZ 暂时性死区**（英temporal dead zone），即代码块开始到变量声明语句完成之间的区域，不像 var，let 拥有暂时性死区，在这个区域内不能使用这个变量。</span><br><span class="line"></span><br><span class="line">   - ```js</span><br><span class="line">     //1. TDZ</span><br><span class="line">     &#123; </span><br><span class="line">      console.log(bar); // undefined，可以访问但是是未定义的，因为当前没有赋值 </span><br><span class="line">      console.log(foo); // ReferenceError，不能访问，有暂时性死区</span><br><span class="line">      var bar = 1;</span><br><span class="line">      let foo = 2; // End of TDZ (for foo)</span><br><span class="line">     &#125;</span><br><span class="line">     // 但下面这样是可以的，即暂时性的意思是取决于执行的顺序，而不是编写代码的顺序，func在暂时性死区外执行，因此可以</span><br><span class="line">     &#123;</span><br><span class="line">      // TDZ starts at beginning of scope</span><br><span class="line">     const func = () =&gt; console.log(letVar);</span><br><span class="line">     let letVar = 3; // End of TDZ (for letVar)</span><br><span class="line">     func();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //2. 声明变量不会提升到代码块顶部</span><br><span class="line">     function getValue(condition) &#123;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">           let value = &quot;blue&quot;;</span><br><span class="line">           return value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           // value 在此处不可用</span><br><span class="line">           return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // value 在此处不可用</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //3. 禁止重复声明，如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误，而声明var则可以</span><br><span class="line">     var count = 30;</span><br><span class="line">     let count = 40; // Uncaught SyntaxError: Identifier &#x27;count&#x27; has already been declared</span><br><span class="line">     </span><br><span class="line">     // 在嵌套作用域中不会抛出错误</span><br><span class="line">     var count = 30;</span><br><span class="line">     var condition = 1;</span><br><span class="line">     if (condition) &#123;</span><br><span class="line">        let count = 40;</span><br><span class="line">        // 其他代码</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //4. 循环中的绑定块作用域的妙用，如果使用 var 声明 i 的话，就会导致 i 成为全局变量，点击任何按钮都是输出4，因为i都变成了 4</span><br><span class="line">     for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">         button[i].onclick = function () &#123;</span><br><span class="line">           console.log(&#x27;第&#x27; + (i + 1) + &#x27;个&#x27;)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>作用域链</strong></p>
<ol>
<li class="lvl-6">
<p><strong>自由变量</strong>：当前的作用域没有定义的变量，找值则需要向（创建函数的）父级作用域查找，一直往上。</p>
<p>但<strong>注意</strong>：无论函数将在哪里调用，要到<strong>创建函数的那个父作用域中取</strong></p>
</li>
<li class="lvl-6">
<p>这种一层一层的查找父作用域的关系，就是<strong>作用域链</strong></p>
</li>
<li class="lvl-6">
<pre><code class="language-js">// 例 1
var x = 10
function fn() &#123;
  console.log(x)
&#125;
function show(f) &#123;
  var x = 20
  (function() &#123;
    f() //10，而不是 20
  &#125;)()
&#125;
show(fn)
// 例 2
var a = 10
function fn() &#123;
  var b = 20
  function bar() &#123;
    console.log(a + b) //30
  &#125;
  return bar
&#125;
var x = fn()
b = 200
x() //bar()
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   4. &gt; 作用域和执行上下文之间最大的区别是：</span><br><span class="line">      &gt;</span><br><span class="line">      &gt; **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。</span><br><span class="line"></span><br><span class="line">3. **闭包**</span><br><span class="line"></span><br><span class="line">   1. 是可以读取其他函数内部变量的函数</span><br><span class="line"></span><br><span class="line">   2. 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&quot;**定义在一个函数内部的函数**&quot;。</span><br><span class="line"></span><br><span class="line">   3. ```js</span><br><span class="line">      function f1()&#123;</span><br><span class="line">      　　var n=999;</span><br><span class="line">         // 匿名函数，本质也是闭包，nAdd是全局变量</span><br><span class="line">      　　nAdd=function()&#123;n+=1;&#125;</span><br><span class="line">         // f2 闭包函数</span><br><span class="line">         function f2()&#123;</span><br><span class="line">      　　　alert(n);</span><br><span class="line">      　　&#125;</span><br><span class="line">         return f2;</span><br><span class="line">      &#125;</span><br><span class="line">      // f2 被赋值被全局变量，因此 f2 一直在内存中，而 f2 依赖于 f1，于是 f1 也在内存中，而不会在调用结束后被垃圾回收机制回收。</span><br><span class="line">      var result=f1();</span><br><span class="line">      result(); // 999</span><br><span class="line">      nAdd();</span><br><span class="line">      result(); // 1000</span><br><span class="line">      </span><br><span class="line">      // 关于 this 的例子</span><br><span class="line">      // this 和调用时有关，而不是创建时</span><br><span class="line">      var name=&quot;XL&quot;;</span><br><span class="line">      var person=&#123;</span><br><span class="line">         name:&quot;xl&quot;,</span><br><span class="line">         showName:function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      person.showName();//  xl</span><br><span class="line">      //这里是 person 对象调用 showName 方法，很显然 this 关键字是指向 person 对象的，所以会输出 name</span><br><span class="line">      </span><br><span class="line">      var showNameA=person.showName;</span><br><span class="line">      showNameA();     //输出  XL</span><br><span class="line">      //这里将 person.showName 方法赋给 showNameA 变量，此时 showNameA 变量相当于 window 对象的一个属性，因此 showNameA() 执行的时候相当于 window.showNameA(),即 window 对象调用 showNameA 这个方法，所以 this 关键字指向 window</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li class="lvl-6">
<p>闭包用途</p>
<ol>
<li class="lvl-9">
<p>实现私有成员</p>
</li>
<li class="lvl-9">
<p>保护命名空间</p>
</li>
<li class="lvl-9">
<p>避免污染全局变量</p>
</li>
<li class="lvl-9">
<p>变量需要长期驻留内存</p>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>with</strong>——<strong>不使用</strong></p>
<ol>
<li class="lvl-6">
<p>不推荐使用with，在 ECMAScript 5 <strong>严格模式中该标签已被禁止</strong>。【出现 with js 引擎不进行任何优化，性能差，且可能会导致数据泄露问题】</p>
<p>推荐的替代方案是声明⼀个临时变量来承载你所需要的属性，如下面例子中的重复写 obj</p>
</li>
<li class="lvl-6">
<p>with 语句的原本用意是<strong>为逐级的对象访问提供命名空间式的速写方式</strong></p>
</li>
<li class="lvl-6">
<p>with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的<strong>某个属性同名</strong>，则这个<strong>局部变量会指向 obj 对象属性</strong>。</p>
</li>
<li class="lvl-6">
<pre><code class="language-js">// 例子
var obj = &#123;
	a: 1,
	b: 2,
	c: 3
&#125;;
// 重复写了3次的“obj”
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 如果使用with，则可以不用写
with (obj) &#123;
	a = 3;
	b = 4;
	c = 5;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. **this**：</span><br><span class="line"></span><br><span class="line">   **显式绑定**：通过call、apply、bind、new 确定指向</span><br><span class="line"></span><br><span class="line">   &gt; **call、apply、bind 都是用来改变 this 的指向的，第一个参数都是 this 要指向的对象。**</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; - call 只是临时改变一次 this 指向，并立即执行函数。但后面参数形式是 `obj.myFun.call(db,&#x27;成都&#x27;,&#x27;上海&#x27;)；`</span><br><span class="line">   &gt; - apply 只是临时改变一次 this 指向，并立即执行函数。但后面参数是 `obj.myFun.apply(db,[&#x27;成都&#x27;,&#x27;上海&#x27;]); `</span><br><span class="line">   &gt; - bind 返回一个永久改变 this 指向的函数，不会立即执行函数，它的参数形式和 call 一样。</span><br><span class="line"></span><br><span class="line">   **隐式绑定**：根据调用关系确定this指向</span><br><span class="line"></span><br><span class="line">   - 在函数体中，非显式或隐式地简单调用函数时，在**严格**模式下，函数内的this会被绑定到 **undefined **上，在**非严格模式下则会被绑定到全局对象 window **上【例子1，2】</span><br><span class="line"></span><br><span class="line">   - ⼀般通过上下文对象调用函数时，函数体内的 this 会被绑定到该对象上【例子3，4】</span><br><span class="line"></span><br><span class="line">     ```js</span><br><span class="line">      // 例子1</span><br><span class="line">      function f1() &#123;</span><br><span class="line">       console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">      function f2() &#123;</span><br><span class="line">       &quot;use strict&quot;;</span><br><span class="line">       console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">      f1(); // window</span><br><span class="line">      f2(); // undefined</span><br><span class="line">     </span><br><span class="line">     // 例子2</span><br><span class="line">     var foo = &#123;</span><br><span class="line">      bar: 10,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     var fn1 = foo.fn</span><br><span class="line">     fn1()// window，因为是用window来调用的</span><br><span class="line">     </span><br><span class="line">     // 例子3</span><br><span class="line">     var foo = &#123;</span><br><span class="line">      bar: 10,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      console.log(this.bar)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     foo.fn()// &#123;bar:10,fn:f&#125;，这里是由foo调用</span><br><span class="line">     </span><br><span class="line">     // 例子4</span><br><span class="line">     var o1 = &#123;</span><br><span class="line">      text: &#x27;o1&#x27;,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      	return this.text</span><br><span class="line">      &#125; &#125;</span><br><span class="line">     var o2 = &#123;</span><br><span class="line">      text: &#x27;o2&#x27;,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      	return o1.fn()</span><br><span class="line">      &#125; &#125;</span><br><span class="line">     var o3 = &#123;</span><br><span class="line">      text: &#x27;o3&#x27;,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      var fn = o1.fn</span><br><span class="line">      	return fn()</span><br><span class="line">      &#125; &#125;</span><br><span class="line">     console.log(o1.fn())// o1，o1调用</span><br><span class="line">     console.log(o2.fn())// o1，在o2中o1进行调用，因此o1中的this指向o1</span><br><span class="line">     console.log(o3.fn())// undefined，return fn()，直接调用函数，不指名this，则this默认指向window，即fn就是由window来调用的，而window中没有text属性，因此是undefined</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<ul class="lvl-2">
<li class="lvl-5">
<p>通过 <strong>call/apply/bind 方法显示调用函数</strong>时，函数体内的 this 会被绑定到<strong>指定参数的对象</strong>上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Tim&#x27;</span>,</span><br><span class="line"> <span class="attr">logName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;mike&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">logName</span>.<span class="title function_">call</span>(bar)<span class="comment">// mike</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>⼀般使用 new 方法调用构造函数时，<strong>构造函数内的 this 会被绑定到新创建的对象上</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="string">&quot;Tim&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">bar</span>)<span class="comment">// Tim</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>箭头函数<strong>不适用上面的规则</strong>，而是根据<strong>外层（函数或者全局）上下文</strong>来决定 this 的指向，始终指向外部对象，因为箭头函数没有<code>this</code>，因此它自身不能进行<code>new</code>实例化，同时也不能使用<code>call, apply, bind</code>等方法来改变<code>this</code>的指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类似上面的例子2</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line"> <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">     (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">     &#125;)()<span class="comment">// 匿名函数直接执行，因此是window</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">fn</span>())<span class="comment">// window</span></span><br><span class="line"><span class="comment">// 取决于外层上下文，箭头函数位于foo内，那么this指向foo</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line"> <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">     (<span class="function">() =&gt;</span> &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">     &#125;)()<span class="comment">// 箭头函数立即执行</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">fn</span>())<span class="comment">// &#123;fn:f&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">call</span>(obj2))<span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>foo.call(obj1) 使得使得 foo 中的 this 指向 obj1【因此箭头函数的 this 指向 obj1】，并立即执行 foo，因此 foo.call(obj1) 会返回一个<strong>箭头函数</strong>即 a =&gt; {console.log(this.a)}，并保存在 bar 中，而箭头函数不能直接对其修改 this 指向，因此 bar.call(obj2) 执行时，this 仍然是 指向 obj1。另外 call 不返回函数，因此 console.log(bar.call(obj2)) 输出 undefind</p>
<p>ref</p>
<ol>
<li class="lvl-3">
<p><a href = "https://www.cnblogs.com/fundebug/p/10535230.html">作用域、作用域链</a></p>
</li>
<li class="lvl-3">
<p><a href = "http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">学习 Javascript 闭包 (Closure)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://www.cnblogs.com/lisha-better/p/5684844.html">JS中this关键字详解</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/zwkkkk1/article/details/79725934">JavaScript中 with的用法</a></p>
</li>
<li class="lvl-3">
<p><a href="https://zhuanlan.zhihu.com/p/82340026">彻底弄懂bind，apply，call三者的区别 </a></p>
</li>
<li class="lvl-3">
<p><a href="https://www.runoob.com/w3cnote/js-call-apply-bind.html">JavaScript 中 call()、apply()、bind() 的用法</a></p>
</li>
</ol>
<h2 id="2-4-DOM-BOM">2.4. DOM BOM</h2>
<h3 id="2-4-1-XHTML-XML-与-DOM-树">2.4.1. XHTML/XML 与 DOM 树</h3>
<blockquote>
<h4 id="2-4-1-1-XHTML-XML">2.4.1.1. XHTML/XML</h4>
<ol>
<li class="lvl-3">HTML 语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对 于传统的电脑来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由 DTD 定义规则，语法要求更加严格的 XHTML。</li>
<li class="lvl-3">最大的变化在于<strong>所有标签必须闭合</strong>，也就是说开始标签要有相应的<strong>结束</strong>标签。另外，XHTML 中所有的<strong>标签必须小写</strong>。在 XHTML 中，<strong>所有的参数值，包括数字，必须用双引号括起来</strong>。</li>
</ol>
</blockquote>
<h4 id="2-4-1-2-DOM">2.4.1.2. DOM</h4>
<ol>
<li class="lvl-3">
<p>当一个网页被<strong>加载</strong>时，浏览器会创建一个页面的<strong>文档对象模型</strong>（Document Object Model，DOM)</p>
<p>HTML DOM模型被构造成一个<strong>对象树</strong></p>
</li>
<li class="lvl-3">
<blockquote>
<p>在应用程序中，基于 DOM 的 XML/HTML 分析器将一个 XML/HTML 文档转换成一个对象模型的集合 ( 通常称 DOM 树 )，应用程序正是通过对这个对象模型的操作，来实现对 XML/HTML 文档数据的操作</p>
</blockquote>
</li>
<li class="lvl-3">
<blockquote>
<p>XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法。</p>
</blockquote>
</li>
<li class="lvl-3">
<blockquote>
<p>HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><mark><strong>HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素以及处理和新建 HTML 事件的标准。</strong></mark></p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/2.png" alt=""></p>
<ol start="7">
<li class="lvl-3">
<p><strong>DOM编程接口</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>HTML DOM可以使用JavaScript</p>
</li>
<li class="lvl-5">
<p>所有 HTML 元素被<strong>定义为对象</strong></p>
</li>
<li class="lvl-5">
<p>编程接口是<strong>每个对象的属性和方法</strong></p>
<ul class="lvl-4">
<li class="lvl-7">
<p>属性是可以获取或设置的值(如<strong>更改</strong>HTML元素的<strong>内容</strong>)。</p>
<p>使用 <code>objectName.attributeName</code> 访问/修改 DOM 对象的属性</p>
</li>
<li class="lvl-7">
<p>方法是可以执行的操作(如<strong>添加</strong>或<strong>删除</strong>HTML元素)。</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>找元素</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">by id<br>
<code>document.getElementById(&quot;intro&quot;);</code></li>
<li class="lvl-5">by tag name<br>
<code>document.getElementsByTagName(&quot;p&quot;);</code></li>
<li class="lvl-5">by class name<br>
<code>document.getElementsByClassName(&quot;intro&quot;);</code></li>
<li class="lvl-5">by CSS selectors<br>
<code>document.querySelectorAll(&quot;p.intro&quot;);</code></li>
<li class="lvl-5">by HTML object collections<br>
<code>document.forms[&quot;frm1&quot;];</code></li>
</ul>
</li>
<li class="lvl-3">
<p>DOM <strong>树节点类型</strong>：</p>
<ol>
<li class="lvl-6">
<p>每个节点都有 nodeType，nodeName，nodeValue</p>
</li>
<li class="lvl-6">
<p>nodeType： Element、Text、Attr(属性节点)、Comment(注释节点)、Document(文档节点)</p>
</li>
<li class="lvl-6">
<p>如<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222200728788.png" alt="image-20230222200728788"></p>
<p>DOM 树就是：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222200950221.png" alt="image-20230222200950221"></p>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-2-DOM0，DOM2-事件流-捕获、目标和冒泡">2.4.2. DOM0，DOM2 事件流 ( 捕获、目标和冒泡 )</h3>
<h4 id="2-4-2-1-DOM0">2.4.2.1. DOM0</h4>
<ol>
<li class="lvl-3">
<p><strong>将一个函数赋值给一个事件处理属性</strong>。为所有浏览器所支持。</p>
<ol>
<li class="lvl-6">优点：简单高效，移除事件非常简单只要 element.onclick=null即可但</li>
<li class="lvl-6">缺点：多次赋值会覆盖之前的回调函数，如 <code>onclick=f;onclick=g</code>，因此<strong>一个事件处理程序只能对应一个处理函数。</strong></li>
</ol>
</li>
<li class="lvl-3">
<p><code>onxxx</code> 如 <code>onclick</code> 是 <code>DOM0</code> 级别的事件</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消绑定</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-2-DOM2">2.4.2.2. DOM2</h4>
<ol>
<li class="lvl-3">
<p>DOM2 事件引进了一种全新的绑定事件方法，添加了一些新的事件。现在的浏览器都支持这种绑定方式，也建议使用这种绑定方式。</p>
</li>
<li class="lvl-3">
<p><code>addEventListener</code>添加的事件处理程序，并通过<code>removeEventListener</code>来删除。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> hander = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数：事件处理属性名称、处理函数、是否在捕获时执行事件处理函数</span></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,handler,<span class="literal">false</span>/<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>,handler,<span class="literal">false</span>/<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>DOM2 级的事件规定<strong>事件流</strong>包含<strong>三个阶段</strong> ref:<a href="https://juejin.cn/post/7192584563799883832">JS中的事件冒泡、事件捕获、事件委托  推荐阅读</a></p>
<blockquote>
<p>当一个 HTML 元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为 DOM 事件流</p>
</blockquote>
<ol>
<li class="lvl-6">
<p><strong>捕获阶段</strong>：事件从Document节点<strong>自上而下向目标节点传播</strong>的阶段。</p>
</li>
<li class="lvl-6">
<p><strong>目标阶段</strong>：找到了被触发事件的元素对象，触发事件函数</p>
</li>
<li class="lvl-6">
<p><strong>冒泡阶段</strong>：从被触发事件的元素对象<strong>向上</strong>冒泡传递事件*（注意这里传递的仅仅是事件，而不是绑定的事件函数）*</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p>事件处理过程</p>
<ol>
<li class="lvl-6">
<p>document 首先接收到 click 事件，然后顺着 DOM 树逐级<strong>向下</strong>传递事件，如果在途中经过的节点<strong>定义了相同事件</strong>的处理函数且 <code>addEventListener</code> 第 3 个参数设定为 <code>true</code>【即在事件捕获阶段处理调用处理函数】，那么会调用这个节点的处理函数</p>
</li>
<li class="lvl-6">
<p>事件最终传递到目标节点，调用处理函数</p>
</li>
<li class="lvl-6">
<p>事件逐级向上传播回 document。同捕获阶段，但是第 3 个参数要设置为 <code>false</code>，默认 <code>false</code>。</p>
<p>有些时候我们不希望产生事件冒泡，所以可以<strong>在子事件中加入 <code>e.stopPropagation()</code></strong> 取消冒泡</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7e3d995dee743f8ac61fd09a4b2b3e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p>
</li>
<li class="lvl-6">
<p><strong>事件委托</strong>：</p>
<ol>
<li class="lvl-9">
<p>就是利用<strong>事件冒泡</strong>，把子元素的事件都<strong>绑定到父元素</strong>上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p>
</li>
<li class="lvl-9">
<p>比如给 1000 个按钮注册点击事件，可以采用给这个 1000 个按钮的父节点添加点击元素，并利用事件的 target 获取按钮的相关信息。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69430357f5d4101a7d423d42f723d22~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d4cf8b887a74bd5acf85290557b22e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-3-观察者模式">2.4.3. 观察者模式</h3>
<ol>
<li class="lvl-3">
<p>察者模式定义了一种一对多的依赖关系，<strong>让多个观察者 Observer 对象同时监听某一个主题 Subject 对象</strong>。这个主题对象在状态上发生变化时，会<strong>通知所有观察者对象</strong>，使它们能够自动更新自己。它主要用于<strong>实现分布式事件处理系统。</strong></p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/5.png" alt=""></p>
<h3 id="2-4-4-BOM">2.4.4. BOM</h3>
<p>ref: <a href="https://www.cnblogs.com/Renyi-Fan/p/8077854.html#_label1_0">浏览器对象模型(BOM)是什么?推荐阅读</a></p>
<p><strong>浏览器对象模型</strong>（Browser Object Model，简称 BOM）是 JavaScript 的组成部分之一，BOM 赋予了 JavaScript 程序<strong>与浏览器交互的能力</strong></p>
<blockquote>
<p>能利用BOM做什么？</p>
<ul class="lvl-1">
<li class="lvl-2">BOM提供了一些访问窗口对象的一些方法，我们可以用它来<strong>移动窗口位置</strong>，<strong>改变窗口大小</strong>，<strong>打开新窗口和关闭窗口</strong>，<strong>弹出对话框</strong>，进行导航以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率。但BOM最强大的功能是它提供了一个<strong>访问HTML页面的一入口——document对象</strong>，以使得我们可以通过这个入口来使用DOM的强大功能！</li>
</ul>
<p>DOM对象和BOM对象的关系？</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>DOM对象是BOM对象的大儿子。所以DOM对象的那些<strong>操作都是浏览器来执行的</strong></p>
</li>
</ul>
<p>BOM中的顶级对象是什么，代表什么意思？</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>BOM中的顶级对象是window，代表的是浏览器打开的一整个窗口</p>
</li>
</ul>
</blockquote>
<p>每个浏览器的 Javascript 程序都可以引用以下全局对象：document、history、location、navigator、screen、window</p>
<p><img src="https://images2018.cnblogs.com/blog/1163900/201805/1163900-20180530160230458-211891518.png" alt="img"></p>
<p><strong>document</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个载入浏览器的 HTML 文档都会成为 Document 对象</p>
</li>
<li class="lvl-2">
<p>Document 对象是 HTML 文档的根节点</p>
</li>
</ul>
<p><strong>window</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有浏览器都支持window对象。</p>
</li>
<li class="lvl-2">
<p>它表示浏览器的窗口所有JavaScript全局对象、函数和变量都自动成为窗口对象的成员。window 也是全局对象，可以直接使用</p>
</li>
</ul>
<p><strong>location</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Location 对象包含有关当前 URL 的信息</p>
</li>
</ul>
<p><strong>navigator</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>navigator 对象包含有关浏览器的信息</p>
</li>
<li class="lvl-2">
<p>来自navigator对象的信息通常会产生误导，不应该用于检测浏览器版本：因为所有者可以任意更改</p>
</li>
</ul>
<p><strong>screen</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>screen对象包含有关客户端显示屏幕的信息</p>
</li>
</ul>
<p><strong>history</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>history对象包含用（在浏览器窗口中）访问过的 URL</p>
</li>
</ul>
<h2 id="不考——2-5-Ajax">不考——2.5. Ajax</h2>
<h3 id="2-5-1-RIA-Rich-Internet-Applications-富互联网应用">2.5.1. RIA Rich Internet Applications 富互联网应用</h3>
<ol>
<li class="lvl-3">
<p>是一种具有近似于传统桌面应用软件系统<strong>功能和特性</strong>的网络应用系统。</p>
</li>
<li class="lvl-3">
<p>RIA 系统最大的<strong>特点</strong>是将大部分处理任务都从<strong>用户界面端移植到客户端</strong>，仅保留一些必要数据与服务器端进行信息交互。</p>
</li>
<li class="lvl-3">
<p>RIA 系统的特性：</p>
<ol>
<li class="lvl-6">运行于浏览器中，不需要额外安装支持软件</li>
<li class="lvl-6">在本地运行时，受安全沙箱全程保护。</li>
</ol>
</li>
<li class="lvl-3">
<p>优点</p>
<ol>
<li class="lvl-6">无需安装</li>
<li class="lvl-6">容易升级</li>
<li class="lvl-6">可以通过 Internet/intranet 轻易获得</li>
<li class="lvl-6">更加丰富的用户界面</li>
<li class="lvl-6">响应速度更快的用户界面</li>
<li class="lvl-6">客户端/服务端 负载平衡</li>
<li class="lvl-6">异步通讯</li>
<li class="lvl-6">网络效率</li>
</ol>
</li>
<li class="lvl-3">
<p>缺点</p>
<ol>
<li class="lvl-6">搜索引擎不可见</li>
<li class="lvl-6">专有 ( 与开放标准相反 )</li>
<li class="lvl-6">完整性丧失 (RIA 通常无法与 HTML 很好地融合在一起 )</li>
<li class="lvl-6">软件开发的复杂性 ( 什么东西要被缓存或不缓存再客户端计算机中？)</li>
<li class="lvl-6">RIA 体系结构打破了网页范例</li>
<li class="lvl-6">受限于安全沙箱</li>
</ol>
</li>
<li class="lvl-3">
<p>实现方式</p>
<ol>
<li class="lvl-6">浏览器插件
<ul class="lvl-4">
<li class="lvl-8">Flash/Flex, Java Swing, Silverlight</li>
<li class="lvl-8">潜在的更强的交互性，更⾼的应用障碍</li>
<li class="lvl-8">关注开放/控制</li>
</ul>
</li>
<li class="lvl-6">在浏览器中，不需要插件
<ul class="lvl-4">
<li class="lvl-8">AJAX</li>
<li class="lvl-8">更低的采用门槛</li>
<li class="lvl-8">跨浏览器问题?</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-5-2-同步、异步通信">2.5.2. 同步、异步通信</h3>
<h4 id="2-5-2-1-同步">2.5.2.1. 同步</h4>
<ol>
<li class="lvl-3">
<p>同步请求/响应通信模型中，总是浏览器 ( 与 Web 服务器、应用服务器或 Web 应用程序相对 ) 发起请求 ( 通过 Web 用户 )。接着，Web 服务器、应用服务器或 Web 应用程序响应进入的请求。在处理同步请求/响应对期间，用户不能继续使用浏览器。</p>
</li>
<li class="lvl-3">
<p>基本上所有新数据都需要刷新页面</p>
</li>
<li class="lvl-3">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223160754341.png" alt="image-20230223160754341" style="zoom:50%;" />
</li>
</ol>
<h4 id="2-5-2-2-异步">2.5.2.2. 异步</h4>
<ol>
<li class="lvl-3">
<p>Web 用户在当前异步请求被处理时还可以继续使用浏览器。一旦异步请求处理完成，异步响应就被通信 ( 从 Web 服务器、应用服务器或 Web 应用程序 ) 回客户机页面。典型情况下，在这个过程中，调用对 Web 用户没有影响；他们不需要等候响应。</p>
</li>
<li class="lvl-3">
<p>交换数据并修改页面但是不需要刷新页面</p>
</li>
<li class="lvl-3">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223160809598.png" alt="image-20230223160809598" style="zoom:50%;" />
</li>
</ol>
<h3 id="2-5-3-Ajax-请求">2.5.3. Ajax 请求</h3>
<p>Asynchronous JavaScript And XML 是⼀种使用 <strong>XMLHttpRequest</strong> 技术构建更复杂，动态的网页的编程实践。</p>
<p>尽管 X 在 Ajax 中代表 XML，但由于JSON的许多优势，比如更加轻量以及作为 Javascript  的⼀部分，目前 JSON 的使用比 XML 更加普遍。<strong>JSON 和 XML 都被用于在 Ajax 模型中打包信息</strong></p>
<ol>
<li class="lvl-3">
<p>通过在后台与服务器进行<strong>少量数据交换</strong>，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，<strong>对网页的某部分进行更新。</strong></p>
</li>
<li class="lvl-3">
<p>传统的网页 ( 不使用 AJAX) 如果需要更新内容，必需重载整个网页面。</p>
</li>
</ol>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/6.png" style="zoom: 33%;" />
<h3 id="2-5-4-Ajax-优缺点">2.5.4. Ajax 优缺点</h3>
<ol>
<li class="lvl-3">
<p>优点</p>
<ol>
<li class="lvl-6">更好的交互性和响应能力，使用起来更让人愉快。</li>
<li class="lvl-6">由于部分渲染，减少了与 Web 服务器的连接。</li>
<li class="lvl-6">因为只加载需要更新页面的数据，而不是刷新整个页面，所以可以节省带宽，减少网络流量。</li>
</ol>
</li>
<li class="lvl-3">
<p>缺点</p>
<ol>
<li class="lvl-6">返回和刷新按钮变得无用。</li>
<li class="lvl-6">为此页面添加书签将变得无用。</li>
<li class="lvl-6">需要在 Web 浏览器上启用 JavaScript。</li>
<li class="lvl-6">网络延迟可能会破坏可用性。</li>
<li class="lvl-6">通过 AJAX 加载的数据不会被任何主要的搜索引擎索引。因此，<strong>使 SEO 不友好</strong>。违背 URL 和资源定位的初衷</li>
</ol>
</li>
</ol>
<h3 id="2-5-5-XMLHttpRequest">2.5.5. XMLHttpRequest</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>XMLHttpRequest 对象是 AJAX 最重要的组件</p>
</li>
<li class="lvl-2">
<p>用于使用 <strong>HTTP</strong> 在 Web 服务器之间<strong>传输和操作 XML/JSON/文本数据</strong></p>
</li>
<li class="lvl-2">
<p>执行操作：</p>
<ul class="lvl-2">
<li class="lvl-4">在后台从客户端发送数据</li>
<li class="lvl-4">从服务器接收数据</li>
<li class="lvl-4">更新网页，无需重新加载</li>
</ul>
</li>
</ul>
<h3 id="2-5-6-Ajax请求流程">2.5.6. Ajax请求流程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端事件发生，如按钮点击</p>
</li>
<li class="lvl-2">
<p>创建 XHMHttpResquest 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);<span class="comment">//老版本IE</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>创建 XMLHttpRequest 对象后，需要决定在收到服务器对请求的响应后要做什么。</p>
<p>设置 XHMHttpResquest 回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//process the server response</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>XHMHttpResquest 发送异步请求给服务器端，需要调用 XMLHttpRequest 对象的 open() 和 send() 方法</p>
<p>open() 方法的参数:</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>第⼀个参数是 HTTP 请求方法，例如 GET、POST 和 HEAD。</p>
</li>
<li class="lvl-4">
<p>第⼆个参数是请求的 Web 页面的 URL。</p>
</li>
<li class="lvl-4">
<p>第三个参数(可选)设置请求是否是异步的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HTTP GET request without querystring</span></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">GET</span>’,’serverpage.<span class="property">php</span>’,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//HTTP GET request with querystring</span></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">GET</span>’,’serverpage.<span class="property">php</span>?</span><br><span class="line">username=’+<span class="title class_">Math</span>.<span class="title function_">random</span>(),<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">GET</span>’,’serverpage.<span class="property">php</span>?</span><br><span class="line">username=user1&amp;pass=password’,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//HTTP POST request</span></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">POST</span>’,’serverpage.<span class="property">php</span>’,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(‘username=user1&amp;pass=password’);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>服务器端发送结果</p>
</li>
<li class="lvl-2">
<p>XHMHttpResques t传送结果给客户端：</p>
<p>首先，响应函数需要检查请求的就绪状态。如果就绪状态的值为 4，则可以进⼀步执行。</p>
<p>接下来，需要检查HTTP服务器响应的响应代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// everything is good, the response is received</span></span><br><span class="line">    &#125;<span class="keyword">if</span> (xmlhttp.<span class="property">status</span> === <span class="number">200</span>) &#123; </span><br><span class="line">        <span class="comment">// process the response </span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// request encountered some problem,</span></span><br><span class="line">        <span class="comment">// for example, the response may contain a HTTP</span></span><br><span class="line">        <span class="number">404</span> (<span class="title class_">Not</span> <span class="title class_">Found</span>) response code</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// still not ready </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-5-7-安全相关，SOP，跨域">2.5.7. 安全相关，SOP，跨域</h3>
<h4 id="2-5-7-1-安全相关">2.5.7.1. 安全相关</h4>
<blockquote>
<p>XSS 威胁</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>跨站脚本 (Cross site scripting，通常简称为 XSS) 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。 它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。指攻击者在网页中嵌入客户端脚本 ( 例如 JavaScript),当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
</li>
<li class="lvl-3">
<p><strong>AJAX 无法从本地存储的网页上运行，只能在存储在 Web 服务器上的网页上运行</strong></p>
</li>
</ol>
<h4 id="2-5-7-2-SOP">2.5.7.2. SOP</h4>
<ol>
<li class="lvl-3">
<p>同源政策：限制浏览器可以获取的资源，只能从同源网站获取内容 ( 除了资源文件 ) 同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<ol>
<li class="lvl-6">Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li class="lvl-6">DOM 无法获得。</li>
<li class="lvl-6">AJAX 请求不能发送。</li>
</ol>
</li>
</ol>
<h4 id="2-5-7-3-跨域问题">2.5.7.3. 跨域问题</h4>
<ol>
<li class="lvl-3">
<p>当<strong>协议、域名、端口号</strong>中任意一个不同时，都算作不同域</p>
</li>
<li class="lvl-3">
<p>实现跨域的方法</p>
<ol>
<li class="lvl-6">CORS：服务器设置 HTTP 响应头中 Access-Control-Allow-Origin 值，解除跨域限制。</li>
<li class="lvl-6">nginx：反向代理</li>
<li class="lvl-6">Docker</li>
</ol>
</li>
</ol>
<h3 id="2-5-6-数据格式">2.5.6. 数据格式</h3>
<h4 id="2-5-6-1-JSON">2.5.6.1. JSON</h4>
<ol>
<li class="lvl-3">
<p>由 Douglas Crockford 形式化和推广，它是一种<strong>轻量级的、易于简化</strong>的数据格式，使用 JavaScript 对象和数组文本语法编写。</p>
</li>
</ol>
<h4 id="2-5-6-2-JSON-P-JSON-with-Padding">2.5.6.2. JSON-P JSON with Padding</h4>
<ol>
<li class="lvl-3">
<p>带填充的 JSON</p>
</li>
<li class="lvl-3">
<p>当使用动态脚本标记插入时，JSON 数据被视为另一个 JavaScript 文件，并作为本机代码执行。为了实现这一点，数据必须包装在回调函数中。</p>
</li>
<li class="lvl-3">
<p>由于数据被当作原生 JS，<strong>因此它以原生 JavaScript 的速度被解析</strong>。</p>
</li>
<li class="lvl-3">
<p>避免使用与性能无关的 JSON-P 有一个原因：由于 JSON-P 必须是可执行的 JavaScript，因此任何人都可以调用它，并使用动态脚本标记插入将其包含在任何网站中。</p>
</li>
<li class="lvl-3">
<p>不要在 JSON-P 中对任何敏感数据进行编码，因为您无法确保它保持私有，即使使用随机 url 或 cookie。</p>
</li>
</ol>
<h1>3. 服务器端</h1>
<h2 id="3-1-Node-js-重要">3.1. Node.js 重要</h2>
<ol>
<li class="lvl-3">
<p>Node.js <strong>不是⼀个web框架，也不是⼀种语言，而是一个运行时环境（类比 JVM）</strong></p>
</li>
<li class="lvl-3">
<p>Node.js 使用<strong>事件驱动</strong>的<strong>非阻塞异步 I/O 模型</strong>，在单⼀进程中可以处理成千上万的<strong>并发</strong>连接，非常适合处理<strong>高并发</strong>。Node所针对的应用程序有⼀个专门的简称：<strong>DIRT</strong>，表示<strong>数据密集型实时</strong>（data-intensive real-time）<strong>程序</strong>【但都对 cpu 使用少】</p>
</li>
</ol>
<h3 id="3-1-1-特点，应用场景">3.1.1. 特点，应用场景</h3>
<h4 id="3-1-1-1-优缺点-适用不适用场景">3.1.1.1. 优缺点/适用不适用场景</h4>
<ol>
<li class="lvl-3">
<p>优点：</p>
<ol>
<li class="lvl-6"><strong>高并发</strong>（最重要的优点）</li>
<li class="lvl-6">适合<strong>I/O密集型</strong>应用</li>
<li class="lvl-6">同样是 js 客户端和服务端<strong>切换成本低</strong></li>
<li class="lvl-6">npm 丰富</li>
<li class="lvl-6"><strong>可移植</strong>到不同平台</li>
</ol>
</li>
<li class="lvl-3">
<p>缺点：</p>
<ol>
<li class="lvl-6"><strong>不适合CPU密集型应用</strong>；CPU密集型应用给Node带来的挑战主要是：由于JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起</li>
<li class="lvl-6"><strong>大内存的应用</strong>：由于 V8 引擎有内存设计的限制，32 位环境中最大堆是 1G，64 位环境中最大堆也不到 2G</li>
<li class="lvl-6"><strong>静态服务器</strong>，和 Nginx 的处理静态资源还是有很大的差距</li>
<li class="lvl-6"><strong>不需要异步的应用</strong>，Nodejs 的异步调用可能会给编程带来⼀些麻烦</li>
</ol>
</li>
</ol>
<h4 id="3-1-1-2-应用场景">3.1.1.2. 应用场景</h4>
<ol>
<li class="lvl-3">
<p>网站</p>
</li>
<li class="lvl-3">
<p>聊天应用程序是最能体现 Node.js 优点的例子</p>
</li>
<li class="lvl-3">
<p>HTTP 代理</p>
</li>
<li class="lvl-3">
<p>前端构建工具 ( 脚手架 )</p>
</li>
<li class="lvl-3">
<p>写操作系统 (NodeOS)</p>
</li>
<li class="lvl-3">
<p>跨平台打包工具</p>
</li>
</ol>
<h3 id="3-1-2-基本原理">3.1.2. 基本原理</h3>
<p>ref:<a href="https://juejin.cn/post/6903165908815904775">深入理解Nodejs单线程实现高并发原理</a></p>
<p>nodejs运行环境 = 主线程(单线程,包括事件队列) + 线程池(工作线程池,执行其他工作-多线程)</p>
<ol>
<li class="lvl-3">
<p><strong>运行机制</strong></p>
<ul class="lvl-2">
<li class="lvl-5">V8 引擎解析 JavaScript 脚本。</li>
<li class="lvl-5">解析后的代码，调用 Node API。</li>
<li class="lvl-5">libuv 库<strong>负责</strong>Node API 的<strong>执行</strong>。它将不同的任务分配给不同的 worker 线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li class="lvl-5">V8 引擎再将结果返回给用户。</li>
<li class="lvl-5"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e2388393d845f0ae8de01090449370~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></li>
<li class="lvl-5"><strong>具体执行：<strong>事件机制都是用设计模式中</strong>观察者模式</strong>实现。
<ul class="lvl-4">
<li class="lvl-7">维护了一个<strong>事件队列（Event queue）</strong>，事件到来就加入事件队列。主线程从事件队列中取出事件，再从线程池中分配一个线程去执行这个事件，当有事件执行完毕后，会通知主线程，<strong>主线程把要执行回调的事件也加入事件队列，后续再执行</strong>，线程归还给线程池。</li>
<li class="lvl-7"><strong>异步操作是由线程池完成的</strong>，node 将所有的阻塞操作都交给了内部的线程池去实现，<strong>本身只负责不断的往返调度</strong>，并没有进行真正的I/O操作，<strong>从而实现异步非阻塞 I/O</strong></li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>4 个层次</strong></p>
<ul class="lvl-2">
<li class="lvl-5">应用层：   即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs</li>
<li class="lvl-5">V8 引擎层：  即利用 V8 引擎来解析JavaScript 语法，进而和下层 API 交互</li>
<li class="lvl-5">NodeAPI 层：  为上层模块提供<strong>系统调用</strong>，一般是由 C 语言来实现，和操作系统进行交互 。</li>
<li class="lvl-5">LIBUV 层： 是跨平台的<strong>底层封装</strong>，实现了 事件循环、文件操作等，是 Node.js <strong>实现异步的核心</strong></li>
</ul>
</li>
<li class="lvl-3">
<p><strong>单线程</strong></p>
<ol>
<li class="lvl-6">
<p>Node 遵循的是<strong>单线程单进程的模式</strong>，node 的单线程是指js的引擎只有一个实例，且在 nodejs 的主线程中执行，同时 node 以<strong>事件驱动</strong>的方式<strong>处理 IO 等异步操作</strong>。node的单线程模式，<strong>只维持一个主线程</strong>，大大减少了线程间切换的开销，但是<strong>会有多个 worker 线程，用于执行异步操作</strong>。</p>
</li>
<li class="lvl-6">
<p>但是 node 的单线程使得在<strong>主线程不能进行CPU密集型操作</strong>，否则会<strong>阻塞主线程</strong>。</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>异步 I/O</strong></p>
</li>
</ol>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/7.png" style="zoom:33%;" />
<ol start="5">
<li class="lvl-3">
<p><strong>事件循环驱动</strong></p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/8.png" alt=""></p>
<blockquote>
<ol start="6">
<li class="lvl-3">
<p>网上解释</p>
<ol>
<li class="lvl-6">Node.js：<strong>单线程，异步 I/O，事件驱动</strong></li>
<li class="lvl-6">应用程序的请求过程可以分为俩个部分：CPU 运算和 I/O 读写
<ol>
<li class="lvl-9">CPU 计算速度通常远高于磁盘读写速度，这就导致 CPU 运算已经完成，但是不得不等待磁盘 I/O 任务完成之后再继续接下来的业务。</li>
<li class="lvl-9">所以 I/O 才是应用程序的瓶颈所在，在 I/O 密集型业务中，假设请求需要 100ms 来完成，其中 99ms 花在 I/O 上。</li>
</ol>
</li>
<li class="lvl-6">如果需要优化应用程序，让他能同时处理更多的请求，我们会采用<strong>多线程</strong>，同时开启 100 个、1000 个线程来提高我们请求处理，当然这也是一种可观的方案。但是由于一个 CPU 核心在<strong>一个时刻</strong>只能做一件事情，操作系统只能通过将 CPU 切分为时间片的方法，让线程可以较为均匀的使用 CPU 资源。</li>
<li class="lvl-6">操作系统在内核切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。那么是否可以另辟蹊径呢？！</li>
<li class="lvl-6">我们先来看看单线程，《深入浅出 Node》一书提到&quot;单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销&quot;，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/9.png" alt=""></p>
<ol start="5">
<li class="lvl-3">
<p>Node.js 的单线程并不是真正的单线程，只是开启了单个线程进行业务处理 (cpu 的运算 )，同时开启了其他线程专门处理 I/O。当一个指令到达主线程，主线程发现有 I/O 之后，直接把这个事件传给 I/O 线程，不会等待 I/O 结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是&quot;单线程&quot;、“异步 I/O”。</p>
</li>
<li class="lvl-3">
<p>I/O 操作完之后呢？Node.js 的 I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时 node 会创建一个类似于 While(true) 的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的&quot;事件驱动&quot;。这也从 Node 的角度解释了什么是&quot;事件驱动&quot;。在 node.js 中，事件主要来源于网络请求，文件 I/O 等，根据事件的不同对观察者进行了分类，有文件 I/O 观察者，网络 I/O 观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行 I/O 等待。</p>
</li>
</ol>
</blockquote>
<h2 id="3-2-模块">3.2. 模块</h2>
<p>两种<strong>模块规范</strong></p>
<ol>
<li class="lvl-3">
<p>ES6 模块，简称 ESM Node.js</p>
</li>
<li class="lvl-3">
<p>CommonJS 模块，简称 CJS</p>
</li>
<li class="lvl-3">
<p><strong>CommonJS 模块是 Node.js 专用的</strong>，与 ES6 模块不兼容。而<strong>ES6模块化在浏览器和node.js中都可以用。</strong></p>
</li>
</ol>
<h3 id="3-2-1-差异">3.2.1. <strong>差异</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>语法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">CommonJS 模块使用 <code>require()</code> 加载和 <code>module.exports</code> 输出</li>
<li class="lvl-5">ES6 模块使用 <code>import</code> 和 <code>export</code></li>
</ul>
</li>
<li class="lvl-3">
<p><strong>机制</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>输出</strong>：CommonJS 模块输出的是一个<strong>值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。</p>
</li>
<li class="lvl-5">
<p><strong>加载</strong>：CommonJS 模块是<strong>同步加载</strong>，ES6 模块是<strong>静态解析</strong>。</p>
<ul class="lvl-4">
<li class="lvl-7">原因：CommonJS 加载的是一个<strong>对象</strong>（即module.exports属性），该对象只有在脚本运行完才会生成。而 <strong>ES6 模块不是对象</strong>，它的对外接口只是一种<strong>静态定义</strong>，在代码<strong>静态解析阶段就会生成</strong>。</li>
</ul>
</li>
<li class="lvl-5">
<pre><code class="language-js">// 例子
// CJS
// lib.js
var counter = 3;
function incCounter() &#123;
 counter++;
&#125;
module.exports = &#123;
 counter: counter,
 incCounter: incCounter,
&#125;;
// main.js
var mod = require('./lib');
console.log(mod.counter); // 3
mod.incCounter();
console.log(mod.counter); // 3，值没有变化，因为是拷贝

// ES6
// lib.mjs
export let counter = 3;
export function incCounter() &#123;
 counter++;
&#125;
// main.mjs
import &#123; counter, incCounter &#125; from ‘./lib.mjs’;
console.log(counter); // 3
incCounter();
console.log(counter); // 4，增加，因为是值的引用
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-2-循环加载">3.2.2. 循环加载</h3>
<p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<ul class="lvl-0">
<li class="lvl-3">
<p>CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异</p>
</li>
<li class="lvl-3">
<p>ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from 'foo'</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</p>
</li>
<li class="lvl-3">
<p>详细解释见：[24. Module 的加载实现 - 循环加载 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack](<a href="https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-module-loader.md#:~:text=ES6">https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-module-loader.md#:~:text=ES6</a> 模块的循环加载 ES6 处理“循环加载”与 CommonJS 有本质的不同。 ES6,模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from ‘foo’ ），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。)</p>
</li>
</ul>
<h1>4. 优化 重要</h1>
<h2 id="4-1-基准测试-性能分析">4.1. 基准测试/性能分析</h2>
<ol>
<li class="lvl-3">
<p>通过设计科学的<strong>测试方法、测试工具和测试系统</strong>，实现对一类测试对象的某项性能指标进行定量和可对比的测试</p>
</li>
<li class="lvl-3">
<p>延迟(传播、传输、处理、排队) 和带宽</p>
</li>
<li class="lvl-3">
<p>Web <strong>性能要点</strong>⭐</p>
<ol>
<li class="lvl-6"><strong>延迟和带宽</strong>对 Web 性能的影响</li>
<li class="lvl-6"><strong>传输协议</strong> (TCP) 对 HTTP 的限制</li>
<li class="lvl-6"><strong>HTTP 协议自身</strong>的功能和缺陷</li>
<li class="lvl-6">Web <strong>应用</strong>的<strong>发展趋势及性能需求</strong></li>
<li class="lvl-6"><strong>浏览器局限性</strong>和优化思路</li>
</ol>
</li>
<li class="lvl-3">
<p>浏览器<strong>渲染</strong>过程：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">渲染页面：浏览器的工作原理 - Web 性能 | MDN (mozilla.org)</a></p>
</li>
<li class="lvl-3">
<p><strong>性能监控指标</strong></p>
<ol>
<li class="lvl-6"><strong>FP</strong>：First Paint 首次绘制，页面第一次绘制的<strong>时间点</strong>：只要出现视觉变化，<strong>无论什么</strong>。</li>
<li class="lvl-6"><strong>FCP</strong>：First Contentful Paint 首次内容绘制，完成对 DOM 中的一部分内容渲染的<strong>时间点</strong>：首次绘制来自 DOM 的内容。
<ul class="lvl-4">
<li class="lvl-8"><strong>注意</strong>：只有首次绘制<strong>文本、图片（包含背景图）、非白色的 canvas 或 SVG</strong> 时才被算作 FCP</li>
<li class="lvl-8">FP和FCP可能是相同的时间，也可能是先FP后FCP</li>
</ul>
</li>
<li class="lvl-6"><strong>FMP</strong>：First Meaningful Paint 首次有意义绘制，页面<strong>关键</strong>元素的渲染时间，没有标准定义，由<strong>开发者自行定义</strong>。</li>
<li class="lvl-6"><strong>首屏时间</strong>：应用渲染完<strong>整个屏幕的时间</strong>。</li>
<li class="lvl-6"><strong>用户可交互时间</strong>： Time to Interactive DOMReady 时间，即可以进行交互的时间点，如果涉及交互的 JS 没有加载好，那么就不能交互</li>
<li class="lvl-6"><strong>总下载时间</strong>：页面<strong>所有资源加载完成</strong>的时间，一般<strong>统计 window.onload 时间</strong>，也可以是异步渲染全部完成的时间。</li>
<li class="lvl-6"><strong>第一个字节加载时间</strong></li>
<li class="lvl-6">页面渲染时间：瀑布流中两个指标 Start Render 和 msFirstPaint
<ol>
<li class="lvl-9">Start Render：通过捕获页面加载的视频，实验室测量。</li>
<li class="lvl-9">msFirstPaint：是浏览器本身报告的测量。</li>
</ol>
</li>
<li class="lvl-6">自定义指标</li>
</ol>
</li>
<li class="lvl-3">
<p>相关工具</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223174846570.png" alt="image-20230223174846570"></p>
<h2 id="4-2-基本原理">4.2. 基本原理</h2>
<ol>
<li class="lvl-3">
<p><strong>浏览器</strong>核心优化策略</p>
<ol>
<li class="lvl-6"><strong>资源预取和排定优先次序</strong>：声明每种资源的优先级</li>
<li class="lvl-6">推测性优化：
<ol>
<li class="lvl-9"><strong>DNS 预解析</strong>：对可能的域名进行提前解析。</li>
<li class="lvl-9"><strong>TCP 预连接</strong>：DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。</li>
<li class="lvl-9"><strong>页面预渲染</strong>：某些浏览器可以让我们提示下⼀个可能的目标，从而在隐藏的标签页中预先渲染整个页面。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>web 性能优化<strong>两个准则</strong></p>
<ol>
<li class="lvl-6"><strong>消除或减少</strong>不必要的<strong>网络延迟</strong></li>
<li class="lvl-6">将需要传输的<strong>数据</strong>压缩至<strong>最少</strong></li>
</ol>
</li>
</ol>
<h2 id="4-3-优化思路，技术，方法">4.3. 优化思路，技术，方法</h2>
<h3 id="4-3-1-优化思路">4.3.1. 优化思路</h3>
<ol>
<li class="lvl-3">
<p>减少 DNS 查找</p>
</li>
<li class="lvl-3">
<p>重用 TCP 连接</p>
</li>
<li class="lvl-3">
<p>减少 HTTP 重定向</p>
</li>
<li class="lvl-3">
<p>使用内容分发网络</p>
</li>
<li class="lvl-3">
<p>避免不必要的资源请求</p>
</li>
<li class="lvl-3">
<p>在客户端缓存部分资源</p>
</li>
<li class="lvl-3">
<p>资源传输前先压缩</p>
</li>
<li class="lvl-3">
<p>避免不必要的请求字节</p>
</li>
<li class="lvl-3">
<p>并行处理请求和响应</p>
</li>
<li class="lvl-4">
<p>针对协议版本采取优化措施</p>
</li>
</ol>
<h3 id="4-3-2-具体的优化方法">4.3.2. 具体的优化方法</h3>
<ol>
<li class="lvl-3">
<p>CSS：CSS 放置在 HTML 顶部，减少 CSS 文件，避免绝对 CSS。</p>
</li>
<li class="lvl-3">
<p>Image：合适的图片大小，而不是浏览器调整</p>
</li>
<li class="lvl-3">
<p>js：将 js 放在 html 的底部，尽量用外部 js</p>
</li>
<li class="lvl-3">
<p>服务器优化：减少域名查找，数据压缩</p>
</li>
<li class="lvl-3">
<p>html：标准兼容、去除空白符、结构尽量简单、做到浏览器和移动端的兼容</p>
</li>
<li class="lvl-3">
<p><strong>针对 HTTP1.x 的优化</strong></p>
<ol>
<li class="lvl-6">利用 <strong>http 管道</strong></li>
<li class="lvl-6">域名分片：将资源分散到多个来源</li>
<li class="lvl-6">打包资源以减少 HTTP 请求</li>
<li class="lvl-6">父文档中嵌入小资源：从而减少请求数量</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>HTTP2 优化</strong></p>
<ol>
<li class="lvl-6">少发数据，减少请求，减少传输数据量和不必要网络延迟，调整资源供给</li>
<li class="lvl-6">每个来源一个链接 ( 多个链接会抵消新协议中首部压缩和请求优先级的作用，域名分区在 HTTP2 下是反作用的 )</li>
<li class="lvl-6">去掉不必要资源打包 (资源打包不利于缓存，单个文件比较大 )</li>
<li class="lvl-6">利用服务器推送 ( 充分使用缓存的机制，即还没有收到浏览器的请求，服务器就把各种资源推送给浏览器；比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 )</li>
</ol>
</li>
</ol>
<h1>5. 前端鉴权</h1>
<h2 id="5-1-术语">5.1. 术语</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>认证</strong>(Identification)： 是指根据声明者所<strong>特有的识别信息</strong>，<strong>确认</strong>声明者的<strong>身份</strong>。如用户名密码，身份证</p>
</li>
<li class="lvl-2">
<p><strong>授权</strong>(Authorization)： 在信息安全领域是指资源所有者委派执行者，<strong>赋予</strong>执行者指定范围的<strong>资源操作权限</strong>，以便对资源的相关操作。如 session，cookie，token</p>
</li>
<li class="lvl-2">
<p><strong>鉴权</strong>(Authentication)：在信息安全领域是指对于⼀个声明者<strong>所声明的身份权利</strong>，对其所<strong>声明的真实性进行鉴别</strong>确认的过程。如确认 token 是否合法、是否到期</p>
<ul class="lvl-2">
<li class="lvl-4">鉴权是⼀个承上启下的⼀个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下⼀步的权限控制做好准备。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>权限控制</strong>(Access/Permission Control)：将可执行的<strong>操作</strong>定义为<strong>权限列表</strong>，然后判断操作<strong>是否允许/禁止</strong>。如通过 web 后端服务，来控制接口访问，允许或拒绝访问请求</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223192856091.png" alt="image-20230223192856091"></p>
</li>
</ul>
<h2 id="5-2-方案">5.2 方案</h2>
<p>见 <a href="https://juejin.cn/post/7129298214959710244#heading-49">一文教你搞定所有前端鉴权与后端鉴权方案</a></p>
<h1>6. 登录注册</h1>
<h1>7. 前端主题切换</h1>
<p>见 <a href="https://mp.weixin.qq.com/s/J90TYDJGmo8KCTsawT-vIg">前端主题切换方案</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">方案/主题样式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>方案1：link标签动态引入</strong>（js 修改引入 css 的 link 标签；文件过大，切换延时，不推荐，但首屏时间短）</td>
</tr>
<tr>
<td style="text-align:left"><strong>方案2：提前引入所有主题样式，做类名切换</strong>（要为变换主题的每个内容写 css）</td>
</tr>
<tr>
<td style="text-align:left"><strong>方案3：CSS变量+类名切换</strong>（使用 css 变量，要用到的地方使用 var(–color)即可，不用给每个内容都写 css）【建议】</td>
</tr>
<tr>
<td style="text-align:left">方案4：Vue3新特性（v-bind）</td>
</tr>
<tr>
<td style="text-align:left">方案5：SCSS + mixin + 类名切换</td>
</tr>
<tr>
<td style="text-align:left">方案6：CSS变量+动态setProperty</td>
</tr>
</tbody>
</table>
<h1>6. 题型</h1>
<h2 id="6-1-基本概念-所有课件中涉及的，不限于总结">6.1. 基本概念 ( 所有课件中涉及的，不限于总结 )</h2>
<h2 id="6-2-简答题">6.2. 简答题</h2>
<h2 id="6-3-问答题">6.3. 问答题</h2>
<h1>7. 2023 web回忆</h1>
<h2 id="7-1-基本概念">7.1. 基本概念</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>URN</p>
</li>
<li class="lvl-2">
<p>CSSOM</p>
</li>
<li class="lvl-2">
<p>SVG</p>
</li>
<li class="lvl-2">
<p>CANVAS</p>
</li>
<li class="lvl-2">
<p>render tree</p>
</li>
<li class="lvl-2">
<p>WebAssembly</p>
</li>
</ul>
<h2 id="7-2-简答题">7.2. 简答题</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>web3.0 特点</p>
</li>
<li class="lvl-2">
<p>箭头函数和普通函数的区别</p>
</li>
<li class="lvl-2">
<p>NodeJs高并发原因</p>
</li>
<li class="lvl-2">
<p>js 数据类型</p>
</li>
<li class="lvl-2">
<p>前端智能的理解，前端智能的典型应用</p>
</li>
<li class="lvl-2">
<p>闭包的定义，优缺点，应用场景</p>
</li>
<li class="lvl-2">
<p>状态码含义：200、301、303，404，500</p>
</li>
</ul>
<h2 id="7-3-问答题">7.3. 问答题</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>列举前端流行框架，什么是 Vanilla JS，为什么要推广 Vanilla JS</p>
</li>
<li class="lvl-2">
<p>http1——http3的发展，各自特点，http3 解决了前面什么问题</p>
</li>
<li class="lvl-2">
<p>前端鉴权 4 种方式，优缺点（20 分）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式复习提纲</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
    <content><![CDATA[<h2 id="1-嵌入式系统">1. 嵌入式系统</h2>
<h3 id="1-1-定义">1.1. 定义</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>IEEE定义：用于控制、监控或者辅助操作机器和设备的装置</p>
</li>
<li class="lvl-2">
<p>国内定义：嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专业计算机系统</p>
</li>
<li class="lvl-2">
<p><strong>三要素：</strong></p>
<ul class="lvl-2">
<li class="lvl-4">嵌入性</li>
<li class="lvl-4">专用性:专用型，软硬件按对象要求设计、裁剪</li>
<li class="lvl-4">计算机:实现对象的智能化功能</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="1-2-特点">1.2. 特点</h3>
<ol>
<li class="lvl-3">
<p>形式多样，面向特定应用</p>
</li>
<li class="lvl-3">
<p>得到多种类型处理器和处理器体系结构的支持</p>
</li>
<li class="lvl-3">
<p>关注成本</p>
</li>
<li class="lvl-3">
<p>有实时性和可靠性要求</p>
</li>
<li class="lvl-3">
<p>使用的操作系统是适应多种处理器、可裁剪、轻量型、实时可靠、可固化的嵌入式操作系统</p>
</li>
<li class="lvl-3">
<p>需要专门工具和特殊方法开发</p>
</li>
</ol>
<h3 id="1-3-分类">1.3. 分类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>按处理器位数：</p>
<ul class="lvl-2">
<li class="lvl-4"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221031163604768.png" alt="image-20221031163604768"></li>
</ul>
</li>
<li class="lvl-2">
<p>按应用：信息家电、汽车电子、通信、移动终端、工业控制</p>
</li>
<li class="lvl-2">
<p>按速度：强实时系统、一般实时系统、弱实时系统</p>
</li>
<li class="lvl-2">
<p>按确定性：</p>
<ul class="lvl-2">
<li class="lvl-4">硬实时系统：如果系统响应时间不能满⾜，就要引起系统崩溃或致命的错误</li>
<li class="lvl-4">软实时系统：如果系统响应时间不能满⾜，不会导致系统出现致命的错误或崩溃</li>
</ul>
</li>
<li class="lvl-2">
<p>按复杂程度：循环轮询系统、有限状态机系统、前后台机系统、单处理器多任务系统、多处理器多任务系统</p>
</li>
</ul>
<h3 id="1-4-典型应用">1.4. 典型应用</h3>
<p>工控设备、军用电子设备、航空航天、汽车电子、智能家居、智能驾驶、智能玩具、可穿戴设备</p>
<h3 id="1-5-嵌入式系统基本组成">1.5. 嵌入式系统基本组成</h3>
<p>由嵌入式硬件和软件组成</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件：微处理器为核心集成存储器和系统专用的输入输出设备</p>
</li>
<li class="lvl-2">
<p>软件：初始化代码及驱动、嵌入式操作系统和应用程序有机结合，形成系统特定的一体化软件。</p>
</li>
</ul>
<h3 id="1-6-IOT基本组成">1.6. IOT基本组成</h3>
<p>物联网：物理设备之间的互联网络，相互之间可以收集和交换信息。</p>
<h3 id="1-7-CPS的基本组成">1.7. CPS的基本组成</h3>
<ol>
<li class="lvl-3">
<p>CPS：信息物理系统（Cyber-Physical Systems）作为计算机进程和物理进程的统一体，是集成计算、通信与控制于一体的下一代智能系统。</p>
</li>
<li class="lvl-3">
<p>嵌入式系统、互联网和控制器组成</p>
</li>
<li class="lvl-3">
<p><strong>典型应用</strong>是汽车电子的GPS定位系统</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/1.png" alt=""></p>
<h2 id="2-嵌入式系统设计">2. 嵌入式系统设计</h2>
<h3 id="2-1-嵌入式系统面临挑战">2.1. 嵌入式系统面临挑战</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>可靠性：如何保证系统可靠地工作</p>
</li>
<li class="lvl-2">
<p>实时性：如何满足时限要求</p>
</li>
<li class="lvl-2">
<p>成本：需要多少硬件</p>
</li>
<li class="lvl-2">
<p>功耗：如何降低系统的功耗</p>
</li>
<li class="lvl-2">
<p>易升级：如何设计以保证系统可升级</p>
</li>
</ul>
<h3 id="2-2-传统开发过程">2.2. 传统开发过程</h3>
<ol>
<li class="lvl-3">
<p>系统在一开始就被划分为软件和硬件两大部分</p>
</li>
<li class="lvl-3">
<p>软件和硬件独立进行开发设计</p>
</li>
<li class="lvl-3">
<p>硬件优先经常被采取</p>
</li>
</ol>
<h3 id="2-3-软硬件协同设计">2.3. 软硬件协同设计</h3>
<ol>
<li class="lvl-3">
<p>增加了系统的灵活性</p>
</li>
<li class="lvl-3">
<p>提高设计的可预测性</p>
</li>
</ol>
<h3 id="2-4-软硬件的划分">2.4. 软硬件的划分</h3>
<ol>
<li class="lvl-3">
<p>嵌入式系统的设计涉及硬件与软件部分，<strong>设计中必须决定什么功能由硬件实现，什么功能由软件实现。</strong> <strong>【硬件速度快，软件可修改性强】</strong></p>
</li>
<li class="lvl-3">
<p>硬件和软件具有<strong>双重性</strong>【既可以让硬件来实现，也可以让软件来实现】</p>
</li>
<li class="lvl-3">
<p>软硬件变动对系统的决策造成影响</p>
</li>
<li class="lvl-3">
<p>划分和选择需要考虑多种因素</p>
</li>
<li class="lvl-3">
<p>硬件和软件的双重性是划分决策的<strong>前提</strong></p>
</li>
</ol>
<h2 id="3-嵌入式硬件系统基础">3. 嵌入式硬件系统基础</h2>
<h3 id="3-1-嵌入式微处理器体系结构">3.1. 嵌入式微处理器体系结构</h3>
<h4 id="3-1-1-冯诺依曼结构和哈佛结构">3.1.1. 冯诺依曼结构和哈佛结构</h4>
<ol>
<li class="lvl-3">
<p><strong>冯诺伊曼结构</strong></p>
<p>数据和程序放在同一个存储单元，统一编址，指令和数据通过同一个总线访问。</p>
</li>
<li class="lvl-3">
<p><strong>哈佛结构</strong></p>
<ol>
<li class="lvl-6">数据和程序存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器。</li>
<li class="lvl-6">每个存储器独立编址、独立访问。</li>
<li class="lvl-6">与之相对应的是系统中设置的两条总线(程序总线和数据总线)， 允许同时进行两次内存提取，更大的带宽。</li>
<li class="lvl-6">哈佛结构不能使用自我修改的代码。</li>
</ol>
</li>
</ol>
<h4 id="3-1-2-CISC与RISC">3.1.2. CISC与RISC</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>CISC：复杂指令集（许多地址格式，许多操作）</p>
</li>
<li class="lvl-2">
<p>RISC：精简指令集（流水型指令）</p>
<table>
<thead>
<tr>
<th></th>
<th>CISC</th>
<th>RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td>价格</td>
<td>由硬件完成部分软件功能，硬件复杂性增加，芯片成本高</td>
<td>由软件完成部分硬件功能，软件复杂性增加，芯片成本低</td>
</tr>
<tr>
<td>性能</td>
<td>减少代码尺寸，增加指令的执行周期数</td>
<td>使用流水线降低指令的执行周期数，增加代码尺寸</td>
</tr>
<tr>
<td>指令集</td>
<td>大量的混杂指令集，有简单快速的指令，也有复杂多周期指令，符合HLL</td>
<td>简单的单周期指令，在汇编指令方面有相应的SISC伪代码指令</td>
</tr>
<tr>
<td>高级语言支持</td>
<td>硬件完成</td>
<td>软件完成</td>
</tr>
<tr>
<td>寻址模式</td>
<td>复杂的寻址模式，支持内存到内存寻址</td>
<td>简单的寻址模式，仅允许LOAD和STORE指令存取内存，<strong>其他所有的操作都基于寄存器到寄存器</strong></td>
</tr>
<tr>
<td>寄存器数目</td>
<td><strong>寄存器较少</strong></td>
<td><strong>寄存器较多</strong></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="3-1-3-流水线技术">3.1.3. 流水线技术</h4>
<p>RISC机器用来减少指令周期的一种技术，提高处理器和总线的使用率，在CPU中由<strong>若干个不同功能的电路单元组成一条指令处理流水线</strong>，然后将一条指令分成若干步后再由这些电路单元分别执行，<strong>这样就能实现在一个CPU时钟周期完成一条指令</strong>，因此提高CPU的运算速度。</p>
<p>优点：提高CPU利用率、并行计算，减少指令周期</p>
<h4 id="3-1-4-微处理器分类">3.1.4. 微处理器分类</h4>
<ol>
<li class="lvl-3">
<p>嵌入式微处理单元(MPU)：功能和微处理器一样，具有较高的性能，具有体积小、功耗少、成本低、可靠性高的优点。具有<strong>32位及以上</strong>的处理器</p>
</li>
<li class="lvl-3">
<p>嵌入式微控制器(MCU)：嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM/EPROM、RAM、总线, 总线逻辑、定时/计数器、Watchdog、I/O、串行口等各种必要功能和外设。<strong>是目前嵌入式工业的主流，50%的份额</strong>。<strong>多是8位和16位处理器，32位的也不多</strong></p>
</li>
<li class="lvl-3">
<p>嵌入式DSP处理器(Data Signal Process)：嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</p>
</li>
<li class="lvl-3">
<p>嵌入式SoC：嵌入式SoC是追求产品<strong>系统最大包容</strong>的集成器件，绝大多数系统构件都在一个系统芯片内部。</p>
</li>
</ol>
<p><strong>都具有体积小、功耗小、可靠性高、设计生产效率高的特点。</strong></p>
<h4 id="3-1-5-选型">3.1.5. 选型</h4>
<ol>
<li class="lvl-3">
<p><strong>有效且经济</strong>地满足任务的计算需求</p>
<ol>
<li class="lvl-6">速度，ROM和RAM的数量，I / O端口和计时器的数量，大小，包装，功耗</li>
<li class="lvl-6">容易升级</li>
<li class="lvl-6">单位成本</li>
</ol>
</li>
<li class="lvl-3">
<p>软件开发工具的可用性：汇编器，调试器，C编译器，仿真器，模拟器，技术支持(开源框架可能没有多少人维护)</p>
</li>
<li class="lvl-3">
<p>微控制器的广泛可用性和可靠来源。</p>
</li>
</ol>
<h3 id="3-2-看门狗（Watch-Dog）">3.2. 看门狗（Watch Dog）</h3>
<ol>
<li class="lvl-3">
<p>功能：</p>
<p>在<strong>对系统稳定性要求较高的场合</strong>，防止嵌入式控制系统运行时收到外部干扰或者系统错误，<strong>程序出现跑飞</strong>，<strong>导致整个系统瘫痪</strong>，加入看门狗电路，当系统跑飞进入死循环时，回复系统的运行</p>
</li>
<li class="lvl-3">
<p>基本原理：</p>
<p>程序完整运行一周期的时间是tp，看门狗的定时周期为ti，且ti&gt;tp，在程序运行一周期后就修改定时器的计数值（即重新设定看门狗的定时周期）（喂狗），只要程序正常运行，定时器就不会溢出。若由于干扰等原因使系统不能再tp时刻修改定时器的计数值，<strong>定时器将在ti时刻溢出</strong>，引发系统复位，使系统得以重新运行，从而起到监控的作用。</p>
</li>
</ol>
<h3 id="3-3-嵌入式系统的存储体系">3.3. 嵌入式系统的存储体系</h3>
<h4 id="3-3-1-存储器系统：存储器系统的层次结构">3.3.1. 存储器系统：存储器系统的层次结构</h4>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/8.png" alt=""></p>
<h4 id="3-3-2-ROM的种类与选型">3.3.2. ROM的种类与选型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>ROM：固定内容、掩膜工艺、无法修改</p>
<blockquote>
<p>只读存储器（Read-Only Memory）是一种只能读取资料的存储器。在制造过程中，将资料以一特制光罩（mask）烧录于线路中，其资料内容在写入后就不能更改，所以有时又称为“光罩式只读内存”（mask ROM）。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>PROM：一次编程ROM，一旦导入、无法改变</p>
<blockquote>
<p>可编程程序只读存储器（Programmable ROM，PROM）之内部有行列式的熔丝，是需要利用电流将其烧断，写入所需的资料，但仅能写录一次。 PROM在出厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0</p>
</blockquote>
</li>
<li class="lvl-2">
<p>EPROM：加电可擦除，多次，字节级</p>
<blockquote>
<p>可抹除可编程只读存储器（Erasable Programmable Read Only Memory，EPROM）可利用高电压将资料编程写入，抹除时将线路曝光于紫外线下，则资料可被清空，并且可重复使用。通常在封装外壳上会预留一个石英透明窗以方便曝光。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>快闪存储器flash：电可擦，块级</p>
<blockquote>
<p>快闪存储器（Flash memory）的每一个记忆胞都具有一个“控制闸”与“浮动闸”，利用高电场改变浮动闸的临限电压即可进行编程动作。</p>
</blockquote>
</li>
</ul>
<h4 id="3-3-3-Flash的种类与选型">3.3.3. Flash的种类与选型</h4>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam2/7.png" alt=""></p>
<ol>
<li class="lvl-3">
<p>NAND Flash与NOR Flash相比，具有读性能比较差、写性能较好、串行读取、成本低、容量大的特点</p>
</li>
<li class="lvl-3">
<p>NAND Flash：需要BootLoader的引导模式</p>
</li>
<li class="lvl-3">
<p>NOR Flash：不需要BootLoader的引导模式</p>
</li>
</ol>
<h4 id="3-3-4-RAM的种类与选型">3.3.4. RAM的种类与选型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>RAM</p>
<blockquote>
<p>RAM也称随机存储器，那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>DRAM：(内存)速度稍慢，加电更新</p>
<blockquote>
<p>DRAM（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是DRAM。DRAM使用电容存储，DRAM 只能将数据保持很短的时间。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>SRAM：不用刷新，速度快，价格贵，容量小</p>
<blockquote>
<p>SRAM（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比DRAM复杂，可以做到不刷新电路即能保存它内部存储的数据。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>SDRAM：提升性能(时钟)</p>
<blockquote>
<p>SDRAM：（Synchronous Dynamic Random Access Memory，同步动态随机存取存储器），为DRAM的一种，同步是指Memory工作需要同步时钟，<strong>内部命令的发送与数据的传输都以时钟为基准</strong>；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是由指定地址进行数据读写。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>还有DDR SDRAM、DDR2 SDRAM、DDR3SDRAM不做过多赘述，感兴趣可以自己百度。</p>
</li>
</ul>
<h3 id="3-4-嵌入式系统总线">3.4. 嵌入式系统总线</h3>
<h4 id="3-4-1-总线结构，常见的总线及特点">3.4.1. 总线结构，常见的总线及特点</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>单总线结构</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/10.png" alt=""></p>
<blockquote>
<p>使用一条单一的系统总线来链接CPU、主存和IO设备。总线只能分时工作，是信息的传送的吞吐量受到限制。四次握手(1 enq， 2 ack, 2 low_ack, 1 low_enq)</p>
</blockquote>
</li>
<li class="lvl-2">
<p>双总线结构</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/11.png" alt=""></p>
<blockquote>
<p>在CPU和主存之间专门设置了一组高速的存储总线，使CPU可通过专用总线与存储器交换信息，并减轻了系统总线的负担。主存仍可通过系统总线与外设之间实现DMA操作，而不经过CPU</p>
</blockquote>
</li>
<li class="lvl-2">
<p>多总线结构</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/12.png" alt=""></p>
<blockquote>
<p>在双总线系统的基础上增加IO总线，其中系统总线是CPU、主存和通道（IOP）之间进行数据传送的公共通路，而IO是多个外部设备与通道之间进行数据传送的公共通路。通道实际上是一台具有特殊功能的处理器，他分担了一部分CPU的功能，以实现对外设的统一管理及外设与主存之间的数据传送。</p>
</blockquote>
</li>
</ul>
<h4 id="3-4-2-输入输出编程：忙等IO和中断IO">3.4.2. 输入输出编程：忙等IO和中断IO</h4>
<ol>
<li class="lvl-3">
<p>忙等IO：用指令来检查设备是否就绪【即轮询看设备是否就绪】</p>
<ul class="lvl-2">
<li class="lvl-5">最简单的设备驱动方式</li>
<li class="lvl-5">CPU不能在检查设备的过程中执行其他指令</li>
<li class="lvl-5">很难处理同时发生的IO操作</li>
</ul>
</li>
<li class="lvl-3">
<p>中断IO：基于子程序调用，使下一条指令为一个子程序调用的预定位置，返回位置被保存确保执行前台程序。【即采用中断机制来 IO】</p>
<ul class="lvl-2">
<li class="lvl-5">CPU和设备之间通过总线连接</li>
<li class="lvl-5">CPU和设备之间进行握手</li>
<li class="lvl-5">设备发出中断请求</li>
<li class="lvl-5">当CPU能处理中断时发出中断确认请求。</li>
</ul>
<p>两种机制确保中断更加有效：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>优先级决定哪个中断先获得CPU；</p>
</li>
<li class="lvl-5">
<p>中断向量决定每个中断对应的执行代码。</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-4-3-Programming-I-O：Independent-I-O-port-memory-mapped-I-O">3.4.3. Programming I/O：Independent I/O port. memory-mapped I/O</h4>
<p><strong>可编程I/O</strong></p>
<ol>
<li class="lvl-3">
<p>通信期间选择控制寄存器或数据缓冲区的三种方法</p>
<ol>
<li class="lvl-6"><strong>独立的I/O端口</strong>：需要专门的指令来完成。</li>
<li class="lvl-6"><strong>内存映射的I/O</strong>。</li>
<li class="lvl-6"><strong>混合解决方案(统一编址)</strong>。混合模型包括内存映射的I/O数据缓冲区和用于控制寄存器的单独的I/O端口。</li>
</ol>
</li>
<li class="lvl-3">
<p>英特尔x86提供了输入输出说明。<strong>大多数其他CPU使用内存映射</strong>的I/O。</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec5/4.png" alt=""></p>
<p>a. 独立的I/O和内存空间。</p>
<p>b. 内存映射的I/O。</p>
<p>c. 混合解决方案。</p>
<h2 id="4-嵌入式系统软件知识【重点】">4. 嵌入式系统软件知识【重点】</h2>
<h3 id="4-1-嵌入式软件基础知识">4.1. 嵌入式软件基础知识</h3>
<h4 id="4-1-1-嵌入式软件的特点">4.1.1. 嵌入式软件的特点</h4>
<ol>
<li class="lvl-3">
<p>独特的实用性</p>
<blockquote>
<p>每种嵌入式软件都有自己独特的应用环境和实用价值</p>
</blockquote>
</li>
<li class="lvl-3">
<p>灵活的适用性</p>
<blockquote>
<p>嵌入式软件通常可以认为是一种模块化软件，它应该能非常方便灵活地运用到各种嵌入式系统中，而不能破坏或更改原有的系统特性和功能</p>
</blockquote>
</li>
<li class="lvl-3">
<p>程序代码精简</p>
<blockquote>
<p>由于嵌入式系统本身的应用有小体积、小存储空间、低成本、低功耗等要求，嵌入式软件和大型机上的软件相比，具有代码精简、执行效率高等特点</p>
</blockquote>
</li>
<li class="lvl-3">
<p>可靠性、稳定性高</p>
<blockquote>
<p>嵌入式系统应用要求一般较为苛刻，特别是在涉及安全相关的领域，如汽车电子、工业控制、航空航天等</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-2-嵌入式软件的分类">4.1.2. 嵌入式软件的分类</h4>
<ol>
<li class="lvl-3">
<p>系统软件</p>
<blockquote>
<p>即OS，负责嵌入系统的全部软、硬件资源的分配、调度工作，控制、协调并发活动；它必须体现其所在系统的特征，能够通过装卸某些模块来达到系统所要求的功能</p>
</blockquote>
</li>
<li class="lvl-3">
<p>支撑软件</p>
<blockquote>
<p>支撑软件是用于帮助和支持软件开发的软件，通常包括<strong>数据库和开发工具</strong>，其中以<strong>数据库最为重要</strong></p>
</blockquote>
</li>
<li class="lvl-3">
<p>应用软件</p>
<blockquote>
<p>嵌入式应用软件是针对特定应用领域，基于某一固定的硬件平台，用来达到用户预期目标的计算机软件。由于用户任务可能有时间和精度上的要求，因此有些嵌入式应用软件需要特定嵌入式操作系统的支持</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-3-嵌入式软件体系结构">4.1.3. 嵌入式软件体系结构</h4>
<ol>
<li class="lvl-3">
<p>轮询</p>
</li>
<li class="lvl-3">
<p>有限状态机</p>
</li>
<li class="lvl-3">
<p>带中断的轮询</p>
</li>
<li class="lvl-3">
<p>仅有中断</p>
</li>
<li class="lvl-3">
<p>功能队列调度</p>
</li>
<li class="lvl-3">
<p>实时操作系统(RTOS)</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>优先级</th>
<th>响应时间</th>
<th>变动的影响</th>
<th>共享数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>轮询</td>
<td>无，一切按序运行</td>
<td>所有任务之和</td>
<td>非常大，增加任务或修改任务时间影响所有任务</td>
<td>无</td>
</tr>
<tr>
<td>状态机</td>
<td>无，当前状态决定下一个状态优先级，非顺序执行</td>
<td>所有任务之和</td>
<td>同上</td>
<td>同上</td>
</tr>
<tr>
<td>带中断轮询</td>
<td>中断比主循环优先级高，中断有优先级</td>
<td>所有任务之和和中断执行时间和</td>
<td>主循环同轮序一样，对中断服务例程影响不大</td>
<td>必须处理和中断服务例程分享的数据</td>
</tr>
<tr>
<td>纯中断</td>
<td>中断有优先级</td>
<td>中断执行时间</td>
<td>对中断服务例程影响不大</td>
<td>同上</td>
</tr>
<tr>
<td>函数队列</td>
<td>中断有优先级，其他任务按序进行</td>
<td>最长任务执行时间</td>
<td>低，中断管理优先级函数，队列管理较低优先级</td>
<td>同上</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数队列:函数指针被添加到队列中，主循环在队列中循环并执行任务，任务或中断将新任务添加到功能队列中。以中断优先为优先级</p>
</li>
</ul>
<h3 id="4-2-嵌入式操作系统基础知识-关注实时调度部分，关注和通用OS的差别">4.2. 嵌入式操作系统基础知识 (关注实时调度部分，关注和通用OS的差别)</h3>
<h4 id="4-2-1-RTOS-Real-time-operating-systems">4.2.1. RTOS  Real time operating systems</h4>
<p><strong>概念</strong></p>
<p>对外来事件能在<strong>限定的响应时间</strong>内做出<strong>预定质量处理</strong>的计算机系统</p>
<p><strong>特点</strong></p>
<p>可移植性、强调实时性能、内核精简、<strong>抢占式内核、使用可重入函数</strong>、可配置、可裁剪、高可靠性</p>
<p><strong>选型原则</strong></p>
<p>首先确认是否需要使用RTOS(系统对相应延迟时间有要求，对事件处理复杂度有要求，对RAM、ROM的占用有一定规模要求)：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>成本，可靠性，实时性，工具链，模块丰富，RTOS内核RAM、ROM占用量，支持</p>
</li>
</ul>
<h4 id="4-2-2-任务管理">4.2.2. 任务管理</h4>
<h5 id="进程、线程、任务的概念">进程、线程、任务的概念</h5>
<ol>
<li class="lvl-3">
<p>进程概念</p>
<p><strong>一个程序的单次执行</strong>。（如果两次运行一个相同的程序，就创建了两个不同的进程）</p>
<p>进程是操作系统资源分配和调度的基本单位，<strong>进程之间的地址空间和资源相互独立</strong></p>
</li>
<li class="lvl-3">
<p>线程概念</p>
<p>轻量级进程，是操作系统任务调度和执行的基本单位</p>
</li>
<li class="lvl-3">
<p>任务概念</p>
<p>最抽象、软件完成一个活动，可以是进程可以是线程。</p>
</li>
</ol>
<h5 id="任务的实现">任务的实现</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>任务控制块</strong></p>
<p>任务控制块(TCB)描述一个任务的核心数据包括任务堆栈指针、任务状态、优先级等，任务创建的时候创建TCB表</p>
</li>
</ul>
<h5 id="任务调度">任务调度</h5>
<ol>
<li class="lvl-3">
<p>可抢占调度</p>
<p>系统总是选择优先级别的最高的算法进行调度，并且一旦高优先级别的任务准备就绪之后，它就会马上被调度而不等待低优先级的任务主动放弃CPU</p>
</li>
<li class="lvl-3">
<p>不可抢占调度</p>
<p>让进程运行直到结束或阻塞的调度方式，主要用于批处理或某些实时性要求不严的实时系统。</p>
</li>
<li class="lvl-3">
<p>先来先服务</p>
<p>将处理机分配给最先来的进程，只考虑先后。(FCFS: first come first service)是一种<strong>非抢占式</strong>策略</p>
</li>
<li class="lvl-3">
<p>时间片轮转算法</p>
<p>系统把所有就绪进程按先入先出的原则排成一个队列。<strong>新来的进程加到就绪队列末尾</strong>。每当执行进程调度时,进程调度程序总是选出就绪队列的队首进程,让它在CPU上运行一个时间片的时间（时间片是一个小的时间单位,通常为10~100ms数量级）。<strong>当进程用完分给它的时间片后</strong>,系统的计时器发出时钟中断,调度程序便停止该进程的运行,<strong>把它放入就绪队列的末尾</strong>;然后,把CPU分给就绪队列的队首进程,同样也让它运行一个时间片。<strong>非抢占调度</strong></p>
</li>
<li class="lvl-3">
<p>优先级算法</p>
<p>系统将处理器分配给就绪队列中优先数最高的进程(分为抢占式优先级算法和非抢占式优先级算法)</p>
</li>
</ol>
<h5 id="实时系统及任务调度⭐">实时系统及任务调度⭐</h5>
<ol>
<li class="lvl-3">
<p>单一速率调度 **RMS **算法Rate Monotonic Scheduling</p>
<p><a href="https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310410910.html">单调速率调度（RMS）算法（详解版） (cdsy.xyz)</a></p>
<p><strong>静态</strong>调度策略，分配给每个进程的优先级是固定不变的，基于单一速率分析。</p>
<p>周期（即最后期限）短的进程被指定为最高优先级。每个周期进去，p进去，根据优先级调度执行，执行结束就从就绪状态退出直到下一个周期开始</p>
</li>
<li class="lvl-3">
<p>最早截止时限优先调度 <strong>EDF</strong> 算法 Earliest deadline first</p>
<p><a href="https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310310909.html">最早截止时间优先（EDF）算法详解 (cdsy.xyz)</a></p>
<p><strong>动态</strong>的优先级方案，在进程执行时当前所有进程的截止时限改变进程的优先级，截止时限最近的优先级最高</p>
<p>与单调速率调度不一样，EDF 调度不要求进程应是周期的，也不要求进程的 CPU 执行的长度是固定的。**唯一的要求是，进程在变成可运行（即就绪态）时，每个时刻应该宣布它的截止期限。**如果截止时限比当前的进程高，那就会抢占当前进程</p>
</li>
</ol>
<p>例子：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/3.png" alt=""></p>
<h5 id="任务间通信">任务间通信</h5>
<ol>
<li class="lvl-3">
<p>共享内存</p>
<blockquote>
<p>两个组件（比如CPU和I/O设备），通过一个共享内存位置进行通信，这个内存区域可以被看作一个通信设备，这个设备上所有的数据都存储在通信链路/内存中</p>
</blockquote>
</li>
<li class="lvl-3">
<p>消息</p>
<blockquote>
<p>消息传递通信机制是共享内存模型的一种补充</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>每个通信实体都具有自己的消息发送/接收单元。消息不在通信链路上存储，而是<strong>存储在端点的发送器/接收器</strong>。</p>
</blockquote>
<ol start="3">
<li class="lvl-3">
<p>管道</p>
<blockquote>
<p>发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。<strong>本质是固定大小的内存缓冲区</strong></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>由于当前操作系统的不惟一性，各个系统都有其独自的通信协议，导致了不同系统间通信的困难。尽管TCP/IP协议目前已发展成为Internet的标准，但仍不能保证C/S应用程序的顺利进行。命名管道作为一种通信方法，有其独特的优越性，这主要表现在它不完全依赖于某一种协议，而是适用于任何协议——只要能够实现通信</p>
</blockquote>
<ol start="4">
<li class="lvl-3">
<p>信号</p>
<blockquote>
<p>信号很简单，因为除了信号本身不会传递其他数据，信号类似于中断，但它完全由软件创建。一个信号是由进程产生的，并由操作系统传送给另一个进程</p>
</blockquote>
</li>
</ol>
<h5 id="同步与互斥">同步与互斥</h5>
<p><strong>同步可以通过开关中断实现，互斥使用信号量。</strong></p>
<ol>
<li class="lvl-3">
<p>竞争条件</p>
<blockquote>
<p>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>竞争条件发生在当多个进程或者线程在读写数据时，其最终的的结果依赖于多个进程的指令执行顺序。</p>
</blockquote>
<ol start="2">
<li class="lvl-3">
<p>代码临界区</p>
<p><strong>临界区</strong>指的是<strong>一个访问共用资源的程序片段</strong>，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待</p>
</li>
<li class="lvl-3">
<p>互斥</p>
<blockquote>
<p>一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源</p>
</blockquote>
</li>
<li class="lvl-3">
<p>信号量</p>
<p>信号量广泛用于进程或线程间的同步和互斥</p>
<blockquote>
<p>管理多进程运行的方式，信号量是一种变量类型，仅能由操作原语PV对其操作。P：将 信号量value值减1，若小于0，相关进程被阻塞，加入队列，若大于0相关进程继续执行 V:value+1，若不大于0，则从队列中释放一个进程进入就绪态，然后自己继续执行，否则自己继续执行，没有别的操作</p>
</blockquote>
</li>
<li class="lvl-3">
<p>死锁</p>
<blockquote>
<p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</p>
<p>当一些进程被永久地阻止获取互斥锁时就发生了死锁</p>
<p>例如线程A持有lock1且被阻止lock2，线程B持有lock2但被阻止获取lock1，就会出现死锁</p>
</blockquote>
</li>
</ol>
<h4 id="4-2-3-存储管理">4.2.3. 存储管理</h4>
<h5 id="1-嵌入式系统静态内存管理">1. 嵌入式系统静态内存管理</h5>
<p>系统在启动前，所有的任务都获得了所需要的所有内存，<strong>运行过程中将不会有新的内存请求</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在强实时系统中，减少内存分配在时间上可能带来的不确定性。</p>
</li>
<li class="lvl-2">
<p>不需要操作系统进行专门的内存管理操作。</p>
</li>
<li class="lvl-2">
<p>系统使用内存的效率比较低下，只适合于那些强实时，且应用比较简单，<strong>任务数量可以静态确定的系统</strong></p>
</li>
</ul>
<h5 id="2-嵌入式系统动态内存管理">2. 嵌入式系统动态内存管理</h5>
<p>应用通过分配（malloc）与释放（free）操作来使用内存</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>堆（heap）会带来碎片</p>
</li>
<li class="lvl-2">
<p>垃圾回收</p>
<p>对内存堆进行重新排列，把碎片组织成为大的连续可用内存空间。但垃圾回收的时间长短不确定：<strong>不适合于处理实时应用</strong></p>
</li>
<li class="lvl-2">
<p><strong>在实时系统中，避免内存碎片的出现，而不是在出现内存碎片时进行回收</strong></p>
</li>
</ul>
<p><strong>malloc 和 free：</strong></p>
<ol>
<li class="lvl-3">
<p>在嵌入式系统中不常用，因为容易<strong>产生碎片</strong>。</p>
</li>
<li class="lvl-3">
<p>解决办法</p>
<p>由于内存管理算法的原因，malloc()和free()函数执行时间是不确定的【是指执行完malloc返回花费的时间，因为分配的内存块大小不确定】。μC/OS-II 对malloc()和free()函数进行了改进，使得它们可以<strong>分配和释放固定大小的内存块</strong>，同时也不会产生碎片。这样⼀来，malloc()和free()函数的执⾏时间也是<strong>固定</strong>的了</p>
</li>
</ol>
<h2 id="5-嵌入式系统程序设计">5. 嵌入式系统程序设计</h2>
<h3 id="5-1-嵌入式软件开发基础知识">5.1. 嵌入式软件开发基础知识</h3>
<h3 id="5-2-嵌入式软件开发环境">5.2. 嵌入式软件开发环境</h3>
<p>交叉开发</p>
<ol>
<li class="lvl-3">
<p>为什么嵌入式软件要交叉开发？<strong>为了满足代码编写编译调试与运行环境有不同要求的情况。</strong></p>
<p>嵌入式系统是面向特定应用的一体化软件，不具备软件编写编译等功能，这么做可以降低嵌入式系统复杂度，降低成本</p>
</li>
<li class="lvl-3">
<p>宿主机和目标机差异:</p>
<ol>
<li class="lvl-6">宿主机是通用计算机系统，而目标机则多为嵌入式系统</li>
<li class="lvl-6">宿主机具有完整的开发软件如IDE、Complier、Debugger等，用于软件的编写，生成的二进制可执行代码则通过串口传输，在专用的面向应用的目标机上运行，并采取交叉方式进行调试</li>
</ol>
</li>
<li class="lvl-3">
<p>过程</p>
<ol>
<li class="lvl-6">宿主机上开发，模拟调试</li>
<li class="lvl-6">通过串口或网络传到目标机上</li>
<li class="lvl-6">目标机上基于监视器和操作系统的调试</li>
<li class="lvl-6">目标机脱离宿主机运行</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>特征</th>
<th>通用计算机</th>
<th>嵌入式系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>形式与类型</td>
<td>看得见的计算机、按照其体系结构、运算速度和结构规模等因素分为大中小型机和微机</td>
<td>看不见的计算机，形式多样，应用领域广泛，按应用来分</td>
</tr>
<tr>
<td>组成</td>
<td>通用处理器、标准总线和外设，软件和硬件相对独立</td>
<td>面向应用的嵌入式微处理器，总线和外部接口多集成在处理器内部。<strong>软件与硬件是紧密集成在一起的</strong></td>
</tr>
<tr>
<td>开发方式</td>
<td>开发平台和运行平台都是通用计算机</td>
<td>采用交叉开发方式，<strong>开发平台一般是通用计算机，运行平台是嵌入式系统</strong></td>
</tr>
<tr>
<td>二次开发性</td>
<td>应用程序可重新编制</td>
<td>一般不能再编程</td>
</tr>
</tbody>
</table>
<h2 id="6-嵌入式实时内核（以ucosII为例）">6. 嵌入式实时内核（以ucosII为例）</h2>
<h3 id="6-1-实时任务调度">6.1. 实时任务调度</h3>
<p>μC/OS_II进行任务调度的思想是 “近似地每时每刻总是让优先级最高的就绪任务处于运行状态” 。为了保证这一点，它在系统或用户任务<strong>调用系统函数及执行中断服务程序结束时总是调用调度器，来确定应该运行的任务并运行它 。</strong></p>
<p>μC/OS_II进行任务调度的<strong>依据就是任务就绪表</strong>，根据就绪表确定最高优先级</p>
<p><strong>μC/OS-II 实时调度机制：</strong></p>
<ol>
<li class="lvl-3">
<p>存储管理采用固定分区存储管理，以固定块大小来分配，避免内存碎片的产生</p>
</li>
<li class="lvl-3">
<p>任务调度时间采用固定优先级的优先级调度，为确保任务的实时性，μC/OS-II 要确保每次调度的耗时具有可预测性，最多可以管理64个任务，且保留了 4 个最高和 4 个最低优先级任务给自己使用，因此用户最多 56 个任务。</p>
<p><strong>不⽀持时间⽚轮转法</strong>，<strong>每个任务的优先级要求不⼀样且是唯⼀的</strong></p>
</li>
<li class="lvl-3">
<p>使用查表法，具有确定的时间，增加了系统的可预测性。TaskUnMapTbl表格存储256种情况下出现1的最低位，在代码为</p>
<ol>
<li class="lvl-6"><code>Y = TaskUnMapTbl[TaskRdyGrp]</code></li>
<li class="lvl-6"><code>X = TaskUnMapTbl[TaskRdyTbl[Y]]</code></li>
<li class="lvl-6"><code>Prio = (Y &lt;&lt; 3) + X</code></li>
<li class="lvl-6">由此找到相应进程，保证耗时固定</li>
</ol>
</li>
<li class="lvl-3">
<p>允许中断与异常存在，使得系统允许实时的高优先级任务执行。</p>
</li>
<li class="lvl-3">
<p>任务调度总是选择<strong>就绪任务</strong>中<strong>优先级最高的一个运行</strong></p>
</li>
<li class="lvl-3">
<p>允许任务间的抢占</p>
</li>
<li class="lvl-3">
<p>具有优先级的中断机制</p>
</li>
<li class="lvl-3">
<p>μC/OS中所有的系统调用时间都是确定的</p>
</li>
</ol>
<h3 id="6-2-中断与时钟">6.2. 中断与时钟</h3>
<p>μC/OS-II系统响应中断的过程为：</p>
<p>系统接收到中断请求后，这时如果CPU处于中断允许状态（即中断是开放的），系统就会中止正在运行的当前任务，而按照中断向量的指向转而去运行中断服务子程序；当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行或者转向运行另一个具有更高优先级别的就绪任务。</p>
<p><strong>时钟节拍是一种特殊的中断</strong>，μC/OS需要⽤户提供周期性信号源，⽤于实现时间延时和确认超时。时钟节拍的实际频率取决于用户应用程序的精度</p>
<h3 id="6-3-同步与通信">6.3. 同步与通信</h3>
<p>所有的通信信号都被看成是事件(event), μC/OS-II通过**事件控制块(ECB)**来管理每⼀个具体事件。</p>
<p>同步可以通过开关中断实现。互斥使用信号量。</p>
<p>​	当处理临界段代码时，需要关中断，处理完毕后，再开中断</p>
<p>通信可以使用邮箱和消息队列实现。</p>
<h3 id="6-4-存储管理">6.4. 存储管理</h3>
<p>μC/OS中是实模式存储管理</p>
<p>不划分内核空间和用户空间，整个系统只有一个地址空间，即物理内存空间，应用程序和内核程序都能直接对所有的内存单元进行访问</p>
<p>系统中的“任务”，实际上都是线程–––只有运行上下文和栈是独享的，其他资源都是共享的。</p>
<h4 id="静态">静态</h4>
<p>所谓静态存储方式是指在程序编译期间分配固定的存储空间的方式。该存储方式通常是在变量定义时就分定存储单元并一直保持不变， 直至整个程序结束。<strong>全局变量，静态变量等就属于此类存储方式。</strong></p>
<h4 id="动态">动态</h4>
<p>μC/OS中的存储管理 μC/OS采用的是<strong>固定分区的存储管理方法</strong>，即malloc和free分配的是固定大小的</p>
<p>μC/OS把连续的大块内存按分区来管理，每个分区包含有整数个大小相同的块;</p>
<p>在一个系统中可以有多个内存分区，这样，用户的应用程序就可以从<strong>不同的内存分区中得到不同大小的内存块</strong>。但是，特定的内存块在释放时必须重新放回它以前所属于的内存分区;</p>
<p>采用这样的内存管理算法，动态分配的内存碎片问题就得到了解决。</p>
<h2 id="7-BSP，BootLoader【不重要，就几分】">7. BSP，BootLoader【不重要，就几分】</h2>
<h3 id="7-1-嵌入式系统的启动过程">7.1. 嵌入式系统的启动过程</h3>
<ol>
<li class="lvl-3">
<p>上电复位</p>
</li>
<li class="lvl-3">
<p>板级初始化</p>
</li>
<li class="lvl-3">
<p>引导操作系统</p>
</li>
<li class="lvl-3">
<p>操作系统初始化</p>
</li>
<li class="lvl-3">
<p>应用程序初始化</p>
</li>
<li class="lvl-3">
<p>多任务应用</p>
</li>
</ol>
<h3 id="7-2-BSP-Board-Support-Packages">7.2. BSP Board Support Packages</h3>
<ol>
<li class="lvl-3">
<p><strong>概念</strong>:全称&quot;板级支持包&quot;(Board Support Packages)，<strong>就是⼀段启动代码</strong>，和计算机主板的BIOS差不多，但提供的功能区别就相差很大</p>
<p>位于上层应用和下层硬件之间的存在</p>
</li>
<li class="lvl-3">
<p><strong>特点:</strong></p>
<ol>
<li class="lvl-6">
<p>硬件相关性:</p>
<blockquote>
<p>因为嵌入式实时系统的硬件环境具有相关性，所以，作为高层软件与硬件之间的接口，BSP必须为操作系统提供操作和控制具体硬件的方法。</p>
</blockquote>
</li>
<li class="lvl-6">
<p>操作系统相关性:</p>
<blockquote>
<p>不同的操作系统具有各自的软件层次结构，因此，不同的操作系统具有特定的硬件接口形式.</p>
</blockquote>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>功能:</strong></p>
<blockquote>
<ol>
<li class="lvl-3">单板硬件初始化，主要是CPU的初始化，为整个软件系统提供底层硬件支持</li>
<li class="lvl-3">为操作系统提供<strong>设备驱动程序</strong>和系统中断服务程序</li>
<li class="lvl-3">定制操作系统的功能，为软件系统提供一个实时多任务的运行环境</li>
<li class="lvl-3">初始化操作系统，为操作系统的正常运行做好准备</li>
</ol>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>与bios、EFI区别:</strong></p>
<ol>
<li class="lvl-6">BIOS: BIOS主要是负责在电脑开启时检测、初始化系统设备(设置栈指针，中断分配，内存初始化)、装入操作系统并调度操作系统向硬件发出的指令。</li>
<li class="lvl-6">BSP是和操作系统绑在一起运行在主板上的，尽管BSP的开始部分和BIOS所做的工作类似，可是大部分和BIOS不同，作用也完全不同。程序员还可以编程修改BSP，在BSP中<strong>任意添加一些和系统无关的驱动或程序，甚至可以把上层开发的统统放到BSP中</strong>。而BIOS程序是用户不能更改，编译编程的，<strong>只能对参数进行修改设置</strong>。<strong>更不会包含一些基本的硬件驱动</strong>。</li>
<li class="lvl-6">EFI:由于EFl框架比BIOS要大得多，其启动过程也比BIOS要复杂。于BIOS最大的区别就是EFI首先需要EBC虚拟机，然后再启动设备驱动和EFI应用程序，最后通过EFI boot manager加载操作系统引导程序。</li>
</ol>
</li>
</ol>
<h3 id="7-3-引导模式">7.3. 引导模式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>操作系统<strong>引导概念</strong></p>
<p><strong>将操作系统装入内存并开始执行的过程</strong></p>
</li>
<li class="lvl-2">
<p>按时间效率和空间效率不同的要求，分为两种模式：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>需要BootLoader的引导模式</p>
<p>NAND flash启动，节省空间，牺牲时间，适用于硬件成本低，运行速度快，但启动速度相对慢</p>
</li>
<li class="lvl-4">
<p>不需要BootLoader的引导模式</p>
<p>时间效率高，空间占用大，直接在NOR flash或ROM系列非易失性存储介质中运行，但运行速度慢</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-4-BootLoader及其启动过程">7.4. BootLoader及其启动过程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>概念：bootloader是嵌入式系统中的OS启动加载程序</p>
</li>
<li class="lvl-2">
<p>启动过程</p>
<ol>
<li class="lvl-5">初始化硬件</li>
<li class="lvl-5">从 kernel.bin 中读取内核，并放入内存</li>
<li class="lvl-5">设置启动参数</li>
<li class="lvl-5">然后跳转到内核所在的开始地址， 运行内核</li>
<li class="lvl-5">消亡</li>
</ol>
</li>
</ul>
<h2 id="8-建模【重要，设计题】">8. 建模【重要，设计题】</h2>
<blockquote>
<p>对应前面的设计</p>
</blockquote>
<h3 id="8-1-有限状态机及其应用。">8.1. 有限状态机及其应用。</h3>
<ol>
<li class="lvl-3">
<p><strong>定义：</strong></p>
<p>有限状态机表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</p>
</li>
<li class="lvl-3">
<p><strong>分类：</strong></p>
<ol>
<li class="lvl-6">Moore State models：输出信号仅与当前状态有关，即可以把Moore型有限状态的输出看成是<strong>当前状态的函数</strong></li>
<li class="lvl-6">Mealy State models：输出信号不仅仅与当前状态有关，还与所有的输入信号有关，即可以把Mearly型有限状态看成是<strong>当前状态和输入信号的函数</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>**示例：**交通信号灯、电话、定时炸弹、自动贩卖机、电梯等</p>
</li>
</ol>
<p>层次型有限状态机：近似的状态归属为一个更大的状态</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec8/25.png" alt=""></p>
<p><strong>注意，不同层次也是可以直接到达具体的状态的，不一定要进入该层次再确定，如上面的 Z→A</strong></p>
<h3 id="8-2-有限状态机的实现。">8.2. 有限状态机的实现。</h3>
<ol>
<li class="lvl-3">
<p>Switch-case</p>
</li>
<li class="lvl-3">
<p>状态表</p>
<p><img src="https://pic3.zhimg.com/80/v2-de3a8e09c4e2d6c71b05656166a22f12_720w.webp" alt="img"></p>
</li>
<li class="lvl-3">
<p>面向对象设计模式：相比于其他方式，更容易维护和扩展，降低了实际状态之间的耦合，通过抽象接口来实现，当需要修改或添加状态时，只需要修改内部实现而不需要改变接口，隐藏内部实现一定程度上分解了复杂度，使得代码容易理解。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用opencv.js实现基于傅里叶变换的频域水印(隐水印)</title>
    <url>/javascript/%E4%BD%BF%E7%94%A8opencv.js%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%A2%91%E5%9F%9F%E6%B0%B4%E5%8D%B0(%E9%9A%90%E6%B0%B4%E5%8D%B0)/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2c9e351cffaffd46f94ae002d41838a719141a97b791f61f564bd2768b26531f">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d62e567dedcc8f90eb681ef848fe53d647c6d1323c3bc99a75e5a721492e94de5aa4498d6831584f2219541de02f3b404784969f186b7582c44a83dae3686334b5165b66262f0c7d750e1fb82d13cf5fbe33b5ba2a4be503a3cad3d78d4b3bf9c72a51e8e589fdfb563e17bc8a007024d3c5f9dcb06fc10f8aca055d7cfe48975e2d365a651e0fa6639840363b25491644f8d95badc155fd5137c8934bf230abedbf590c396ca837502d24b336ca985c77df3c76a36081f7d54f6f6bedc9de57ed18b51302de96b7909d7309feaa2ab557ea58c71cccf960082f24a88cc2c69e2071bd08cf550a4dfa632f4f690c87bcc4de561f82b58fff38746325f5356c0bbb882f38dcf1b1795060b2c28954b33ba6912e9e838141bce8ddca883c52c94f83c5582f11a4a25fbfce400dfa316e6119d8c978f07f693d243dde7b4ee73c4a49c84eac6dccc2aa5be5069a72c571f2e4d014b5d224eb881b3ac743db51699dbf3d58127cac3302e2aa74e0d5b37aacfd974a3de0e98c71f6be156ea70bc119b9ed93866eb68b0ad992b5fbf768bc6a69ed036679e2c18bb57e0f4d089fcf58bb0458ced4824a441cd46c0b91fb26b3af0fe45e6aceb69ebfef2103ba35c141c62f4d9b82be4dd8fed21d6c0d7e5d2bbbe061c8dcdbd608610713f5e04e385a905e7e7cd2c258449348bec67f8d488dc0bb77ce1f6da2ed1c7b64ac2fa7298f75b715ee18c3f8f548c9c13a5ddaa183720e97d88a8961101db5e5d215d35897fdcea3fb50efdd95a5f7d1c0938cb59c50c81ed135a2b992da184f92249a1f31b3a8372eccf96937880571d176dd3258e1d01362063ac9746af34a1a8220d4b7d7ec0ce9006b7f421d3f152e80aad1941ba89da1d88e0f9611ba91c9f5b92c93141d1723aaceb3bfcba8c79187f6e775882ca7b20f042a4ff249f0798195ceecb0c18b91e55570b7f9448e2db43f6c0c7e8ece9b2c420fceff28d4abb9572c9ae87d790f4a2f21f2f7f66fcd02548602de7bac2b745fa8d33a1cb14bcbe2e934336a4683cbc44ba1d3f1fbba71cc58f8d7eaeddc97019e850b1e9c3608e32047713183d4b981dd04f4b95dbebd0e620737a699322f8476f2dbee62aae8f92549f14a120b3851f0aa9d949d8cb6cd4c88ff4f315dd2a09f325c3ccd30ffebec4016a683adeb4fdf34d62ea9fa8aa6c978399378b505a4063682963da7bce0ea79163230f7933e6b701fdf963bf8add7c108fcc9e4d9080f5b30df9eb0f4864fbf42b0443a61767b4e340b5497e5b340b11f51366d8ad40aaad224c4751a2d7e5363e85f16725025370a9c04ea155fbbb6284b0954e2cac232228ce3aeb5bad0c67b61284d71b63be26262c4694b504c83769d3fb98ca5da0fac85c391655bd7efac851a822577e19b7f37b5696244bed1c276d4d2265ec27cf9eefedc16f3a0528b7f5871aed2e773c1d96a4375aaeb718412d58355da7fe76cf3c38d1c0b3e977588161429864a45177b0b8b5e48c372e2fda3c829d491f48e69940a3968c2f76281e870d93727ffdd9fea851a4e12f235e8a060fe27a40ff719f50f1fcae558cf790017f9747f746b622b03af6341deca28775f060e2725b0d6d4b25ef67bc5b53a4f350f22fd7024a3f0b90cf608f9ee7ca33b928c3ab6f607c5a328fe6a50cb60d11c5cd4a9ec7b01d396f886ab02327b9d431d2642f6580470c1e5beee6f5517aae68e0024178c180bada774334e8ab22b64efdec6d394b14863b28af1c7bd416fab98fe0f33619d0e4929ccece7213766d32a91406bc2ea066e3c8129d5a5b704dadd94eae41b26be35eeb9dfe47b7763ba43a5677b366238c60b218f2aa08cf591ec9d8ac1672df88422ded7ff712b0feae929c74c1ab8f143bd7476c5a19d3eb5ae8ceb8bfbf9a8ffc94a51e9b359db9fc10e24f634c1fe984a798ba96f4a52520f570ee399320a1669a9e5914edfb83952df2445ac712a226e7f5035bbdc3e7c7c73a936ab94a5b76d5207217b6362a12f5782c89be3d39d30fcfa2e56e447126c15b3ddd1e60cabd968de3fee70a03958b63b84473e65d1e143b5d60d169a546d9b68a0e24451c26698d4807aaa4de9866e85a1ee7f018f277e742455eb49e6d13cae14f5e9b4daa189e009bc16f548c20ec55e2b7ef82153969330be9e1c285032d41cfc130326d5fe64c6cde6ffc7495b83b72d4f51d7edb5ea438bf149ed1fc1988ae051e907d2e4e6e1655a8156babe5395ae88e46760c205ede95572975e94a5d3275129524153b341fa50da4c5207147375a27e29dbb862db0e41bbf00950dd3b3e755e7b9656c5fb45c6fba3da7ee5742be109a807596c7b08cba6c4f76caac69c61e58dd5f15a908fc9318a51f4848b07c7460e581f217f1e84b37d1d01b82f468f6285477e8b36426f7d6c6c6f981e902bf2724e8deb4040bcd25dee22a743b876a56bce55d54e2932e424cb5d2011be31b6f6105aca6268312d7ccfe4232aa48f1d2f4a620b05e81339eddc0d36e96e4dc2b0a09c3d8e5f6a64f771f741a9aec7bfabd12a0b8a8eab77306d8c8075ae812db77e13fca241e331c9b10b5c2a1194f56c108f125836e5710b6f102f5f4175e70e3b63b4f8711a654d1e1e565c78aa600bc4fef4de48e81d538b5fbc882a76218a46d498fabf63c50686a4ebf5795c2379922570f0f92e812e463c353f5c9045630c0956377be73844b77530abc15bfc947a0cd3ba52a10b31bc81978021fb815e9c383888a7712d0091a2827477203f41cd83f0af6a643a4c830908c7dd3a52d45654e566ab857e3dc5683f6896d0dbe53042aefb3fe1c10206b7d51d0edd0de7af3030237afd24a5f32d14a3a0a5f6adaa89f90c729013164ad81182dc04ba5a714e494eb48d21c26714e77305910ab270d3cfed615e9639f58726f9812e1e056683d13ecf0aff31c34359a1ab7edff11dbc5078b09c39cd27440a3a8089edcfc94e91193e7efc20712d9dba3f87b5c60d91579ef89f48823d93e42b314defaac5d9dc49ce8b1a6992e4ab70004ba0778e75bef10c7bfb7cf83d36c00092538ad664e64a26715856226bc38b660d6b8f84bfbaca1347b45ae171620856a693dff0bbdf259b981147de06fe9dc6d5364c7ba9417eefe46facbb45d40ec36e64520a8413595e595bc9c2a4a3858148402eab98522f2d64928e63cac7140fd1815cc6fa1ce3528ec59789f1bbf547adcfcd15d75d75bf0d6464471a41d6532b41e4a4e7b4f0dc6cb2e39e5b37d174838d5d3cf7949ae9854e0450dab53f5279308844181dc7a31ac66f3c49e3fedef71c707422b594761989a66c067fe6c93f7617f5109d92279cca34a58ec8ca727a080c5e32ed8a3f18b4f2bf349c8e53f3d60ee44e6ba3cf90aa120f4765b2a96accbe8fc0042c861695c88cb90156c62f238d6dec573bb37c1721ef8cc304ab590b5af904195c6b70b090df992c4e95b194b057962e003e293916e5b4a4182e616382612b2ceb2ade85ce2246472f61bef9679351bcbdb7c056e7306da8973df590e54b64ee3f744ab4fabc0b5cdf9d22c5e29ff4df6ca8dd53b55928b5358f0f7dfec03ed7240de16de3dde512a804a7711373fa1bc6acc34073ba916bcbc3c4b04d3a3bd75e2444d980d95801a577287b9d34b08a7b48a54d83ae7e8ab4cb6d25fb09024c1662cf525158de62b05d12bc727ff428a29261188a0eae1ac717ca122fd2f154a07ff20474b4d7e719a5fd3929c72cff3ec10ef97e65c1513feba873a200a1cea0b8761e85146eadc30e8642050bb23f6543373ade28b672c3d2d90f6fa1386b5d5b89d85f4e44b8bd8d84478824c15df02e7dee03d0b2021f29b011c608cabd9ef259e4ef4288a1f626c08c11172baff389c3e9826d3356b4df9e61d26c066fd0f87aba90c268dccf51049c8ef748fc983d9b968b8150043e7b4d8ba0c1db562aaa0ab9a8ebd0cf45b6bb5965219b90fbca1df2b0f6369242ca2d9834367e317c1ae4b285abfb12eaf9b7e97cebfda24002204b357d4d9bb5baac66a049d6b641eef4642317643ec993034fe55f3df7fdcfece3f3b363e6c212a187f4ca4d3acba7c315abb867bdfb535c642bbdc6c4000ca0c78a1f1b43b65b5e017f4cc9acfe968914effb301aba6029b4c7402a7fac8a6853cc73bfef37385ca518a6f539e1df16a0bb806d4ec542f85f7e30b449c908d30f7d91a245fd0d3e515bb4b3c2f93f71594cfa708fcc1b969c044366690f4f9549d9e0c8a87f17d4159f41b4c2c1136f4b35ea4907304a19b6d908721f22c24c01a4ed2e28400dfb0a8e989baae69fed1dd5f02fc6dc3199005ea38b0ca79c608047410a7a318f850c48cfa13aef69e67c61b611e77928847c157328b04c623f2eaa21c4d38fd30b52bbb346277a12c4a7fd2bf012d931181e240eb540146371d4ec8707f4699814c48ed414a27181f32a7942b12149de89ca15e20677b75ba5aa052eab88d21e61f6af7c7aaba946f0d4518b4e5c9a74a5f388620c53dc5efcb976e91819764e847d281e3f313a8bad65fa780d4fb79727c116268381531ff8ff7d486b30b7320048266c504782a4a51af0e6457f5be39b312ab3e506f673b2644611a5ed4d98df20f241f8367805a4be2c87ec49aa005f445633922e9a5b02297511fe3f8a1d8f6a626aca2db0869c77432af6b8b58911ca838a55e87dc445c801ae89249c210c56d4de8de99b5936298350245c100c3dec2610a40bed96536e7ffa4723826fb66712623ee030e4e3babe549a2637cceec5f4b08c5fb4fdd38593ed0f053945fba9e10f47ccddfaad90858857e446d85bcf7d8f1dc186bbd49e4782ad5cd721642e221e055e96921594cda010e6e227f319b7134e975205802d3f51878eaa2453b9e0ab3a204d4d2db31d444bdff2889fd365b3de7e2fc77bd3f228b34f26906bc6e6ee4b1cd71c2f7b9ea2ca3e9afbcbe4fb048d25fdece5462a9f4dd7bfda50f84d47525054b81503f6f55b7c48df9279d0adb86cca5142f9c0535c063ee7ae989638d7d0cece616cb5f05479a32ef1a4359a4317ae1ed9cbc1897d83bf7f61fd6324e861d7e27100b221167738bc9ae65f637007ae075effce1e7934d5c011db5a9c20c4ef17e8ec7a8e5a4acec0ae37bf59dc396f24292b0d6dbec4cd3688608ea358ae6c88dafdf6ab267a45f25fc2424a6f764c91678ea200a7c68729f0179bf88cafcb3e4af36dcf44efc4da0b59b45595350d2da3869b0cca69904c849d5aee52573e04c3a5330230a9db39f160e1e06e4b39907eebf23484074658a986bc9bb71ef9a885a137db104a8deb0acf5205743e7e5435dd441937ce5ec7218e08af15fcf66939022ceaee412f8713618287bd29939311a191c0f373353e42cfea841df3fa0e2f4c69ab68cf92059776152360905532acefee904f91ad1b27baffd18d8aa5336488157c08cd6d772c441ce4910570843c41723607bf9d3f254cc08efc7bc763ec6e664f65b73599d2cd8a5edf1bd9f5708d4993506ed4e92d151dc9de177005d5e3cc9d3b2136ef3f0f8d77893f1c6152498a82678d73029b86bd25c15a46d10e158f8b30d41f0d49bd7537d451b8dc55ab5648e258747729f8f48c4ab4c68de83af20bcc598170bcb554a6a12ad599f7af27c22dd4bdbd07433e3882cb35c0784563e352ed956e8b55d2539ab26d3b2054ccc9027a8554d5f4107e64c750ceb25ddf952a908585d26ba68a157ee6056e2969f1ebe00052a46361d5cddc39663dadf0ed7925443c294e7f2990a357ef9469f08c2c51cfa9ccb146cccb3fb6e67d89de063648bfb5c9a7b08d3b6d2c754fa67c0c22ec2c018897dcf717697af12e2733e80a279e70b34a74d90cad9241538d4638f7cef4e2ba734d1fb19b1a4b5da4954038638a3750be0003698e054169a4e4c79cd0fb8fc3180b46e4a4aa9fe0912897e42d34440dac729bc2cd78bbd0bf4aa06f2d1d26e938091dcafa791b86cff8cb10ab49fb50e6ac8a787d3357706bc48dda5e9049975f4535067f234755bb51502d8d3de9038b046b3840a261e3942d24729303801e65fd2f4ee5bdc49e5132263f2451d9b3d6d7aeb6db87e74c5881b97cc071883deeffa34ad8f411b4967f03fefae8f906be4d93d36f22b45f7a3472ba29f85cd3d76e6f015d7beaa34b884916e65aa16fb873c936434d819ef988cf8a5e1fef7f20d7282c749621f842b70fb4faf1c57c28857e95a49eb4823b27f3b8a82fd5a90e0aece7a937128b0f2225ed5158d9b25e73f30104bf357803c3ae87f376f59a140939a8fd0e627d85274c5c0c51891d21f34edfb05c7900648ae1d894e0335d0608088858b626dedf3967b332ed89fabef4567ea417a20faae32b59b42497ae913e49420e1e332318e3068b4e4f6cc870fc64524f4acc0c30a246cc0482a114b4b0c922970fdf108de595e40588ad80e644e94b9c3a3dc904e2c8f7e53b951464c536edfa4ce18dcd166137e9ae3048115c6cb5318b2bee4cbfc0c7aa7fd08e601689740cb29d9eafdd602d15780e685736bccff165a54edf17b7bb519378227e0727675b5c9c71782a9553a80902bbaae72460f46cb6d91704f9c18ec034decdc3dd317b9e8bd6b3ffed18e99eb7157469f4d1627e3e317fbf7ca8e64d245b24b77d16b1e0614ef171324a975105ad2a741635ae65227be8a54267bcc1d9e9dd841587d4f3a5413cf63538f2135edbbcc541153a30b2e8106f6971fe024da59dc1325309186ae10b90b8f139bbbaba1c999126a19c9cb10fa8b6b999b18460be3ca82d2f9473160b3157c1d1448f92de8512d44e78508f0c43342823c7cc29f8d647f4b03a86a2b532a3c615fff68c13645f5b4e69dd6f1259c2bed21e13fff1caf36c6324ceb231a7538a64302036ff04dd4c5826b3cad7b0532f2f053b65eb7f8d8d44142b449d1a30ec03f2cb2944795ef3c8f3e22462bfc74feb48a8f4977ff7cf1bc110be8fdaf82bdac25c3472afb6f5733841e9d6ef64225f7d232e4eefaa501a407ce7c0399e8c808bec7e369c773d2dae7ad581360993273f354ac59687a1d8e313abb6ea1c85c35c86793b2a0a510988fcb3bee7d2a92095510e423131dac847a803973fe6233bbaa3ac6433985d632d326db1ddecdf285b282a28d263a86cb1ae7f3a2886e31906ce185a2285c5cdf1c1ca29cadfe2515c12bce94d3d592dfaaa7acd86a4dca4ece9a2bdf240b30492bb8244d28274983044891303fa63c4466ca75bbadc4b72ca2c6a66013afa3adebeaa6ff88074cfb150c7a747e33c8ba7498416e9963353e268cdee949fa765c7f5af32ed11e7f5d26fa18b7dc22f7b074fe37680c8514ccfe57c7c1d848e58c56ef6817fcaf9ff3f1636f72d961213f5f78477e8f870992bb52b97f9c8f8685b2618dfc2bc7b3467b5ce87129405f8112f1c20e999aff955312a804a1c07b4a6641e9f6ccaadaf33b696144baf497ea698d42ac65f80037c661dd05f1ad4571bd088bd062d150ad72c73aaa800c09aae452661f5f151de8deb7513193af807b5bd7b51ae5ddc3605b4e451791a703fcbc53b53edaf998a7a3e94e2a6214a945ad2b38dcd7d82304fddfdd9d3ecf9766148c69d6461a4822db1163fdaf5bacbb9c43466e118abe5313e8ee49492365ad4d3a8fce52bf985277eed3fc63b497450a8e4c02bac25f2f9f543bbe5ecdd873e3393baba19750cc4816ce448b6f1071cf4e45f2cdb2478520d4086f07a3754f4fd2a82ae67a21fa06d6e3808b57881dbdf5a35d06fedf98658c3d81b92f8b2f86c0d2137d3d062c0044b302da7443024b932bc80b9e31dc0a8c934319a43fa51772a8cf0bd4840e522a6eaf24232698c1df482d906ff4109a09df451598b625652f1692a860266f125c71e8cee5cdd5e76e0a376c838d736a09268e9208d106054ba615095cbb14d1bbd775162ef9dc4339e66ae2d21273e979e7cb05940141f447867c10ec59b96d52dba7d0028f6ddc1a73acb8ca986b89cccb119751d984d467a3d15691922ebc0274b033bc1f7fa737a1c7e82948bea6c1738939d0d2862b902ca0cd8afcaf8afdf25707caa23aaa2647a48d08616ca05e091879b0e89fa3e91fd4648fceca4cfb9f1937af150720480eda5e270824d204dc260bb3709e6b80d7b33b34df1374a3c7f00a5d23143b4bc807557d0dfb8b46dbfac58beb527ee4e74d65418354ca15dd7332bde85dc235b9adb6cc8100a260df3a953d102c35a1229130e4e27f9b270b930a0ec99159078fb211f99c42b7daae9c28f14b367655adeea42ffd98b9407b543919f04141f00c121554d97acca875f4131bd082354d2babe8fab3f442b428d8760de83e3161b08fb2f260932aa3095aab2d47a17dfffa66ac4a7c5e6ef659b44133883b2b61aa950ce0de2f4662accbbfb1fa6d5639c84c0a29edd5aa625fc7e1d3b42213fe28569a85d6e91b033dd96ba310cdc39699e9e0c7d82aa83be441a3db21085cdece29a4e50b2649f94f3797aeee64c89f0ef548d58fc5dbb57b190e93ac8ccb4d8f17977288e6de7d32f638cfd0efff1afb7b0f7a4f5947716ad990098eca9d96aef7f3ad430ad5c243705a81ab67023e668f14c4920d9679890abc52d13963af00496863be4aac74dc75533a387cf99044956e1baae4721755751e73487a3f77a1bd82cf8ca5a38694faf7c7a12d4d92076d2bf05f8801d709b3ee26d4fd12e795d39a96e29e29e3c566ffae99479b968ed775fc8a62d018bccc10416ca7f414962901175c1beab6536b16ef2873d09ec2ead6628b3d6cd3714302d9d25d63bdf3199754e5b66480d0eb164955d361f5da8d52b995a58d59b009e4eb20028ce79c850504ac2e6a9573056e045c505441e6d8e3c759bf3652abffbe190450e159befdd5b956899b2bf707b1ddef7a8ac8111941c2b5d9ff5769939cafdda05e61477df3f9f98f0ecb1c4e1a9a98ec1d850d969202ea62ed5e57561d8226c89c63ae5d298d0d54ffde1069bbd47d79e8c242994a5a988bde3d45993f579149627fa953b71e8befd9b9ee6082524bfb7003c2d1eaab149619cff124e688af5f4c57011349426c487541b02789b7a489ef986cd7f8ef5572f13090bfa8bb8c53cf5359d67adb4ab44d644ba85ead4a2b133b5cf8daca4210be55a1e40e218f6865898ae81e395cd4a57da3a7c50e93e17639671e5a4ce0b41df77eba9966cfeaf67b4198b92be24c0bde9f15dd0ab788cc49eb9b07b80518536d64fd0e49ee0c0eeea4edaa7a4f4fa2827ce9eecb847ad29084db120a317b7e4c03e3fe64197b3edafe39b399025c3a91efa72cc9678d8467621dc7393dac0802ca13f018120c37112a3cb1df7c529b215d67916f78cf72baa29a671b375d17b9ddbd9905567e54792bc801270d360db1f722720230f548b80f215ef780077f3b60e6730822b164cd22824bedb8ed7a68ad2240e9fc8e2dcc7ca6543d3ec91a33a504202009cec9839611c6082b4c16c709e24f2eea21c4cbb509c7bcb9f5475fff958fae05eb151cc635a438ff567dea240e9af6b7a6b684a0baa2f7e8822186a43f3fd2ccebcb742dbe07edc10a1b4f52a2aac81a233a3ba849379fec540c78c6a4f057745375635c8a2d1faec8a954b32405536955c5373f6dc371b1d09bd7a0ee0deeb0774db4b5686c62e79e95f2f484f17a0f870d16d3aac84d7e8be57266a851c10ddb40eb779db2c9b71a16e6390e4d8242de69f5d2a401a3754285bf4d8041f48a365930275d7cc7063e4ea2f0de8b45f4f7818341da72eda65ce1868f0676c8d44933fd98dbf9559b59bc5f4a968a801320ebe42f705edef460d1d6f325c303ad282312b66aee762ca74713a638a44fd40fa79011865a15e68aa56e4dbcfe01728b57c16cc607bb3072a4f972e2f473a20946be988be4e248e3fadca4e36e53753c751e96c0474d0ac18c1aed94e1f8a1c0cde21087bfa9d5f6e57bf51b84d6f814ac8a6b5d1606a16702399c1231b87c3612f27d0c663438ea04bf66beccdd09b5eac8e35c4849b8c81d40194b4b7bc34e6a74ce148f038e7c3bdfe0da41d3bf6c8c3f705a76a6655b44adaf10a012b90041ad3d53507a7fb52e3bb2a418bece6b1a8abe09b197bad9644588ada31739fddd0bb342251ce61ff64ad4885bb2eefc28d4e3f2df674a86b83395a140190cd3fa4649c07c4204dfa1779bd4eec4bb963758a56edd3ad74fb798bc98015d600f66ee8c415c2042651d6264c9d739d6ffc71ccb9e49d629ab395e1c9364610d91632942fc25cf4624b6eace1eb7da19132e41ee70ca8bf4527f91324f0f5ae1a51f35950dec3bd5e58597e082b342ce19de4b91adca3d719ab915ef5ff22718d2ab96bff61f49317390e27fd474206aa9a2acfbac2e06f76e7df47ad1fc5f9be02fde9f29af3f4d2ad1022867e68cf4b6e72da138009ea3084c4c011337697924960ef493f09d184cc9dabab3cf2450d1a50c9b5f0152cb61bfb13c75009a8cedf54b80a6cd7a65916e53c6926091a45c749e3863de764cfa4951c3258a3d824850523c647e158bf45416ee564fbd5d44b4f45671a45d73c4e9b7429fa90d3da98de9594473041492f39d7a54721c3c665e5cb170f260d08bc2e952cf4d9f291b7fbed753801ea051c2be539b30f76035b6e1aae12d69bd19cdc2396eb03ca2e8df0db0f5236c31f3dfe7959ae53115ea2c41a1b58c6c37044502e8a875b4522da65e9f60fd1353c9fdd29c0ec0116a9ab390812fe7c8bba59ddb75f0dcdfb2b74e3ff7707508e100fb0ec25236ba5bafc0b460864f7eb00d99657416bd11cae5d0f57c5cc10c36400b1121e780e20789a1b9804927e838d7cb83010a77367cc19687b32121f48e73ef368ba5955fac4062efd414d142830c2d08cf340c3017afdb5a31cb9f672864f37703b1c6d83ab540aa8892aaa1bbddd53338ae69ed76dd0dbfdc17ae62d778d61665dd0fe8bca0b19e23ee18de3cc949bdaa4abdbbf82b0c3e166e83021e0e05f39af2a6efea0652ef0002b4a7cae35e7209d00a9a51cdbd92d7b65e67b3b13f69e86282138cb1fc8a86fef1923e20638a6a110f448297535d51c0edc58c5e1dbf456d705d9249dc5368277e1868cde964d2f8efe37f9fcf51621e24de7f00665b5dac112eea6970965230943e9f9ba9601a0c0f8429df0d594322e6c746f08b81314effff20039022e3d11c104679c94a20fd6ff61a82d0537b294e4715e466c237f94a5969573926c2a00fd9ae1ed4a9f4776bd11c5f9359225eb0745ed0197173f8a3ecfae675342817414cae21d8d25b6b589ba94fbec05521b5a1ca584ebd503e153cc34fc7b0cce33c6c839d8000f9cf0597e8817d25b72cabdd45e7f51e0444d14796d111525346db99d0398a412c281a29d8c1a82602cdb374408c45ababfe139fcc0ef39a7b27bf07ff0abee89dd49970a953fa7e508bdebe4cf813b4f93cd78baa2ea76e64542d562fa47af2c58a28ce70d09ad5157249f7768ed30a81d68de697965eb248b2d546d312bd35ce0144c7747774f285227a065534c5d1d675d3282a15e01db9fe6916c0aa86d065e09a2976717db761516e9de322ab45c5582542e51657c9630becacd7336af9c4c8ef6224b93a12d929550b81fc7604fbbbf5bebeea8c3b68a87585e321d1ae085afbd1566ae0276994ed6822cda7b72bf597d15fec92d1797a713e6a905790f93f1dbd5fd8a83536ee518ce8b20d0af6a06d94894bbbad1be8d9c8278e79d189f3b92cc69b859c66fe3151d9ecbf46ed27147f86d0f87edf42e2743d3d5cb2164b891f227274850f1ef8e443db3ecca4edcc0bc124e557b7fb469b43882c62290187e441bf65473dacb8b12645d49affab34bdb10941ee6b83829e5b09cd52daa47983e20fbc82fb9dd70e61f116a3c5c5bfab74b50f22f1d1386dc8771d0df82cc80df6f470f650d440ba9f273ec79d00afe6e909235bceeb99695db46006683c882c2ba6674ac8fae360cc9a660a0ce7825e8902a4d9962be7d13e4b4cd9d55bd1071c76e9ad88806dd71b12f2547f23b355764f143fe84147312a51e49acb7848a26332ab6ff2e28a3502486f8de2027e473b1b2ddcb8bede5b0db0d095d67f01a625858ca1d07e9f2054a9f52d07272b4f55de7258dc26d18004a7c33dcadeecf0fdd98cdd65c6854aec1002cb648b85f0ca36494c15bcbe4aed5b532629a1c04f283f9c51506b04acfcbed4bc42f623d20e0942569fe70e1a6e80c1bf37f99250cc504262ad04acbd0d7a9c50d2d1f685106f639be0ea976be4c2226cb28b4f7bf88aca11548a4bb0e296f862e79c10173f287b28fa2fc3d2e3f7ab4350bd8e1a553984f3b595b6e78ff8de4ac8b1920db14cf656e35d96f238c1e36f44b2804db0d0849bae45bf0cf4edeb7b65a36716cfd89d45957eb74565fa3da1810716987252d56e273ac484f4c4d0a9c3bf3e9b9a796313ed399738b5004bab395ccdc86919fac728f385dc6bce038777a4163ff7776f285f8b1fc4ae21241463fd26f8ef400b2009d1223f12bcef70bcd15fffecdeebe61e56415cba97be3d7ccaa705c340b9ee60a761e5e0cd5ed81238410ad6b8f6f173104ee96ae405f560711cd7adcbebff47d016d5bea1146cab7d67a634c5959861668f78fa1576f0b2b38fd51df369f4497a5f9c02ab8b1a2b8e544475ff169f09f3bf9dc66ed0375c6e86fc02ed257c3fdc8f3312fd94f64133a206fbd631e9d7bf575c71d5bd4f02f29dd6ec60ac27178fe15d989bcf57dcc1c335981cb834a4527c3ba7474b52f3aa79ae93dad75e43d36ffbb8791d3f8e0b228d44d188804e50c20a97606fde57da8b3bf3096c8d534f9245b409baa49c05378fecccd5af3f646490e020ba72dbf0f5ef9e800dbeb51bbe7cf63b79182e60ce9f84f956b289cceef7cfb42bd19b3c4b055861cb98f1b0321d30a9ba6e53da8f784b7aa6db7e0e0997a6d04d509173f4d5a9e977bfef16a9de23c84f295c63d57be393dcd2881c33bb8e566753655d364bad2446723cd1b86dbab41ff3fdbca470e4712ac0fc7326c292074044ca287c57571dacc9fc9d2438318ff92baef0826d57db004ca9a45bbcd2f606388a276d155fbd95ddeb6cadf22d9108be698f1d8bccda22819a137698f192cdc0b47621853fa1e86e6f5f128c5708fd35b9d0ad42e66d6f0c28e161bd0c629c17da2a38a2c411a356fba2a52aae7a42d35b11122da78af0e817b1d9147168f0ffac6e3c30779d826ed28e01c62e1e7f9540073149898b21dd740e07977f1a937337e5874b04666c023d5ecef4dcc215f0ede8fbc8bbcd92dd968191657e6a4294f09d0673666ec4701a29bfe21a8003a3ae736bb07bb0f26e4317e1b9a1a3625d76aadde146a31048423302f439fcd85b405404adf73f8c83c091e1e9e7c72c669e3fc603916fdacdab8f7c5ac064c36236060bba9f6e5189a3dd82d540b14e9edd0e7c96ee9b8f3fd096fd9a9e68bb6f6a54d126ccd9f8add405a52e238eff5eef97b44db3c994bddb4ac96ad9f39200587e858b0ed5b78395396469561a8382a6bc01455c5e198dc001e6a623a25a8729b9396b01d1f7742ec06997f8dbb96d449ba2465c5c7d398440aa083aef201b6f547da74d1d2c6e9e30176147677fa44cde734ea89fd34e989bfc8d327f84a1d43c0353746bea2fac07d9173379a82fa9ede1525e78614c9030c3bccf15a59bcc42c7581804fcf9722072ab3194ce0a4ffb7119e4d1fbce4a557c669ea87ce9dd80a288142ea8426257a4f839a15067d33d0b1f270e33766406b34b62453bc6fd14e6338dbefc19a9c605fef3d4282747e330e033fd9ab1401e668ed0b360b65099399929feca1aa42c0657b09f64cc617871b7d25b6778dc284d1d6289c65a21b65551657e5daf9ef4bb2b74f430618064516c1d3e1cd73f0b3a28e557d0303d2a6198cb4a2727a4241b7677879aa3818a3f429709294d3905e24a820ce36dc8687d596fd4095d5f778454a42fbbd9bcf5b36b1be83970663ed35305cf3a5829fab83c2e06bb2294119a231a9645e4dff9ac1c6bb7e1059d6f9a1bae8550e620e240dab290fe2b29c8873ed29d9f7fc9198980738838d52ddec1237844887168b802d496953b964f43708f6a1d9d544e4c27bb29293cc36f1095cc11422e14e6b6d62eac59e3580c8b3bb4ca33712dcf06ce2976fff64171145e6e4dcf9a26a2a1f584a1c22c5272626245daa3c7d1a330fcd6b51711c6bf5003747036623b60a741c9bca0a88fe53a232a4de52d793b6756be93b255f5f9f3a43fbfec3d2191956d38b5c66ce113ac8d4d24e665ded588d43e873b1acf6b5259f82d496a01abe7bd7094bb43ff6a6038698ef2aa4196dbf9d49081b095730077e1431b986028f2d84f3c0122898e87a5a89bf1b1e2b21e390b9e23b760dec35c13abc508fd3384a1773c10c7f4847f41735d729d2689b7705f8c004a6f2c5e64347dedea90d468ae372c6446d9bc0a0b09882404586385d611362d1d5ccb8cf575d30237c5e0f220273dae0b27afbd2cb82be5efbfd4bd652c706b587ff0547d83f5a7f57c6c35be2d0d600c7817afebeadb910336ed77e668527e8b67e79a238109a60d813ca1af42c38f615a7beda8eba4cdbebb6d40b161ebe7303efb2e5c3e12d25e2523517e608c42a30c8ec9d6d0eeb219bf732839b159b9450eee5955c87047d47f7229c60e4f8eb7d4e59a9c19a062d0fcc8dbdf1e28e8297596db631f0096d72aa5ca209a7100481bef143e28ca128f331a36fbb5be35550e0702c99e669c816c2ff7dc4ead04500cd57f1a36839921b4ccd669d7f04fb96fd345d59ddcc97847bc22288dcffd6918e8b0993bb3bef32d7798dfe8cac2ed187443d76f084deed7967fafc7ce8f83ff70785ebd01de325ab2f5b6bdda929ddee1f5a4a334aabb11ee89061d25089e5b57c3afd1eb80741ce432011a71fb2b3d187bec39256a78e371802f961093164a58279448425849b8b70daeb8156e956a11cdf1894cf4357ee4a5d451140f0a314e5cc3b26244a9ee751ad6fea3a5159c2a11a2550329b0fb6d71139f6a95244a30ba4fccaccad382ad9df80e5878bb9e295d0e45abd0c9a3ab1a044e31bd0ca9d8bc25e1e66a4d5356285f82251b2593ce59d6d47c4fa02970f799e7b903e84a99f8fcc40cde5e02c3f733c64b3b31155c0ed15b1dfd8856460db1972677f28eabbd59a5130b2cca9112656b76b412ac54574a88cdd402f7f5a6037d43917a77ac98f2da02acca64f3724f08162a3b1e66d5e31665df6282bb9f102b723e52f1e1d77120b18623198d9f719353f30bb4377a87f2bf7a122f5f975a32012cd36a0af7f9e8dd2eb5f8e6c8d4038745afbd30251f64eb235ba4f68f313e2d7e1ef14d349f98fcd009b497d07cab736f759c024a131ed719709509f2277d6ae935e3195bb673bf0794a41d9c4bd12bcd7fe4146d0572b403f80d3acab97fb14487d3fbbb892649a9441c786a101e6616a7b6a919cde5e1dfca110a62e3d8227742148848105a4e4158e875d97a247856189c0b0c6b030d83eda63e5f1442b5b804273d4ac2a444a9a4f4b9acac5fbb07c40fbb870f2569c06b8ce021b73402f1fe245f5d6a1554489a194dbef238fee6bb675eefab975f35542b6734e70fc1dee88c89155c746a7e061548b4525059e91171cb50482857162d85396985cb6d52b0ef4f65ef7270e3974922b4a7798b49e17b48afdd2ed7e73a1f168818f3cdf5514882a0483bf850d331728af60becef0ec6cc8b9a1d0293baa9854d000765f7bbc2ba582748df9e76de21164c7b54670964ff908ba5a21d0c43447a8728f0f8562facb82bf0c5edb45442a8fe1908233f48b384c415125f0baded4717a6d89245a49b46a36b303137df3c9c7349c14fba220fc7737caed0f1fea193acfde984dcb829e269b115d69d69c8d8b63ae97ca66c9522c181d0a52def6b7fe9592ad91f8cb558623d6897e1cc9c08e16a4a27d087d72a7af57e70abc95849af8742877aa6ee9abed18d55ee305f9d98801956260761d16e17286690c53b8db50e0b65411147bda9995738f46abf2a16d8396bf672a93c521388bd5aa88ff5248ae23aaae50035e19d47417f67c54bf2b27b725b68d7efc7fb9161fa1d11ce36e42385a0f599768492e2ee266ae370d348174de9cbdcd94342db3e9a3d30e6ca4055eedc97d2a6cfcb4ca62c231a7fe2c1ed9f7971fdd4effd302e0361dd9ca7f01d9a493e1cf0fc18346698f3d8659c9767dbfc792b1d28f3c79f750a2038dc9220ec4924d22043be85721675535220580b9b5374da5da856b63a2173d0a4f92503dc8377eeff94ad2abde3f1a894c570cb1c4ec8c26b4dcb775cabda84eb7b75879371cede1c2952cbd402809b3956a9f57cbf13ca20ea3a6da1ce954de33cc5ea16a3b366231cb1ca12980c57887f1ef4c9b763434050c914254c065a95de8a621ebd4e74c448af8b0520cd34b6677ab6cc5f063d45b7e64beee2f5adb8c7472f0b37150735ef7982e0d1e3a2bff2e95a7d71d870c4bac9760205ef5d14590d45183a3892bd4b2ec5d97d250d2c048352a44c330a55169d99402b7fef2423367ab197e7cccdcdf47850c4e83b241eb709346122737cab6c96d59b42ac14dfe10d3227d9418c63ee16a8de8ec5a0a78fe15ef2c1fb791f153082b528a7ad1e441f915477fe76212d941079c769c349792b258b55b1a2d00f5a28907b378f669d9bbf2b138b62d856650dc76cf81cca19bcbb7545567ac89d7de502209f36188958a8aa61798e51332d38cb5239bbf09ea8cb0722ece97c800b9b8ce1d073b06d38915769bc18f12b8fe94fad863c862ae06f8e1cfda3f1ac9c5601af4e0257d2e149e751eea6098ddc644ade9ae126d2074c58cc1989bbac745c3f868b01ae1e8d924bc5b5131bf8a68b1c58fb82267c14099cd0204d6ab6d97aa988e9f159497f2c70148834d77a15dafb29fc3bbb7fec996b3c97757be4b019701d677a516d0a9156c100f37fe2dc2e8ec6edb737eb3564f1985a5642465a841d6ca6dcd2ca9339a24160e1c56779120dd89b6055cd9b77592bb74d547539cba6a8350563812389574fd452f959d079bae7aeb3f511d9cac835740abb30305bc60ca96a35a5eff23e472f40f31bc2f7ad36de99b6c1f4ff11c67feea9e9376db4ec622418e7bc6c51f810ba3f64b14bc5bb961f0d0e2881e5aaecd2361b945a4ac3b40ee215ad8b82cd0776093f187d2221607d97c9855c35ae4ecef2a7ef6cd1ff4ffc93cc8f1697e13ed88bf28d2495cccbe502e91b8ac823df3add0c1fbb8de26d64f1cd9c4aba2a792de8c0727b937dab04b7b0c48ed2331e735916891c4be0cabd8fcd7f2635d22d9237ab6dd60983b69ea4b3516e30518e4646a0659d28a79555726d847eee6684ee4355acc9500def82f9c9d7c98d1593820f6b5605a9bae0d7b36cb830e8b12865ce77a718ed3d2c335fc9e9ea759351f7901b233b89e2dfdbb515b5ca397fa8c1773ac92ba090f615c6b5caac306deef7d027bf7f5adb0545def1e7ce82071ceaf5e909c1849eb8343467c469bbbe0f81516103cf6c39be4014ee690f643d4c6b81f0d5daee58b69931bd2ce7bd84602ad934195012e4d7ce6bcc931fb8536dc7164796c66cb9d56e969dfd7ad9865ccee930ef661297a79d98f8f1ddd23069df8913b93a12ec7e2f474bbb4104a87b1dd4ade89386754fe7a421a7387189c6581c5f2c07965a859c5f5254a45706bd22010dc1bb8c04fa8f01bb3eaddd7e21282530a98395465a265b60cfb45ed14a3768ddbf9cbece26b6ca20f129980fab58368a314230633f391ebe4a0df9e0a61e01e5c4342acf97c4d792ede74a7624e23b6c59f83c7f56971626db1deab7de0d5aceecb6b45bbf6759149a1b164dbf37854f3d229c7090f078885aaf8e671f3b71940cff9af50cc9b9988712233658e3bcbfb08a6330e2883f62edb356ea9d3ef0b816166b83184c17d706f92ef22d1719400536ce40df30c1f7bf95fc80192e8666ede8b7676e4a056fd6efefcdddb08cd957fbf1b854d9d35b1ad5c09a7c6554a291f8e81886ab4a0b3f2f7aef0e8af30beab7138bf43ddec3341c549490f4b0b4ff5c5e1d6615292c9795608db6e1d361cc2ad8d4f2c23ed0cf9e06ada24aa8a8343daeeafc02fe632cbc597ff50c801d0bd03a2d687448d0ce14bfb53871433d8e873b7ccf3b0271c564011bc2b9d341dd855c9d837929f63c69559cfc28edb62014bb38ada8350a6ebe0df7e78c1edcbb534888c12af57a9ec3b40cd66033dbfbf8e74409bba5dd30b9339f69afffdd6caedd2794f1ff37c521e719f669483d7e3e877229eea4a55599f4cf8679839e11ad269c8d4dd3b2afd5e9b843349e7e13aefceb6dd38acd8f37f6502de06d0028b15e092ea5a48ba4775fafb71971719a4e98a3ed75163be605a4d991accac07c54df0c9f3d7eb0218c9ba7e6640833bf5499c8475ba4f30ccf2189cc2b1f659eb323833035c60b62f9e9a58e1deef67c9da0ce5e23f62006b6e2e67a1e303e701a8c901b17edd4cfeae670e3b9a096fc29fd5b35db6d0f93e859bf257bb3cb672adf9fab224e5723cc8edccf87b51bfb6b68e5ab719841789c917cc145bcaa8109507163b9aee577a5645a361916aff51d7814b1c9707c0464525a33e8d38487a7b1dc05c09339bc9d151d8f29a0cc3ed87ad75c7bf637df97f3366ba7a9a62fc93df6309625b5c2acc3d099c2bbf642fb05c8bd59e0463f6d92f8dffc3574e53748536329aadfa6d4fb92f0766ec9e3986735d16b4d9f20a30a58543f882052b8b8d72fcf9f0e6c8680a667500949459eb3ab0c2df3018acea26e12ea33225f94c17921b08fe87eb0725a74a0cb7758bca93c3997122017e7d75c5f044cb8e69fd89a1c44532dbf5a484b946c00dabea02f3be247bb728e912c66e35dc200147f9ae3a62e09c23da419313518cdce257b0db682829c56bd34f2052558a37fe9e46375d35748c7908f30e5f9cbdf4026b4c15bcf7eb115905ac1e42163a953b5fa1b7bd6d55bb6a99c189f7a5569c3e59a5f437ef01c3589bb30cf646b18a2af48775b7dfcf1ede25c33ae2d87a634011ef9e6c04b1e27791539dffcc2dcf0bdfeb80601779c183602bc1a6fb102504cd93c7abb3f097941a7b20cf87b545173175f8111e2460c18bca48d250db8ae202d02bde4d771bde7c23f5af7784f99e3e2926b62f5825d170c25042c31c7232d81754f5bc144571de3d1d0e8049af45e37f0ee47a2bbbddc0f57b375868b8d4fad2597fc8f2a835f9b50c6513dedb34dca5960f6471aa06d8804f663aae28bf0e5ce5dc53a3efcefcf83b0feba98ae9c31b32598d29f038fedc0d5ca142eb1f494b77a00fd51cefd0dc91ba1246faeccbf3b146e8a876102a45bd65279ecec4f3b19304b421d0039aa77e7dc5ab94b20c7f939c4551239c8c4442e6c56717993638d523c68aa1018421e7eaea37fdfcbb4e73f1842181e1dbeed7e65605657dab4d9266c7942fa63909aa2a8968ea9c52ffd1f924370246c942a9f6051c8da7b353f2cc4cfda4f24742ca82cb61b53de8d542db90d0b1c0a51dc54bd0675a7333f8164c88055ffa572d8944627398caa784a134705a4409354f11918357b75814027291dc42853052484067e54f0177eb03dfc8189310f4b068fa3fb77fc95887bb7b8479ed434507186621d6926bbd838ce1f26bc58c68d220430a5bc7ad36c5c860fdd465e33ac20b5714753b7ed735ef5d278f37ad17b703880e913790d03a25f3f90191664dca4886d15005ef83b7d31e7cc3e5e062797bff2a95cf788ba19fdf2279ef31bdbf43c6ed0e3f3bfd767e8ed4b7662714def4086318726aa141503f036ddfd52e68b1f1ea346c4d306c70354a49ff1831804c2f353fb3bee4322d07cb4cfcef3fe7e40c7ae51ae87bc6573507a62ee3dd8a1430df8101757ac247c7e8814f8e49694260b0a60fc3e868d1a8adefbd1b3f886d6d47d79eb60449300bedc948b1d4aeeabcc4ee97855ebd2666533cfe7a8afaac3c83a161a9a86dfc2f34d01a4bcf7285fe58af05e344a0abc782e6854272d6b4782732b64e95ade501fa44187733ece15db6aa5d4f3bf4aca8d135ad12c3bad34dbbce215f2f2305ff690c9f95ac88fae8faab92269849116ba7b1bfa08ac2decc6298a48816f41a7b61581b187b0a69f617898faad940af7ffa93419e0cbc742f5570365e22f7a1db82e7bf0a3c51e8df21cf4c22878b882641c26124861284a35ed1be3ba7e21cb93312c16b22d1e4e0e835641387e9db65858b8016664fa97ed49703050f6eeb5931933eab34e9565effc9b4ee38626025c04504a14a7edfaf3d25209eb33959d1a57093540e011eb571810a2ee479c78516f78bcdb790aafb75aeb27da387afa624dff3c3b2e15715b11fe8758ec7efe79495212e01d2c61e41eb9afb18b9e6477b01ef26c1068d02dfd8aff6418667fc4e46289bee7e10332527e5e28be59e01cb598143988dc849783feb1815dc02a8a560a35301b9a9eaaafe67907f97b136020085c308d1ad8b15dcac0128990605417729f6e70799998f9b4045efa01fb7111074bdeb3df525c5e1a694fc65598c67b1ef3eaf442ffb4d1a1555c1259a063b83075eb2b14a7460f9e4b03a343f2ea7570d6ee09c119ce6b75de004eb6eb66e1478d35b51705084d3138f217f99920471444dbfa21eaadcf7282020e70b08fe1a067598a32051ae376c8739a91683f02d1c2dcbd3e2a9bc5cc39e1150a64b9479665d6bd1a66a43138cef53c04c97ccb37e59beb021c4cf66cb5c31e142bd8f4628106d42eec9ce87899b48285960fd4f487c09de11f6a22a1751f500b46a1b6caa71a2de7c8a8b48264ca1a831d388605ede33964182866b74fddf1d8fec0f8c332fac60930f6432d57a4b6fac7c7238541d9e7a04e0bb5a1d9c6ef9b653279c573196ba84fef943990e85d5252e5dde8c36b4b65b4c33db815e60772f1799e76ac1eea5859e36923e050bf278a4676a805f82c6c74695d13e430e9d2d20c9c295a869464c879800c41ed9f8577a602ec33f18257f6b31b861f49bca9785655c91035463c5788f20f19a212e4e965588d2b174a7ed9f6a2d42114a6712711b02fc52069921cbbe982560377786eb9ea933b7d15cd0d5d01a9d65b155d0f2ce9bca27147290b46929d81512f023f8232ff71ea40666984c4488634c1fc7c796144b0cb5ee301200b83ac4c73c546880f949a9ef1c1dbbfd12c6be4df7e58f4aadc0973fcb16127fb784f7d969e636c6f4a7afbaba3c5a9af518fe99a4c335d3ddb7e7d9c43a415dec069e6cb325ca31614589286f27b091e0309fb9fef587a506cd5859c892546231ee072fc5bdc6b67a8a9371657a99630b280c7f29066e243f64b71ae06f36e93ea54c0f65a3a305874072cf9cc891b6301cbb5fc18bc7fd012ee69bcd729b078c1c4df0d6b9e305c5e43aa66ec0f9972dc17659111b5a75851b5985fbb15fa43d1bafb8ce8ae0771b3c5f9b121b9111df6c4d378c793a6d1cd457dcad402c28f3ec9dc3b3d051a6b3a8a8a9132bb079d3b752977d6cc1d2b6d4d1fccdf6c27bd3a89c682e913069abfc207e07a80d574ee5d354e868d894c88ace33497d9c6fa06ac5bb7a193605476f5847f9a4243eb82056de911d4d2126dcccb34658ade534f6dcd98aa50612ddcab236674d9baee9bff7725a52827e75e5065b8b246d98cfa99cea192ce259f264f43f7e603262a9afd30330fe3ff875d5be5c8c00e8c2a3cf88f17dabbf218bfccb493d0a311fd13a53f4691387370c1a6c19eb2879ec2a0c85190da7ca16f483ddf8b4e06b4f8aa12e56bdd1f77ebf886de24e93994b92549a6ff14d0c746f56f5bec609d4632b63fcfbce2e57a72ffe81454d32f6f083bc88ac0ecef46132f63646f4150c4746abcac0e2a6c0d587a708cfc6a3c4457d3def92d0d752cf99c8e74ea465cf8158d5b2c8ba897e395a74361a748b1bdbaf20a79a4ed391986fead34fb9536cd247e94febb442d7d8a7eb2e427d0fb98118393ddd80313cfa8dc58276b0606d23df33779572609b0fd5e4bd41852739aea844770a713e463e7cc9831d06424f73cf5b3d1a5c39e046865d20a965be4437ddf2eea6a7ddf856b87088d42ed9db868cc0134b1b9701df47e170df18d44a5aed0c7b9be7c2229869d60ca61b849ec926c11e976edb025f12496b25a8aa0c15575d05790fd0d031d489fb19af11cc59ee7dc7dac947435773b36d87c737c4cac3bcb656f4e2fbf8cefc20df95410c02ca67f30951f331d9800c3b90def6ca774d3fe928b80adad187788989ca1089275d73e9a3c8e05cf3ab7c78e86fcf7ba672689376439a470313dc33a394b31c00e7fe8c81ff1ad8e266ef93cfc95d9d63d0ee86530e247d15fb8fe42fbf1a37d0b5452e9a1dc24f79f2085d3018583c0baac828bda2cc3dbd0ee0a481caa9e417e503d41aa5128a0ca6447730042caa6f86e0c9d7dbf2d9ec6d63cbff06b9ec0fe231283bd21c554bbde4e8277eeeca1c5de7ca9cdc668022ff7fc96d07ecc7c1df8bd942e7020f37977a310bf48b0ce228da41bc5ffbbe3cf63aa606a0e9116800436a5dd4ff482f058673f3f892fff55812c2f08be5adc78e6d41466f8c579de05080758ffc327b7ba0fe167ae8d85ac5f5e14edb4ce0d027750ddfa0e91e9d1e6a20604aece46e1ccfd3b9aee11c300fc4337f1e5a24c4c48eebc96974c983cb7d45c1b1ae22b57909ffa199638a158f66c0697006f6af5e0c9da334dc6f32527234842352f924a5456ce82756b6d95d39e67cd4e8eae7b313db43210565b21930a98dd029cb9e0a506b138aa0b4f21eec871facfb81dc6b23c7ee737c0b5ae10a6e11b021fc589ee815c0686b12a46920b316a4d9461ca34d38d3356db25606e9ae00b6453252272f575954946625d90487b9198f86499e2db6cc6e83569d7ace12c8a4a9d48427717d4233c232d68cf1cc010e0b33ab8d92d566fed16a63d1baf440136c5b9da0d046989694a4c66c62893f89efd7f3bcfd312c59f3932ff51ae0bced2da87f5624d485148d0511dce6ab114384bde0cbea014740ce66ccf0a5cbdcbfc311e6e8f5fe6d85e66290af7da2d2073fe2e74e335a51a8cf8f0532ae834093139e7bbf2a5be04199dd8b27baf27f0adedd73968ef30f62c9c9dd7cd21f8f29cccf1341c4225c9022c3f259cf18fef4aaf189a55d7b8c80b98f25df8add7d4d01b6a96ed205bcb09ceee051a7c50bdea408dc364c735208243a391aaf3b331c1e88944c7f7e8e8cf875d6b31845386fb1dac0ee81f0a9c474d5c5ba1a5e2660b0b2d7a325777915ee940e841531a4f1259ca0e2feda8acc8ea59f6a788c26de051e2d16b682a8eeedca8ae975abe184fcea6847604725a8087f4d77ae2f16edaf953184ed3ec86ccd60c21649a145c402eff791605f4ea84931aeac2e912c17bf15f1e424fec280f2957af637a8f7dd14209bb1b2faa626e1091bba0bdf0367a5e985e0afb2f7ec3c392984f10c0170406a310719284cc6c3b07bec80d491ab710354540959d6569bc71d094bcd5398427a3e36dcead544bdf3a8d87dbc06afeec636ad928ab9a0f84c892a6d0779d11c9ef8c3e9447f093d406fe54fcc62c6dc99cd2e751399bc309f67b403f34ad2d6fa8fdbfc166f523502235f336298f79874d88e1daf8956e6ba1f26dd8d7daa84e38c4d3da703ebfae549999bde0d50ea3b84a44741033c35eb2e808e29543afc1613fa637eabb9d5b69611f50ffc38de1fd9952d932b684fb29d41a4635ab2a033f26459fa24c871b9e944fc33c393eb0cc7871ec3879f7de7fc959a22d552d7939f8740e8a192e242195dff253ee1aefc15d91fc5fa1a388556575628050f3d37130dff19121b3001b8932d911b027399fd34ac1bef9f231e3d6351546b48b753e4d76fe47dbab7cbb7bba8ba48049764b639e709e7158956a3b2636a2bb72fc2a4aa16e82f91ffaf9f2d3f0f8760dd4cedb1c9a01e56e5eb0d8bba40215efbc4442232a082f18db0d18a481e38721cd10f78e42c9179816479fc8d487da2a54f735148228c3f39456c31ef02e81de8277d51d9bc64b8cbf02cc2b1f950067e47ffa8a5d7d205cb868bc9dbcb9abe5fcf64b3fc7cec1e06a26f501df3bd7f1cc08ed1bf36ed47ddef94fbf8c775ba4f385f993b24b08b70c06cd7e13b58e6826359f3e8775d029a4bdd93d11879bdb7aa06752022ccf18b8a5079ccdc4840cddfc63afedc41e843eeaaf36919a710ea030a976405316d701196b452ebcddb5d8ad8c1dd10d5e86d115dd9de944b225dd420576983a65a0a5543922e3bfc850ec25c511e6ebcd5148b91a1b9e8a3b9dda295fbc223b0fcd7ea2b4e1aca6ac79545a622f86401e1cfb551279151261ba9bcea5bf15ec6423f6ebb1d02130551e5334d326921a3862e44742f08130a5342fa27b4d7d369345c83bdf949c25a7aaf279af30c4f78107796c19b566bf5995d503c95d6386e844eccd019060e43875795fbf10f40cb00a8c79da28640907ad4d9b40524bb763ea2f7ef7ed85317b6273bacc9972fc6d7c6e62431f1e00aede4ec9c11bd7fa6b7c5dec9a939e0e2300d6aa585067f2eba407b3dff62d054c749dd9d080a9de2540fa0a1e4edd24f8a9b149a8bf5870ed5c842f6be7b7cabe5d9101445d09d7521ee6294fb65e3d78deadcb1319d3d82e9fdc876be4bd0be0c904b0424c74fffa1bbac48e9ea03b5fd85850b37489b1a3a67c3419578f3dade13837683c505743bc6b5275ba9cbc9ee5a1aa221389cadec31bd88eac96249dc3eed7a3e38959b7fffd815622cbff9b9775b45ef71afc44e92eb68ec8fcaf36438feab0d794523a8382f973ebce03a0a38ff661ce6e0023d4f1edd5b70ccdd587a4eee2ca7913b7cd0074e45bdb1009b42463d63c824696bc79a1edb7fa754894f9405172071601e80ab9c2fb7df593ffa40abcb0132679a2aff78a1364b2ca9186211d8f78022d4612d5ac7420a402c70cdb3fe0a5badc760c0029d9d42747f372a688b79fd23042de10da2e789f47270f506d03b8cec36d6966f649968a584fb395a76a754e9ce3d49da792ea05057fed02ddff890d9d7987287c70f18bc488857186b21cdd7f9b674e543a00b92b1b7cfb663a5cdb8ab462ea78727fe82cc99bd8c57882059a2beaf31d60f393a763d6e363f9fd3f790d27572c8c17f94f2289972e1e22a3d45fae2c60f5b3acc8ec7722925ee365c3b28d784b662e150209d18e5cb1a7d8ff802f9e955fe596d43ad26137a41d539aa8f76f284f223781721a6dc1a8d8cc75a84fc78762bde81be016fbf126fa1799158bc71fbbeca2d6950efec6d2e9feb517c1c06fcc2c5d02ff8a5a6284c6613dbd921a6c3cce2f03e6c07a3d91c69544f09d04298a6007bc29568d156e89ec472cb132e74c08caf9e35068147692d3aae17a4bc6dacc027d5984e520cedd43a455e7a124f8a85751cf59e41076e9b7e161d72974d809b1f2030bb3cc69e2abe87b6f50c4418795856b01c61d2ea61dbcd4737a9e46065926c3b789da4c9fc9217025d710e9366ae7cf95a37e4cc98f2c890bfb388fc9bd096f2dfc8bbeb2ea875fdd43fe8ce0abd3c9f345b762d99d6dbffb8759f790b904c5a49574c392ecb1291495609abbde9e9da1bbabfbdb091faa675e478863d941d0c5792c8569a7829227c567b4cb4e9b81866e7e12ce638fffb8ec679750bd210b9bdefd1ce0366e1f1b4390a453cabfa54da7d69cdda39dde48c1b015454d4652e6389e9e6380b865d92b195c272d1ffaaf382abf8954e785d9305cef3243b32abf9730f60483b4d3c3570a4cda9f6749edbeafc12c74d4b3103cd96298346a630bca0631cf2381ef4378fcc417b36ebdcc935d8eb87fa2e9a3ba3bcff0e45b32e286663a642a2fa2508c7fbd0910ff3db23dd163dc66bfe1fd5b90076721355ce6a7d06d0db011956d65bdd1c7f30b5a4d7cd965a28d4884364e0ea9e669e177e20db9015c13c44b0265055bb444f2df2140675925fbd5a0323e3089618a637454dfbae25a073090d98605c4359fe89056ae2fb883746a8c5ef063bd585dc1cc28a8500fe31ff1717e6033b2ece03beb6a93268b3ab1997dc51bbdb3ad6be2408c87c696d6ccd64b53afd3e9e6346436ed0f41d2ff3bc10d471e28bcde141c281891cc788e052113d45dd7c9c6edc230de3202ad63c23bcf6ca4a4c711e0c348a65d2245eeec99b13459c154ecfa35ec78735812b1e7ab7a372d611c6a9b94788f3edd3f467131c1b8af4bd40c8829b4b9db57a7233a9ab28c2941765590a2fa2fabda3e0930969bbfa9802601bfb4e15202ed02e4610809f5b157c6b7576c0e3355b5767635b25910a25e23853e65fd5770240e3d8f8f5663ba1cd8c7da49101bece98e094a9df66f0430e02a05ac5203e0439a0d8eede23588398ac3898306c7f7974719a4d32cf6e9d8a76ad1ae93aad36feaaa3fc327a4c32fa223d5c9be952f99d66e2e2040492947f23e6cf99be4866e3bfb3b946d68f471b6fc671b32c728207ebde248dbecfdd179fb8a689971e9877a5a4feeae525d311dc9fdb639a3c9e5dbb7926fc5d1ef6d754f6a018978eddaf1ecdc7aca9bf08d06d352cf96deb3b9ca950417471ca7a8249dc5e10d3efb05d5bdee842a47548b355e7d93132fb409427ab4e50e678729c2fae434bb1d2ce91fcba9876e1ceaeb13cf44da6e0cd37db1200505d44e4d8e9b60bf9d930e27fafc4e6fa34c92a78f317932f93a01fc0f26cf089e8e8a9aa176660a8707ff8d0d5475807d4905e9e14900076e12a3660f493128e30290e1e08e3d8cfa27c4bffb8ce6689fff1173aeb9aa2325dcc4f528d37387beb11a373c73316921094cf33d94a24aca5987c170280233b5cc8a74a3297611168fb9151590181e666e3a8e4855327883852370b159b48a9cd5d7c36eb706e97b56c2e80a3290208ff758003efa7d960de77f2d1092f8fd6b42e020b5cf87e164761082f1bd46c9cd2086f07d88b8279197d907157bc2da6f4d958fe6e4c90c6f5ba91c5f620d00c45e03754bb80f6fb7717a1754b392911bae2454fe804e276130fff535f13eb420a34ef32751cafd2f64542c6635820e5e2b54c31a9b0d58d0c1ba86e2ec65a568bf9d786196b84ce0c20b0b35fd658a0fd8d35952e0f838a8652bb2f60723afd8c2dfb7112bbf9c41e1a23562c6c059bcc059808d7545b60b09c8ffeac360f3a8f90f98170b13e998b362bdf767ef23b192a44f51ee80f4f061a6db46e8d778f3b354078df65e160ba821c60da7ab20f6a98dafb1e80bff924e35db47b53c24d93c9a6ab44d62508b4a6aef29455a8dbeba03d9dae97079af78836690030537e84ec2cfbec3157764be7885e09cc4a1efd78daf8f48c4f408c6a6ab29629709fa47e39f04ac5595a38cb0df68ec757c9bc108c535b922bb9d29f5634c7146d1a095748a1d8a8e82cc0f70649ad8ded048c387a07749831c607d5eab1abed92191e32d4eedc47a0aa4abc2b34facf49e8f1ee74e1ae68533e2ac082fcaa5485c13a456fefe9074b3d4767018628027b19f2194337cd609efbef5adb41920cc57ff3fc98b3eef69f06bafc6413f5e3594e4eae398caea4348079fa3d612b7d09326b6fe0605fb51a7fc03f3626fbeaf75a73837b2240ddf68b584b0f4a2dabff36f4a2821c52c2c6fc5d2511b52048dd7bff8352d4a817297cae41211aae9370e7dd5509daf6387e97d55edb2c221aa75e5be270dbf09a4adfe736e86ef2c8a0ac4765c1ff7dfab9186918fed6d40af0818b2425e86731bed9eeb4d4793858e472c10e73efb44d4f3bd44e3fb3f66bf20423ce23dfd890f6db5151546d91609f3278fb592af3f6361e1fa602693548a564282f79d72b288afd8a96013102941d441dddaf6518ee2e48480781c8b35622037a2c46c4ebb4c307cc4891b70ef6ed6e8cc9b5915b903f6d35420c1ae3095a46bd8612b2d3db18d6ec384e7be6254960a681b7518b8801bc61dc1487fbb9b8da5de913c9a0cd38e48f92a94693678e7f947759fafd39589186ed4768fa8ef977bb30177d8fe22bb97b625ca5cf7a81bf9da2f10211c4f4323bd745a0fb2af558865a092796af697282b47dcd0adb755041f4259b3b64cc41959c5b0ec11a77106afe56ca576292559ef2553fb226edf62619f41669d24e14ff6ae4b64564231babf2ac04546da1949d63af729d4666e310f600e6a1f3f77ff93acf6f54b342851fa33fdde0f4aa1510c937d66ba38d6a2db68d6d45c24c969bea89b9ce30b90937e217ba3ac4a6b41fd9f695fc73952d0d9c8c5f13d667ae7d9b7ccb20a310998d9f1554e600d25ff2827e836e064faa03d05a6660d11f87fce73156d52f9bedade6111627247c5d606b0c60b442a617fc527b4b3e0033426805d34537708c2cd5b5aa9743df54fcd0fae853b792796de84c98cc24d0a56f45349097602f2605467b167314fffc81f7867f53437ad49ca9a4177b256f090869595827b7c475b55725082f01760a4cbf5d4faa58920810028a0bc819fc37bf1bcad2f3d61c76c75ccca8613bfcb427b3c2ff712c2afa008ac57a01e29464c05be37fe12010139bcd0df588a8aa78b55ebd344874ea82d7b09635e216bacb1676bf29fcb8f8fda7d2ee081002d3f7ecabacb7f46f3713a727dd2a36347078e4f08b026c68b885673b1956dacd8aa56c83c71a31090f7dcfc432204ca7bf186c3111fcaf2ef7285ce8bb494d396306caf48943758085c91d5458f63af8408585c485f146694d937f780ef07293f1380e9c442a42d091425c8e2d1a50f52558da1f605c619041524f02038675292627662d21b9594dbef96eb9795a4f383ece24c602f028c81a9e9c09715a1fd9d8ddbac8e5f558f2b856ec0df95524ec8fd5651f35f309566362dde78e8239635dff91afbaf41be7023b6b30f2556b14cbd0d5b4f2260c0ee91bcd13d4628f75d057d529cf72be7e5b2664fcfed21c3a9e33e7a0b4f79558b29631400a81f726ed75d71280c84aef34a4d4924a94a34a8c512311f5abe4841aeb8b59dd6742aae60879592497506bff1f17a8a8591249122a405d5140ccf8a31ec8c76eb811d2aa386508a080d06528c40e383396146e0eb149018a5bcf2b7f32aa74282481d9ba81660a1459e12dc7c1697bae68774162e807a20e75f57454753ade1b1185a2846aa58d72a8c220e1c36d8595f154127a1b7d87f3798fe0d33b0fc14e062691c74c4e1c5295e29f0b8e85a08c3b11f7fc21ad08bcfd960d9a2b3bd67c137c790911090af03db9f0f840b38bbcb2c19bd2e37540f5811237a2471990ec51adf557927791f6e7f18d670000843b4c84fe18fd102c791fbde4d1a4599a4a84de8b1b6b4d13016a338932538e510b3b73432ab9dd9bb14a2ea7f9949907b54ff9677d31086f961ec7a6461eaac0a943a7c74248727359a587130be339bec784dd1b4ccc09687e902750fa438c495ed83801e84e1cc15003c3b9280a4de09f50bd7d270a4ab984dee935f831996844482e0c5368f2beb6d118dcfb8352c5a4b7255e32dd38b8cc478fdf1a21f66f967875667e1aa36346d54d3a9fa5f3ddf5207bc9ca0de5dfefd1ac403987b550113a802a6fd206cdaf27e0704ae01b73ba777fc836cfcfe115d1b26e71e9781773976d239a55d8877896e85a1ab282986d68ecc3f9e7703d2f11c474456e7e6cf1c6333524429c115c3cbe71883a37547b24a1c6802c3e9e90981de70a87c6d77953997131a74f55d177d434d37fca7a8b04e308c411f2ef5ac8d584875b3d3a92d1d0a4addb48b3a324511acbb9b2da12fc40cfcc49da59a6e46c789132f0c19c27799b56e1da0c88f28b62aae8f85326d67922e7ae7a66aa7b29edd6f15d5194fc4a7d90bd3fb8e1b48d0e36175e87f4e3ba8a14f5d90e9d20518ea0ae5cb7b51b90ac477a622203bd6f681320fa8cb2e72fad423eeff7d922462ca892f4491ada033e3bec93c2da2d6a23371670b3852b1f98f4635fd94e35cf3961e5750ad48a06c6fb803b567b73435e5043ee33d4c3efbe1733bc98b4cc87f310d765b1232324629d50b5a3a57f6858f71d06696ff9b302aa660de3b4c1d05e971ecb71ae05599cde05298891101ac80f361338ec6de2c769c147fee75b58c749f9619848dfcd47d05936ade65391219b2da3e23d199c9bd02c41fec32b6d04a5bf979064c47c5a859de864616fd6e5ae40b31a231c1f15b8764b143bf72c50ab891a7e3b914873d125a7459cca652b8d5c7bf61b795fb6fa99ebfa81700541a22b518f3056eefc0fcc4fa7f60ad9220574b2b20e0eb41575116a9562c0541eee220aa3f267352ce1d6a790c8146511df1d50e54bba1dcf2db59eb9779df84f9c0cd6e84d35ed9f94ec41bec3591a223a5f9098d2e02157c8dfdc117e9b632479df6835c01ba0cbab75c1479d9c6d137df1eba3d04312d8967b50495734a973f86d84320025b37db72a3423b1c1f36f792ec6c0fb977fb9a165696e0f6f219c6c98c25684ca575fe71a423e5629265dbb832deb315c3aa9ec2c04d0d03191865537df90d2d1aee2a3a9b0d4ed622d31d938fdbf2af39e22761b1ffe945e24dcdf8c8a0b983d4faa8d3f41446e83ebd5bc3c9cb0f767ad4e2a90fab706c324230be74a05e1ac435e1557632ae9d80326e4253a5d0023fdec97be4c0958bc59d31c6ba2f48a14d86482da121f82e4421a54ce323d144f150c753e0c4622f8316d98c833c381d2986a328489c5b01e4e9f0c00f68769a8f275252ecc2477fbd6dfa12e12b441a72a46841a346fa0d9d5451ebc934203a5f224c73837982add0c794da4f750aafb95b6c5440e1e86023d0a2d5ba37abd6e60609e503122958daee3d7a9a5e0e6452147fa043886598ce738d2841ddce4d9fbada2d0ef4ae9ae85e0487fb449b8e588920d6c01e79fbd087af811efec23b751405c6fc757fdb4efb74d4f072051ba6133f372ec422f5c4a927b838b61e7e39aff85e2ec92fc7ec6ff8f8c376b77bceb54ed35533d916fa45c175341634eee61812f0a62529761a8e8033901b2ec7066c876fbba3ee94ecfeaec79b4dc34b856d0c72bb7d23fee183172cf66dbb6e95b54861d075ca2ed4d0372fcd5ad31cd1f74f3cfc2ede2c0eff1a3b172a57b6dc09d237c4013f3005c9024863e3188152550334033566f7a159f01e6a6c1f2dbac9a738131f9d4db082c226382f332766b296eb850e4211f69fa45ac716f446284262e8f38438d139ad8b6e08911a2c02963e41a2ceacf31a6c90205485ba4bff2ac2282262a3a20d307976cd52e5f3962d233c28b0ce79bbe16a9cbe9ef9f03c3239cd65ba04aa03a3c264e394f364c7ae3f56f212dc2ce7a7a8f3d3fcc2f5a55a3242a1edd459e2bbe2f42424726de9780a08ab3e413c70baee54629ed76bd1afd92bc82cc2794840caeadda6def33247bc7351ade972eb1e42b9a725ee2874ad57c9d304531b495b340ab668e1186c63d4d0e215f7041f9212091040048422e8cda7a080e65ba82ea62972ebcd16194a4a05e6c3e718437014ee7729a4f621bcb76bc65fa48b8789759832894d077c9210280c59889fccac94729fcfe16eb5388bc98157d09caa97b0d92ecc02949ed489c9d75e3ca83912fa14c258243bbe32cad04dc388261f3f72b1e98c074ce42a8c9ac019fdf8df52d785e931dae09bb49513583db298ebca55015508d13fb938cc87b064b8dc48571364755aee421d68e6cfe29ef364f035e8bd6849dadfd27985c3912a7b2bda04d8f625e30ef8db1e52ea54310ad9d4255029406acae89c047d38fb32bf98e68b7b04e725c9d3277d7e09a9f56a47686bcdb928c6b0d3e1d103bc82a7aa52ac32a261c342a7c47947bb0c664a8c6a1b91409f8fe11e9664bf51bdef00bf599a6037688c226e4dbb8083189cc3875a10259a1f785336a9e4ac92ab820a350fb7739cfb7612cb38f374781b9e6c8a5e57b9eea2444fb4496d2ea963a4e09406ef56f28addd80da003de7f20c11ef7f4f856261ea5ae8b3c1efe4b5eb03f11fc3e1c44f4f85afc8de34fe3cec071421710efb35cb05ed1d48758a6b3ef7f933379249f20e381903611e38de3d2956c1d462323dc574670a37e73ae096a3367649eb7f7ac6d0492aa16954d0b6027b324bcec7226ae2fca82655131cfdd2312e397311482137d437d6c28b85029ea710f9a0cb3fbe9c1fe97d15fb213bea19b56d1c29145c31a987fa7904419849363a4cb8006aeb19af1d7b8fefaf9ddb769e742b3b567eeddab1b55c87afd5fe3c284bd6dd8722d7ebb56d6d95a07403353937c368eedb81b2559e318d7f6a436c70f6e7d36951fc50abdf61e1954a8f5cbe960ff4143a6c2f8c96b23a599cd40bba2d4b97fbe7873c8d87ece47efd30fd9ecb06a573e0d2588dbe33fdb0765d20c5b6ba51bd0f12b607e2c02d073fc2b19937ab492c3077cc390b6277a4fe1e1fbc9cd5207dcf43e2176d84da18a5b98649e3c64f3601598096ef5a6da1431873ded826f923221bd0249f83be490fbc8c1f756050cbcbd38c2e5af21bb12acc9c6a72ab384168fa7d531c832d75b272c0aaac136f2b04429847dfa640b6a624bdbb9fe96e3458c3ae26da3031e5b01e3fe7ee04a9c216f55b0e96898099e041d0c9720939e0f97b42d1d903cd8d3483b4dacc4b96838a79a3515a9da0ce2dbbcbad43b8ed9000fd144f623189d7c62d1876d6b323ea8503e02002533640ddc36e53cef4066efd531b56ae5dfaf3ed67b9658f51952428bc2c2b2468a6d195ebe3a290dc4630fa819977bb0e6b66611fbb8ebf50d6e14872678594474a804ccfdabf2797d2b23575e62b49a787db2519a6d983ff63166fe4868eec7b98553b16ff030c357b5d55cb5ef62eaad9f6070a9ecb414ac6f661bc413559da74c5492d757320df11da45244649baa5551e25a1970b2c424bdef07378839ad4b7d73508a3a2d6990b9a52830ce7b8ebfd9da14cb351ec92fadebe3d6c23cb06836638efed2684ac5f70a4972ce8e05abf64c723a02783e55fadfb0af5c3a69a339014cf999bed70e4a1b548d25d4a60a45cead0e5b4c232a7c93dac3a836a888e37919fcbad49c6758605fcd88696a42491e4c7c4f5152b64dee095fdac2dd3585c172d93091e62cd6734dd6c0b5844c28ffd39cd3e681dfbbf3cf4f52a7af78581c92850ac25164a0eb28a70e7a3b59d31773a26078f5b52df3e36b6fd0dd8c40a6553d544e100ea1c5261ab7cf3de5e41cbcc9dc2d3c025837cb5f9af0fe795ba393c632c9cc3360945096b0119290a93e52a5541c53f3615f1b410f3cff69d57526c3b332d9f7648e70f401465dcb9f2746558745b7870df61d063f174cfd68058556c2557fd358fbc9f4100b5a651cca56b624445528045e3644b6ee9ae6beb55f50c66a1e0ecabb4ade3d4a3bede5792b791ee38bfeb5998baeece825422fb0c853fed278efbb0af929ae1cfcaaee8e794d41b65b3ea36cfcd103c2b79c5678ba7c571b3fb676b0de23e83b56360392a7b83616db26a026269b03e44442a2f6c967baee8bf0661ff1801b61fce727273da9db46fd1ed44572157d1cd45bf5e62de8ac3efe1fc6c530da68051d32dfe9a1981faf522033f3dbd2571d53900d5882fd6c67228d5983018cc67f5f75dd56993af2345f3803bcf0b15fb237358d01458f982f85f35b5db6ba97c4a7c72f7a985f696768efec23669bbe97a42feb2b30b2f769a967bf19cdc568fe82e65d5874719daf1e39b12c78b15c0af2e45a4c3089e0e2c43304c2089bb3a5aea6625a19c6f8b1ab1c0b2b92d917b0e079270a8ef68fab32fba4abd976471697beb415475e1bb34fdf6af80d675637a667a652cf2bbca04caa3f6d02757717abce57b06d24c523a9e008c1dbb46d56c5914060b77cf5cc0f6c39a57d152faca3cb4324066fe4376e562b85ff42e0edc4315b4b21f3c3bc73e5a16c7b249185a6d3eb2517e6e9cf7b5c8a7763af2ef78df7075aa06762035a3a97c95e8dfdbc34b5a2b04d7afa02fa09b5bb70afba7d96ff59385626f6d6faf521d1c1d86540ef90348a602e7882cce5640a642d15b90036337df96060bd7ecee78282d84a9f05bad8066f05be9afbd7b60a6cb8e626bb4505820d5c07fa29d2b184dd4b933830562e52926c492105c8da7e3c5c69b56958cf3d816376318fb90bb62b9cc6f5eb925b1eb763faa89e99171cfb2cb2b0c47f845364d16059773c297505fe533d2ae0a2020463b59bbb0ec20deee15a9dfe2103575e7695cab08bb1b010c044d04ae9286576ebbb9df4d109638e6f49a13339294e1d49764b77f8b3d92443444a8de93879fecdf145ab21bfdc3ea5bdd03ff1085ba5f33113e8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>10 外部存储器</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/10%20%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>10 外部存储器</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114150452483.png" alt="image-20211114150452483"></p>
<span id="more"></span>
<p>外存不在计算机系统的内部，不在冯诺依曼架构中</p>
<p>用于存储<strong>不常用，数据量大</strong>的数据，外存是<strong>非易失的</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114150620522.png" alt="image-20211114150620522"></p>
<h2 id="磁盘存储器">磁盘存储器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114150958798.png" alt="image-20211114150958798"></p>
<p><strong>玻璃</strong>基材更具优势</p>
<p>其中，<strong>能够支持磁头有较低的飞行高度</strong>。飞行高度是指磁头离盘片的高度，飞行高度越低，能分辨的范围就越小，那么磁盘上就能把更小的范围作为一个单元，这样存储的信息就能更多</p>
<p><strong>飞行高度取决于基材的性质</strong>，飞行高度越低，就要求基材越平整（否则就可能撞到），同时要求基材受外界环境因素如气温的影响要小，如温度变化时形变小</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114151806520.png" alt="image-20211114151806520"></p>
<p><strong>基材的圆片是软的那么就是软盘，硬的就是硬盘</strong></p>
<p>软盘的存储数据量为<strong>1.44MB</strong>，常用的就是容量为1.44MB的<strong>3.5英寸</strong>软盘，之后由于U盘的出现，软盘的应用逐渐衰落直至淘汰</p>
<p>硬盘可以多个盘片叠在一起，增大容量，而软盘只有一层；硬盘更加稳定，软盘很容易坏</p>
<h3 id="结构">结构</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114152631105.png" alt="image-20211114152631105"></p>
<p>蓝色的是中间的轴，红色的是盘片，盘片的两个面都可以用来存储信息，绿色的是读写头，可以移动读写头的位置来读取/写入想要的信息</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114153453098.png" alt="image-20211114153453098"></p>
<p>每一个面都需要一个读写磁头，所有的磁头都是固定在一起，同时移动的，所处位置相同。盘片是和轴固定在一起的，一起旋转，转速相同。</p>
<p><strong>磁头只能在一条直线上来回移动，盘片在旋转移动</strong>。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114153905447.png" alt="image-20211114153905447"></p>
<p><strong>温彻斯特磁头</strong>：盘片静止时，停留在盘片上，盘片选择时，空气压力使得磁头上升，从而达到一个比较小飞行高度</p>
<h3 id="读写机制">读写机制</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114154240752.png" alt="image-20211114154240752"></p>
<p>读写时静止是指读写单个位置的信息时，磁头当然是不动的，但在广义的读写上，磁头当然是要移动的</p>
<p>现在的硬盘用两个磁头（双磁头）<strong>分别来进行读和写</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114154723264.png" alt="image-20211114154723264"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114154824299.png" alt="image-20211114154824299"></p>
<p>早期单磁头的使用的仅仅是上面的写磁头，也即利用感应磁场来进行写入，感应电流来读取（但显然感应电流的产生需要变化的磁场，同时电流不够稳定，因此利用感应电流来读取信息<strong>效率不好</strong>）<em>（应该是根据感应电流的方向来判断信息，如果没有产生感应电流，那么信息和之前的一样）</em></p>
<p>后来新加入的读取磁头利用的是一个<strong>磁阻敏感器</strong>，根据<strong>磁场的方向</strong>不同，敏感器的<strong>电阻会改变</strong>，通过检测敏感器的电压变化即可实现读取信息，<strong>效率更高</strong>，<strong>因此硬盘的读取速度一般比写入速度快</strong>。同时使用这种方式，对介质的大小要求也会更低*（如果是感应电流，那么介质面积不能太小，否则可能产生不了感应电流）*，<strong>因此存储密度也可以更高</strong></p>
<h3 id="数据组织">数据组织</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114155912307.png" alt="image-20211114155912307"></p>
<p>数据以扇区的形式来传输信息，默认一个扇区是512B（即使面积大小不同的扇区容量也都一样为512B）</p>
<p>磁道<strong>从外往里面编号</strong>，最外面是0，里面是N</p>
<p>磁头不读取信息时会<strong>停留在最外侧，也即磁道0</strong></p>
<h4 id="扇区划分——恒定角速度（CAV）">扇区划分——恒定角速度（CAV）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114160253407.png" alt="image-20211114160253407"></p>
<h4 id="扇区划分——多带式记录-多重区域记录">扇区划分——多带式记录/多重区域记录</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114160721871.png" alt="image-20211114160721871"></p>
<p>外层的扇区数目<strong>多于内层</strong>，而扇区的<strong>容量是一样的，同时为了保证数据传输的稳定性</strong>（即读写不同区域的速度应当一样）因此外层扇区对应的<strong>圆心角会更小，所以在读取外层数据时，盘的转速要小</strong>，而内层扇区对应的<strong>圆心角会更大，因此读取内层数据盘的转速要更大</strong>。这样需要更加精细的调控，所以<strong>电路更加复杂</strong></p>
<p><strong>注意</strong>：上图中的<strong>一个同心圆不是一个磁道，而是一组磁道，里面包含了多个磁道</strong> <em>（因为往外一个磁道，周长的增加是很小的，可能不够在多放进去一个扇区，所以这个磁道应当保持和里面一层磁道相同的扇区划分，<strong>就像恒定角速度划分一样</strong>，即多个相邻磁道是采用恒定角速度的）</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114161833891.png" alt="image-20211114161833891"></p>
<h3 id="格式化">格式化</h3>
<p>如何将磁盘按上面说的数据组织方式来组织呢？并不是在加工时就划分好，<strong>而是后期来处理的</strong>，这个过程就是<strong>格式化</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114162349970.png" alt="image-20211114162349970"></p>
<p><strong>同步字节是用来告诉磁头接下来就是一个新的扇区了</strong>，就可以读取后面的内容来判断如扇号等信息了</p>
<p><strong>间隙的留出是让磁头去处理判定读到的信息如扇号是不是想要的那个</strong>（因为盘是不停地在转的，而判断需要时间，如果没有间隙，数据和扇号紧挨着，那么当判定完时，数据已经转过一部分了。如果判断的时间是固定的，那么就可以用一个固定长度的间隙让其反应）。<strong>转速越快，那么间隙就要越大</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>仅消除数据是<strong>高级格式化</strong></p>
</li>
<li class="lvl-2">
<p>建立磁道，建立扇区是<strong>低级格式化</strong>，完全清除数据，对整个硬盘做格式化，不能区分C/D盘等，同时低级格式化是对硬盘有损伤的</p>
</li>
</ul>
<blockquote>
<p>现在的新标准是是指将8个扇区（每扇区512Byte）重新定义为一个“4K扇区”格式，共用1个ID，这样可以提高效率，一次读取数据只要读取更少的扇区即可</p>
<p>新标准的&quot;4K扇区&quot;硬盘，为了保证与之前512B的兼容性，会将扇区模拟成512B，这才会有4K扇区和4K簇不对齐的情况发生</p>
</blockquote>
<h3 id="I-O访问时间">I/O访问时间</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114165106721.png" alt="image-20211114165106721"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114170106854.png" alt="image-20211114170106854"></p>
<p>访问多个相邻磁道</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>旋转延迟都要考虑</strong></p>
</li>
<li class="lvl-2">
<p>寻道时间通常指考虑<strong>第一个磁道的寻道时间</strong>，<strong>因为后续磁道很近，寻道时间非常短</strong>，但在明确指出跨越每个磁道的寻道时间时仍要考虑</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114170520159.png" alt="image-20211114170520159"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114170530312.png" alt="image-20211114170530312"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114170751906.png" alt="image-20211114170751906"></p>
<p>这里随机存取，<strong>平均寻道时间是要算入的，因为不是相邻的磁道</strong></p>
<p>显然顺序组织的方式速度更快</p>
<p>计算机中的<strong>磁盘整理</strong>就是把分散的文件信息放到连续的一起，因此一定的磁盘整理是有必要的，但不能过于频繁，因为在这个过程中会对磁盘有大量的读写，会对磁盘有损伤</p>
<h3 id="磁头寻道-磁盘调度">磁头寻道/磁盘调度</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114171146332.png" alt="image-20211114171146332"></p>
<h4 id="先来先服务（FCFS）">先来先服务（FCFS）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114171424559.png" alt="image-20211114171424559"></p>
<h4 id="最短寻道时间优先（SSTF）">最短寻道时间优先（SSTF）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114171545685.png" alt="image-20211114171545685"></p>
<p>饥饿现象是指最边上的会很难被访问到，要一直等待</p>
<h4 id="扫描-电梯（SCAN）">扫描/电梯（SCAN）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114171845112.png" alt="image-20211114171845112"></p>
<p>先以一个方向到头，再返回，循环往复，对于不同位置的磁道响应频率不同，靠近两端的会在一次响应后很快又得到一次响应，而明明刚刚已经处理过了，这时再次响应会有所浪费，而再下一次想要响应间隔时间又会很长，<strong>也即两次响应的间隔不均匀（中间的磁道是均匀的）</strong></p>
<h4 id="循环扫描（C-SCAN）">循环扫描（C-SCAN）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114172946698.png" alt="image-20211114172946698"></p>
<h4 id="LOOK">LOOK</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114174202886.png" alt="image-20211114174202886"></p>
<p>对SCAN的升级，但也有代价：如果调转方向后，又产生了原来方向上的任务，这时候就会导致这个新任务需要较长时间才能被响应</p>
<h4 id="C-LOOK">C-LOOK</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211114174703606.png" alt="image-20211114174703606"></p>
<h2 id="光存储器">光存储器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115194524279.png" alt="image-20211115194524279"></p>
<h3 id="CD和CD-ROM">CD和CD-ROM</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115194950266.png" alt="image-20211115194950266"></p>
<p><strong>CD和CD-ROM都是只读的</strong>，只是CD-ROM具有耐用和纠错的功能，因此加了给ROM后缀</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115195527048.png" alt="image-20211115195527048"></p>
<p><strong>保护高反射材料的丙烯酸树脂保护层是不透明的</strong>，而<strong>聚碳酸酯塑料是透明的</strong>，因此上图中，下面是反光的那一层，上面是可以用来印制图案的，即标签</p>
<p><em>光盘需要光驱来读取，事实上磁盘也是需要特定的驱动器来读取的，但随着磁盘容量增大，对环境的要求增大，因此磁盘驱动器是和磁盘<strong>绑定</strong>在一起了，但光盘的容量小，且比较廉价，<strong>因此和光驱还是分开的</strong></em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115195913347.png" alt="image-20211115195913347"></p>
<p>用<strong>低强度激光</strong>来读取</p>
<p>光盘中是以<strong>一根单螺旋线来存储信息的</strong>，而不是和磁盘那样分磁道，因此，光盘上<strong>所有扇区长度一样长</strong>，就像是把一根直线弯曲成一圈圈圆</p>
<p>同样为了保证读取速度的恒定，光驱应当以<strong>恒定的线速度读出，所以盘片要变速选旋转</strong></p>
<p>光盘的一个扇区分为4个部分（如图以CD-ROM为例）：<strong>同步区，ID区，数据区，纠错区</strong>（CD-ROM有纠错功能）</p>
<p><strong>CD-ROM的容量大约为650MB</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115200512391.png" alt="image-20211115200512391"></p>
<h3 id="CD-R和CD-RW">CD-R和CD-RW</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115200621591.png" alt="image-20211115200621591"></p>
<p><strong>CD-R（可刻录）只能写一次，CD-RW（可重写）可以写多次</strong>。使用<strong>高强度激光</strong>来改变</p>
<h3 id="DVD（DVD-R-DVD-RW）">DVD（DVD-R/DVD-RW）</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115201029656.png" alt="image-20211115201029656"></p>
<p><strong>DVD的容量更大，因此DVD的激光束会比较细，波长更短</strong>，这也是为什么DVD的光驱可以读CD的，但反过来CD的光驱不能读DVD</p>
<p><strong>DVD采用两层结构（一个半反射层，一个全反射层），注意不是两面，而是在一面中有两层</strong>，通过调整激光束可以读取不同层的信息</p>
<p><strong>DVD-ROM是用两面都可以用于记录</strong></p>
<h3 id="高清晰光盘">高清晰光盘</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115201702715.png" alt="image-20211115201702715"></p>
<h2 id="磁带">磁带</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115201852159.png" alt="image-20211115201852159"></p>
<p><strong>串行记录（蛇形记录）方式</strong>，如上图，是左右的蛇形方式，先在磁道0上从左读写到右，再从磁道1上从右到左读写。</p>
<p>上图下面的一张是指在局部上会有并行，但整体主要是串行方式，比如有12个磁道，从左到右先<strong>同时</strong>读取0-3这4个磁道，再从右到左读写4-7这4个磁道</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115202726138.png" alt="image-20211115202726138"></p>
<h2 id="U盘和固态硬盘">U盘和固态硬盘</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115203225240.png" alt="image-20211115203225240"></p>
<p><strong>内存和外存的界限在变得模糊</strong></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211115203708592.png" alt="image-20211115203708592"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>11 冗余磁盘阵列（RAID）</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/11%20%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%EF%BC%88RAID%EF%BC%89/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>11 冗余磁盘阵列（RAID）</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124201947610.png" alt="image-20211124201947610"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124202340250.png" alt="image-20211124202340250"></p>
<p>目的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>增加容量</p>
</li>
<li class="lvl-2">
<p>数据分散在多个磁盘上，并行提高数据传输速率</p>
</li>
<li class="lvl-2">
<p>纠错</p>
</li>
</ul>
<p><strong>逻辑上是一个磁盘，物理上是多个的</strong>，同时<strong>数据是分布在多个物理磁盘</strong>上的，这样才能多个磁盘并行工作来提高效率</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124202714276.png" alt="image-20211124202714276"></p>
<h2 id="条带化">条带化</h2>
<h3 id="RAID-0">RAID 0</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124202853383.png" alt="image-20211124202853383"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124203104344.png" alt="image-20211124203104344"></p>
<p><strong>条带化即把一个磁盘/一个组（如后面的10，01，50）分散成多个条带放到不同的磁盘上</strong></p>
<p><strong>优点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>大I/O数据传输速率快</strong>，每个物理硬盘都可以传输，所以对于<strong>大</strong>的数据块，可以被拆分成多个部分来传输</p>
</li>
<li class="lvl-2">
<p><strong>小I/O响应速度快</strong>，如果是一个硬盘，那么一次只能响应一个请求，而对于多个分布在不同物理磁盘上<strong>小</strong>的数据块，RAID 0则可以同时响应</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据可用性低</strong>，多个磁盘，出现错误的概率大</p>
</li>
<li class="lvl-2">
<p><strong>没有冗余检验</strong></p>
</li>
</ul>
<h2 id="镜像">镜像</h2>
<h3 id="RAID-1">RAID 1</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124203828637.png" alt="image-20211124203828637"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124204604960.png" alt="image-20211124204604960"></p>
<p>深色的是冗余盘，简单地把原来的数据进行了拷贝</p>
<p><strong>优点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据可用性很高</strong>，如果一个盘坏了，还能找到一个一模一样的盘</p>
</li>
<li class="lvl-2">
<p><strong>大I/O传输读比单盘快，而写的速度与单盘差不多</strong>，因为同时要写两个盘，受限于速度慢的磁盘</p>
</li>
<li class="lvl-2">
<p><strong>小I/O响应速度比单盘快一倍</strong>，即使两个请求位于同一个盘上，也能同时响应，因为有备份，而RAID0则只能在位于不同盘时同时响应</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>价格昂贵</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124205124993.png" alt="image-20211124205124993"></p>
<p><strong>只用于关键数据，重要数据的保存</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124205533673.png" alt="image-20211124205533673"></p>
<p>RAID 01是先进行条带化，再备份分组，如果disk0坏了，那么整个组都不能用了，即disk2和disk1不能联动</p>
<p>RAID 10是先进行备份分组，再进行条带化，这样一组中坏了一个也不要紧，比如disk0坏了，还可以，disk1和disk2联动</p>
<p><strong>所以RAID 10的容错率更高</strong></p>
<h1>？</h1>
<h2 id="并行存取——解决单次大I-O传输">并行存取——解决单次大I/O传输</h2>
<h3 id="RAID-2">RAID 2</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124210109478.png" alt="image-20211124210109478"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不论是大的还是小的I/O请求，要求<strong>所有磁盘都参与</strong>请求的执行。</p>
</li>
<li class="lvl-2">
<p>每个磁盘的轴<strong>同步旋转，磁头始终处于同一位置</strong></p>
</li>
<li class="lvl-2">
<p><strong>数据条带很小如一个字节或字</strong>，这样才能让所有磁盘都调动起来，注意这里条带同样是满了才到下一个条带，而不是一个条带用一点，另一个条带用一点，因此要让条带很容易的被装满</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124210453301.png" alt="image-20211124210453301"></p>
<p><strong>冗余盘用来存储校验码——海明码</strong>，</p>
<p>4个bit需要3个bit的校验位（8个需要4个），所以4个硬盘需要3个硬盘来校验，并且<strong>校验码就存放在数据对应的位置</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124211014816.png" alt="image-20211124211014816"></p>
<p>对于经常出错的情况意义很大，而磁盘事实上本身就有CRC，所以出错概率是很小的，所以RAID 2在这种情况下意义不大。</p>
<p><strong>事实上，RAID 2已经被弃用了</strong></p>
<h3 id="RAID-3">RAID 3</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124211227554.png" alt="image-20211124211227554"></p>
<p>RAID 中讲冗余，<strong>是为了防止磁盘坏了</strong>，而不是为了防止磁盘出错，关于出错是在纠错中强调的。</p>
<p>出错是可以正常读，错误的位混在数据中，而磁盘坏了这一位就丢失了，不可读了，所以这个是<strong>可以定位错误的</strong>，<strong>因此也可以重构（修复）磁盘坏了的数据</strong>。</p>
<p>如上是偶检验修复损坏的b<sub>0</sub>，奇校验需要多异或一个1，<strong>原理是两边同时异或一个数字，等式不变，所以在校验码计算式子的两边同时异或b<sub>0</sub>和p(b)即可</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124211948352.png" alt="image-20211124211948352"></p>
<p>这样的并行存取就是为了大的I/O处理的速度更快，保证任何一次都有所有的磁盘参与进来</p>
<p>但面对多个I/O请求时，由于对于每个I/O请求，所有硬盘都要参与，所以面对多个时，<strong>一次只能响应一个请求</strong></p>
<h2 id="独立存取（实际上即RAID-0加上了校验码）">独立存取（实际上即RAID 0加上了校验码）</h2>
<h3 id="RAID-4">RAID 4</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124212431965.png" alt="image-20211124212431965"></p>
<p>采用较大的数据条带，各个磁盘的操作是独立的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124212959982.png" alt="image-20211124212959982"></p>
<p>每次写时，不但要修改数据，还要修改校验位，对于小的I/O写请求，会产生写损失，而在RAID 3中则没有影响，因为条带小，每次都一定要修改校验位，并且直接用写入的数据修改即可，无需取出原有数据。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>此外经过异或计算，可以发现如上公式，因此如果仅修改<strong>很小的数据如1位</strong>，<strong>修改校验位</strong>，<strong>只需要从原来的数据中取出P(B)和B<sub>i</sub>（要被修改的数据的原来数据）即可（<em>原理和之前的RAID 3一样，p(b）异或b<sub>i</sub>=剩下所有数据的异或</em>），B‘是指经过修改的数据</strong></p>
</li>
<li class="lvl-2">
<p>而如果是<strong>整个数据都要修改掉</strong>，则原来的数据已经不重要了，直接用新的数据生成校验码即可</p>
</li>
<li class="lvl-2">
<p>因此综上，<strong>在修改大的I/O时，写损失少，而修改小的I/O时，要从原来数据中再读出来后再修改</strong>，这个读的过程造成很多损失</p>
</li>
</ul>
<p>只要涉及写操作，一定要涉及校验盘，所有没法做到各个盘的写是独立的，<strong>校验盘会成为瓶颈</strong></p>
<p><strong>RAID 4同样被弃用</strong>，它在设计上有缺陷，即上面所述，在读取操作和一次写操作时都没什么问题，但小I/O存取有瓶颈</p>
<h3 id="RAID-5">RAID 5</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124214232259.png" alt="image-20211124214232259"></p>
<p>把校验盘拆散到各个磁盘上，即分布式，<strong>这样不会因为校验盘一个盘产生瓶颈</strong></p>
<p>RAID 5 <strong>只能坏一块盘</strong>，和前面的一样，在坏一块时可以用其他的来恢复，但坏更多盘时则不能恢复</p>
<p><em><em>当一块数据被修改时，与它同一行、与它的校验块同一个磁盘（列）的数据都不能进行修改、这个不能修改的磁盘上有的所有的校验块对应的那一行也都不能修改</em>（因为一行中块的修改的修改必须要修改校验块）</em>**</p>
<p>因此，一个块的修改仍然会约束很多的块，没有那么的独立</p>
<p><strong>两读两写</strong>是指读数据和读校验用于计算新的校验，两写是指写数据和写校验位。</p>
<p>最好的情况就是同时读出两个，同时再写回去，最坏的自然就是两读和两写分开来</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124215744728.png" alt="image-20211124215744728"></p>
<p>RAID 50的<strong>性能更高，且能坏的盘更多</strong>，只要不是一组内坏多个都能运行(即可以不同组分别坏)，但<strong>容量利用率更低，冗余所需空间更多</strong>（因为每一组都生成了校验码）</p>
<h3 id="RAID-6">RAID 6</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124215940852.png" alt="image-20211124215940852"></p>
<p>使用了两个校验码，允许坏两个磁盘，但不能坏三个</p>
<p>但每次写都要影响两个校验码</p>
<h2 id="RAID比较">RAID比较</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124220232811.png" alt="image-20211124220232811"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124220339171.png" alt="image-20211124220339171"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211124220441586.png" alt="image-20211124220441586"></p>
<p><strong>RAID 0 和 RAID 3适用于高吞吐量的应用</strong></p>
<p><strong>RAID 1适合要求高可用性的应用</strong></p>
<p><strong>RAID 5是用途最多的，如数据库服务器，各种网络服务器等</strong></p>
<p><strong>RAID 6 适合丢失数据严重的应用</strong></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>12 虚拟存储器</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/12%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>12.虚拟存储器</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129172949605.png" alt="image-20211129172949605"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129173241691.png" alt="image-20211129173241691"></p>
<p><strong>系统软件并不是操作系统</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129173659417.png" alt="image-20211129173659417"></p>
<p>实用程序一般是指程序的创建，文件管理等</p>
<p>当然操作系统本身也是一个程序，自身还是需要占用资源的，同时又在分配计算机的资源</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129175001089.png" alt="image-20211129175001089"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129175239499.png" alt="image-20211129175239499"></p>
<p>通过仅将当前需要的页调用主存，其他的页暂时放在外存上，可以让主存中尽可能多的包含更多的任务，提高CPU的利用率</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129175319015.png" alt="image-20211129175319015"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129183712793.png" alt="image-20211129183712793"></p>
<p>分区方式：（系统区占用的大小在不同分区方式中都是一样的，不同分区方式是针对用户分区的）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>简单固定分区：<strong>把用户区划分成长度不等的固定长度的区域，给任务分配一个</strong>可用</strong>且可以<strong>容纳它</strong>的<strong>最小</strong>分区。<strong>注意一个分区只能放一个任务，不能多个任务一起放在一个分区，因此会非常浪费内存</strong></p>
</li>
<li class="lvl-2">
<p>**可变长分区：**根据任务需要的大小来分配内存，提高主存利用率，但时间长了之后，<strong>碎片会变多，这些碎片很难被利用</strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129184112800.png" alt="image-20211129184112800"></p>
<p><strong>利用页可以使得一个任务的不同页不需要用连续的页框来存储</strong>，注意这里是把一个任务的<strong>所有部分都分成页装进来</strong>（还不是下面的请求分页的思想）</p>
<h2 id="虚拟内存">虚拟内存</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129191908177.png" alt="image-20211129191908177"></p>
<p>任务越来越多，对内存的需求越来越大</p>
<p>基本思想：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>请求分页</strong>：仅仅把需要的页面载进来，而不是把任务的所有页都载进来。因此会存在未命中的问题</p>
</li>
</ul>
<p>优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在物理内存不变的情况下，可以载入更多的任务</p>
</li>
<li class="lvl-2">
<p>编写程序时无需考虑物理内存的情况，因此程序可以在不同内存大小的计算机上运行</p>
</li>
<li class="lvl-2">
<p>可以在比物理内存还大的虚拟地址空间中编程</p>
</li>
</ul>
<h3 id="流程">流程</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129192341451.png" alt="image-20211129192341451"></p>
<p><strong>所有使用的页面要载入到硬盘里，当前使用的页面载入到内存里</strong>，<strong>同时被替换且已经被修改的页重新存储到硬盘中，即写回法</strong></p>
<h3 id="设计">设计</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129192616096.png" alt="image-20211129192616096"></p>
<p>cache比主存快10倍，而主存比硬盘快100000倍，因此在cache中缺失来访问主存比在内存中缺失来访问硬盘的开销要小很多，所以要<strong>尽可能减少对硬盘的访问</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>增大页大小，一次能多加载些：如4KB</p>
</li>
<li class="lvl-2">
<p>使用关联映射，增大命中率</p>
</li>
<li class="lvl-2">
<p>采用写回法，减少对硬盘的访问</p>
</li>
</ul>
<h2 id="分页式虚拟存储器">分页式虚拟存储器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129193003620.png" alt="image-20211129193003620"></p>
<p>程序运行时，会生成一个<strong>页表</strong>，记录程序<strong>所有虚拟页</strong>的信息，<strong>页表同样也是存在内存里</strong></p>
<h3 id="页表">页表</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129193703884.png" alt="image-20211129193703884"></p>
<p>在页表中，<strong>虚拟页号是不用记录的</strong>，因为页表中是所有页的信息，数组的下标就代表了页的标号</p>
<p>物理地址和虚拟地址的<strong>页内地址是一样的</strong>，所以只要替换虚拟页号就可以，一般来说，<strong>虚拟地址的长度会比物理地址的长度要长</strong></p>
<h3 id="快表TLB">快表TLB</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129194533164.png" alt="image-20211129194533164"></p>
<p>页表的使用增加了主存的访问，每次访存都要通过页表去得知这个虚拟地址所对应的物理地址是多少，而之前的cache就是要尽可能减少主存的访问</p>
<p>而页表很大，不能全部放到cache中，<strong>所以把最活跃使用的几个页表项放到cache中，称为快表（TLB）</strong>，对应的主存中的页表就称为<strong>慢表</strong></p>
<p>快表采取<strong>关联/组关联映射，增大命中率；替换方法采用随机替换法</strong></p>
<h3 id="CPU访存过程">CPU访存过程</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129195949467.png" alt="image-20211129195949467"></p>
<p><strong>如果在TLB中hit了，那么这个页一定已经被载入内存中了。</strong></p>
<p>要出现TLB中命中但页没有被载入的情况，只有一种可能就是，TLB中有记录，但主存中对应的那一页被其他页给替换了，但这时新的页进来，那么TLB和页表自然也要更新，所以只要把刚刚被替换掉的那一页的记录也给替换掉即可。<strong>这样就可以保证TLB中的记录一定是已经被载入的</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129200701995.png" alt="image-20211129200701995"></p>
<h3 id="缺失组合">缺失组合</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129201443716.png" alt="image-20211129201443716"></p>
<p>第8种情况和上面的TLB命中必定载入同理，当一个页从主存中被替换出去后，<strong>cache中也会发生替换，那么这个新的数据自然是去把被替换掉的页的信息给替换掉最好</strong></p>
<p><strong>TLB缺失可以由硬件处理也可以由软件处理</strong></p>
<p><strong>缺页由软件处理，虚拟地址到物理地址的转换由硬件处理</strong></p>
<h2 id="分段式虚拟存储器">分段式虚拟存储器</h2>
<p>分页式可能会把数据分到不同的页，不利于保护和管理</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129204057971.png" alt="image-20211129204057971"></p>
<p>分段式和前面的分区类似，但同样是把需要的段载入内存中去，而不是和前面的分区那样是全部载入。同样会出现<strong>碎片化的问题</strong></p>
<h2 id="段页式虚拟存储器">段页式虚拟存储器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129204431193.png" alt="image-20211129204431193"></p>
<p>每一个段都有一个自己的页表<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106215707945.png" alt="image-20220106215707945"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211129204604663.png" alt="image-20211129204604663"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>13 总线</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/13%20%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>13 总线</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207153248644.png" alt="image-20211207153248644"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207153453753.png" alt="image-20211207153453753"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207153523369.png" alt="image-20211207153523369"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207153628700.png" alt="image-20211207153628700"></p>
<p>总线包括<strong>芯片内部总线、系统总线、通信总线</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207153843673.png" alt="image-20211207153843673"></p>
<p>系统总线在不同位置不同场景下会有不同的含义，课程中主要把系统总线作为一个通用的概念，而不是特指某条总线</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207154032467.png" alt="image-20211207154032467"></p>
<p>地址不一定只能一次传输，事实上有时候是可以分成两次来传输地址的，这样就能扩展寻址空间，即寻址空间不是由地址线的宽度来决定的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207154229952.png" alt="image-20211207154229952"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207154449894.png" alt="image-20211207154449894"></p>
<p><strong>当总线被使用时，其他设备不能抢占</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207154524872.png" alt="image-20211207154524872"></p>
<h2 id="用途">用途</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207154644495.png" alt="image-20211207154644495"></p>
<h2 id="仲裁">仲裁</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207154759597.png" alt="image-20211207154759597"></p>
<p>要在<strong>优先级和公平性之间取得平衡</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207163212308.png" alt="image-20211207163212308"></p>
<p>仲裁器是硬件设备，集中处理总线使用权</p>
<h3 id="集中式">集中式</h3>
<h4 id="链式查询">链式查询</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207163402586.png" alt="image-20211207163402586"></p>
<p>允许信号从仲裁器下发，按优先级从高到底传递（<strong>串行</strong>），从而高优先级的设备如果要使用总线，则可以截取允许信号</p>
<p>繁忙线与各个设备之间是<strong>双向箭头</strong>，因为各个设备要去监听看总线是否繁忙，如果繁忙则不能发起请求。同时得到允许的设备要去修改这条线的状态，使之变成繁忙</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207164628442.png" alt="image-20211207164628442"></p>
<p>连接的设备<strong>越多</strong>，那么速度就会<strong>越慢</strong>，因为允许信号要经过每一个设备</p>
<h4 id="计数器查询">计数器查询</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207164945819.png" alt="image-20211207164945819"></p>
<p>至少要<strong>log<sub>2</sub>n</strong>根线，来区分不同的设备ID，可以灵活的调整优先级</p>
<p>相当于一个个的报学号，可以按不同的顺序报，也可以从不同的位置开始报，从而来平衡优先级和公平性，先报到的可以使用总线</p>
<p>如果一个响应后又从1开始计数，那么就和上面的链式查询效果一样的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207165624775.png" alt="image-20211207165624775"></p>
<h4 id="独立请求">独立请求</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207165913987.png" alt="image-20211207165913987"></p>
<p>仲裁器可以灵活使用不同的策略来分配总线</p>
<p>但线路更多了</p>
<p>不需要和前面一样要等待询问其他设备就可以请求总线，随时都发送请求，如果仲裁器通过了，就可以直接获得允许</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207171157206.png" alt="image-20211207171157206"></p>
<h3 id="分布式">分布式</h3>
<h4 id="自举式">自举式</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207171325430.png" alt="image-20211207171325430"></p>
<p>设备<strong>只需要</strong>关心优先级比它高的设备是否需要使用总线，而<strong>无需</strong>去关心优先级比它低的设备是否需要总线</p>
<p>因此<strong>高优先级需要关心的少</strong>，上面设备3的优先级最高，只需要关心是否总线忙即可</p>
<p>而<strong>最低优先级的设备没有请求线</strong>，如上的设备0，因为没有其他设备需要去关心它的请求</p>
<p>同样的当使用总线时要把总线设为忙</p>
<p><strong>优先级很明显</strong></p>
<h4 id="冲突检测">冲突检测</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207172059705.png" alt="image-20211207172059705"></p>
<p><strong>公平性很明显</strong></p>
<p>解决冲突要消耗一定的时间，效率会低一些</p>
<h2 id="时序">时序</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207172448029.png" alt="image-20211207172448029"></p>
<p><strong>总线事务</strong>是指在总线上完成一次数据的传递：是指根据<strong>一个地址，但数据可能会传输多次</strong></p>
<h4 id="同步时序？？">同步时序？？</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207172655523.png" alt="image-20211207172655523"></p>
<p>所有设备共用一个时钟，会导致快的设备要去迁就慢的设备(即要等待慢的设备，而不像下面的异步一样快的设备只要发出信号就可以去做其他事情)，也即快的设备的速度没法发挥出来。</p>
<blockquote>
<p>如时钟周期为50ns，存储器准备数据230ns，那么实际上仍然需要250ns才能完成数据的准备，因为必须在一个时钟周期开始才能进行下一步，所以即使存储器完成了准备，也需要等待时钟周期，而异步时序则当数据准备完成即可直接传输</p>
</blockquote>
<p>总线不能太长，如果总线很长，那么时钟信号会有较大的延迟</p>
<h4 id="异步时序">异步时序</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207173006368.png" alt="image-20211207173006368"></p>
<p>Ready信号说明已经准备好了，设备可以来取，Ack信号表明告诉对方已经取完了，对方可以把ready信号给拿走了</p>
<p>信号都有上升沿和下降沿，分别表示把信号放到总线上和把信号从总线上拿走的过程</p>
<p><strong>一次握手其实就是表明一个前后关系</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>非互锁</strong>是一个自然的状态，只通过<strong>一次握手</strong>，而没有加额外的限制，只是一个自然的先后关系，先准备好才能去取，然后才有取好信号</p>
</li>
<li class="lvl-2">
<p><strong>半互锁</strong>是用<strong>两次握手</strong>强调已经取完了之后Ready信号才能撤走，这是为了防止出现在取之前（并不是一出现Ready就去取，可能正在处理其他事务）就已经撤走了Ready，即撤早了，而无法取数据就一直处于等待的情况</p>
</li>
<li class="lvl-2">
<p><strong>全互锁</strong>是用<strong>三次握手</strong>强调只有Ready撤走后，才能撤走Ack，如果ready的设备正在处理其他事务，而另一个设备已经取好了，并撤走了Ack，那么设备就以为对方还没有取好，因此会一直处于Ready状态</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207205114405.png" alt="image-20211207205114405"></p>
<p>注意总共为<strong>7次握手</strong>，<strong>握手中即有数据传输的时间</strong>，所有的握手时间加起来即一次总线事务的时间，而不需要额外考虑数据传输。</p>
<blockquote>
<p>如1花费了40ns，即存储器得到ReadReq信号并读取了地址并设置了Ack信号花费40ns。此时存储器已经得到了地址信息，可以<strong>开始准备数据</strong>。</p>
<p>数据准备阶段：在234中有3次握手，是为了保证顺序，当4结束时存储器把数据放到数据线上，因此这里花费的时间为<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220107113225293.png" alt="image-20220107113225293">3次握手的时间和存储器准备这些数据的时间的<strong>最大值</strong>。</p>
<p>数据传输阶段：567则是通过3次握手，保证数据能传输到CPU中</p>
<p>上面3个部分全部加起来就是一次总线事务的时间，数据量/时间即数据传输速率</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207205610699.png" alt="image-20211207205610699"></p>
<p>速度快的设备在Ready后，就可以去忙别的事情了，而等慢的设备Ack后，快的设备再回来处理这件事，从而<strong>协调好不同速度的设备</strong></p>
<p><strong>对噪声敏感</strong>是指设备可能把噪声误认为是信号，从而出现错误。因为异步信号的发送是没有固定的时间的，是<strong>很随意的</strong>，任何时间段都可以发出信号，所以会容易把偶然的噪声当作信号</p>
<h4 id="半同步时序">半同步时序</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207205842375.png" alt="image-20211207205842375"></p>
<p>固定在<strong>上升沿</strong>才能发出<strong>准备和响应信号</strong>，其他时间段的信号均为无效，从而减少噪声的影响</p>
<h4 id="分离事务">分离事务</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207210148594.png" alt="image-20211207210148594"></p>
<p>即把总线事务分成地址传过去和数据传过来两个过程，在得到地址后准备数据的过程中，可以把总线释放出来，给其他设备使用，等数据准备好了，再去申请总线</p>
<p>提高了<strong>总线利用率</strong></p>
<p>但这样会<strong>增加每个总线事务的时长</strong>，因为在数据准备好后再申请总线不一定立刻就能得到，可能需要等待一段时间</p>
<h2 id="总线带宽和数据传输速率">总线带宽和数据传输速率</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207210713756.png" alt="image-20211207210713756"></p>
<p>总线带宽是<strong>理想状态</strong>下的<strong>数据传输速率</strong>，不考虑<strong>地址传输</strong>和总线仲裁</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207211038040.png" alt="image-20211207211038040"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207211207154.png" alt="image-20211207211207154"></p>
<p><strong>地址不算数据</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207211252537.png" alt="image-20211207211252537"></p>
<p>同步总线中一个时钟周期内只能做一件事情</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207211412513.png" alt="image-20211207211412513"></p>
<p>计算数据传输速率只要计算传输一次4个或16个字即可，同时<strong>最后全部传完之后的空闲也要算进去，因为肯定还会有下一次总线事务，所以可以算入到每次传完后里面</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207212358935.png" alt="image-20211207212358935"></p>
<p>这里每次总线事务都是可以理解是第一次访问内存，所以都需要花费200ns，只有像下面的一次传输一个块的，才是考虑后面的访cache速度快</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211207212407122.png" alt="image-20211207212407122"></p>
<h4 id="提高总线的数据传输率">提高总线的数据传输率</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211201211349.png" alt="image-20211211201211349"></p>
<p>块传输可以<strong>减少地址传输的时间</strong>，同时<strong>减少了准备数据的时间</strong>，因为有cache的存在，所以第一次数据读取会比较慢，但后续的读取会很快</p>
<h2 id="总线的层次结构">总线的层次结构</h2>
<p>总线主要讨论<strong>CPU、主存、IO</strong>之间的连接和数据传输</p>
<h4 id="单总线结构">单总线结构</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211213440303.png" alt="image-20211211213440303"></p>
<h4 id="双总线结构1">双总线结构1</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211213600776.png" alt="image-20211211213600776"></p>
<h4 id="双总线结构2">双总线结构2</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211213732850.png" alt="image-20211211213732850"></p>
<p>####　多总线结构１</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211213813963.png" alt="image-20211211213813963"></p>
<p>这种情况是cache还设计在CPU外,与之分离的时候的总线结构,当cache合并到CPU中时,就是内部总线了,而不存在上面的本地总线</p>
<h4 id="多总线结构2">多总线结构2</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211214009253.png" alt="image-20211211214009253"></p>
<p><strong>从外部输入的数据可以直接存入主存，而不需要经过CPU</strong></p>
<h4 id="多总线结构3">多总线结构3</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211214258764.png" alt="image-20211211214258764"></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211211214355193.png" alt="image-20211211214355193"></p>
<p><strong>总线的巨大缺点是一次只能有一个数据在总线上，如果多个，那么会出错</strong></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>15 指令周期和流水线</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/15%20%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>15 指令周期和指令流水线</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212172556900.png" alt="image-20211212172556900"></p>
<span id="more"></span>
<h2 id="指令周期">指令周期</h2>
<h3 id="指令周期-2">指令周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212172643616.png" alt="image-20211212172643616"></p>
<p>只有机器关闭，发生错误，遇到停止计算机的指令时，程序才会停止。只要计算机开着，即使不使用，也是持续在执行指令的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212172844488.png" alt="image-20211212172844488"></p>
<p><code>返回字符串或向量数据</code>是指比如要取一个字符串，那么一次可能无法全部得到，那么就<strong>必须要分多次，多次的计算源操作地址，取字符串，计算目的操作数地址，存字符串</strong>。但这是<strong>一条指令的功能</strong>，所以直到全部取完后，才进行下一条指令的地址计算</p>
<h3 id="带中断的指令周期">带中断的指令周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212173408972.png" alt="image-20211212173408972"></p>
<p><strong>在这条指令执行完，下一条指令未开始的中间进行中断的判断</strong>（这时候PC已经是下一条指令的地址了）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212173517551.png" alt="image-20211212173517551"></p>
<h3 id="间址周期">间址周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212173634159.png" alt="image-20211212173634159"></p>
<p>把间接地址的读取看作一个额外的指令子周期，相比于直接寻址，<strong>多了存储器的访问，所以单独作为一个子周期</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212173845638.png" alt="image-20211212173845638"></p>
<h2 id="CPU的任务">CPU的任务</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212174036530.png" alt="image-20211212174036530"></p>
<h3 id="寄存器">寄存器</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212174727688.png" alt="image-20211212174727688"></p>
<h3 id="数据流">数据流</h3>
<h4 id="取指周期">取指周期</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212174908311.png" alt="image-20211212174908311"></p>
<p>如果是同步的总线，那么只要按时间取做上面的流程即可，如果是异步总线，那么在存储器把数据放到数据总线上时，还要通过控制总线告诉CPU已经好了，所以存储器与控制总线之间是双向箭头。</p>
<p>而这里单向箭头，说明是同步总线。事实上，一般来说，<strong>CPU和存储器之间都是采用同步的</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212175521345.png" alt="image-20211212175521345"></p>
<p>黄色箭头代表两个含义：</p>
<ol>
<li class="lvl-3">
<p>控制PC传输地址，从而取指令</p>
</li>
<li class="lvl-3">
<p><strong>当指令取完后、指令执行前</strong>（一般是<strong>要取到IR中后才加1</strong>，即在<strong>取指周期的最后</strong>加1，否则不知道+1是加多少），而不是指令执行完，控制PC+1。但其实也不一定，<strong>如下，PC+1可以和其他的一起执行</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220107160454915.png" alt="image-20220107160454915"></p>
</li>
</ol>
<h4 id="间址周期-2">间址周期</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212175802748.png" alt="image-20211212175802748"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212175852485.png" alt="image-20211212175852485"></p>
<p>注意：<strong>间址周期取回来到MBR的只是有效地址EA，而通过有效地址EA去取操作数的过程是在执行周期里的</strong></p>
<h4 id="中断周期">中断周期</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212180314902.png" alt="image-20211212180314902"></p>
<p>这里数据线都是指向存储器的，表明<strong>写操作</strong>，同时PC连到MBR，因此这里想要做的是对<strong>PC进行保存（PC这时候存的是下一条指令的地址）</strong>，从而能够在中断之后能够准确的<strong>返回</strong></p>
<p>中断中由<strong>控制器去告诉MAR地址</strong>，即PC要存储在存储器的哪一个位置，这个地址<strong>很可能是栈的指针</strong>，中断也是过程调用</p>
<p><strong>（在取指过程中由PC告诉MAR，在间址过程中由MBR告诉MAR）</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212181013832.png" alt="image-20211212181013832"></p>
<h2 id="指令流水线">指令流水线</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212195915496.png" alt="image-20211212195915496"></p>
<p>流水线可以让每个部件各司其职，只做它要做的单一的事，提高效率，<strong>节省时间</strong></p>
<p><strong>CPU就像一个生产线</strong>，如果各个步骤的任务分配不够好，比如不同步骤所需时间不同，那么就会造成资源的浪费，如矿泉水的生产，不同步骤时间不同，那么时间短的就会闲着。</p>
<p><strong>因此对CPU生产线上的步骤进行阶段划分：</strong></p>
<h3 id="两阶段方法">两阶段方法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212200713610.png" alt="image-20211212200713610"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212200819371.png" alt="image-20211212200819371"></p>
<p>取指令要访问内存，执行指令也可能要访问内存，可能会造成访存冲突</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>取指令的等待</strong>是执行的时间比取指令的时间长，所以要等待</p>
</li>
<li class="lvl-2">
<p><strong>执行阶段的等待</strong>是可能执行的是跳转指令，所以取指令在执行期间取好的指令就要<strong>作废</strong>，要<strong>根据新的地址去取指令</strong>，此时执行阶段要等待</p>
</li>
</ul>
<h3 id="六阶段方法">六阶段方法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212201501405.png" alt="image-20211212201501405"></p>
<p>六个阶段的所需时间<strong>几乎相等</strong>，因此如下可以把每个阶段<strong>所需时间当作一个时间单位</strong></p>
<p><strong>注意在EI阶段就会把目的操作数写入目的位置（主要是CPU内的寄存器），而如果是要写入主存的，才在WO阶段写，就和上面的FO一样，对于寄存器中的值不需要取，取的是主存中的操作数</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212201648969.png" alt="image-20211212201648969"></p>
<p>如同生产矿泉水的流水线</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212201926683.png" alt="image-20211212201926683"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>为了简化流水线的设计，可以假定每个指令都是6个阶段，如果没有某个阶段，不执行即可（如果为特殊指令设计不同阶段，那么是非常不划算的）</p>
</li>
<li class="lvl-2">
<p>阶段之间<strong>不一定全都能并行，如对内存的访问，会产生访存冲突</strong></p>
</li>
<li class="lvl-2">
<p>几乎相等，仍然是有差别时间，那么会导致一定的等待，所以<strong>时间单位应该以最长的时间的为准</strong>，保证每个阶段在这个时间单位内都能执行完</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212203056479.png" alt="image-20211212203056479"></p>
<p><strong>限制</strong>：在两阶段中跳转指令会使得已经取得的下一条指令失效。而在六阶段中会使得上面<strong>红框中执行了一半的指令的全部失效</strong></p>
<p><strong>注意</strong>：上面的<strong>最后一个指令的WO的同时，下面的FI也在执行</strong>，这是因为跳转指令<strong>不需要写存储器</strong>，而是在EI执行指令的过程中就把PC寄存器的值给改变了，<strong>所以在EI后面一个单位时间会执行正确的FI</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212203319302.png" alt="image-20211212203319302"></p>
<p>和跳转一样，中断也会使得指令失效，如上图中的<strong>排空流水线</strong>，这里多了一个无条件转移，<strong>那么在无条件转移把PC值修改后的一个单位时间内的FI才是有效的，中间的流水线全部失效</strong>，但已经在执行的指令的后续阶段是不受影响的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212203406279.png" alt="image-20211212203406279"></p>
<p>绿色框是导致<strong>空闲</strong>的区域，而红色框内的执行是<strong>无效</strong>的，同理指令13的EI修改了PC，所以下面一个单位时间的I15才是有效的，中间的全部失效，但I13剩下的阶段正常进行</p>
<h3 id="流水线的性能">流水线的性能</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212203637784.png" alt="image-20211212203637784"></p>
<p>这里的<strong>t即单位时间</strong>，应当为各阶段中花费时间最大的时间，加上两阶段切换的时间</p>
<p>锁存时间是在<strong>两个阶段之间切换的时间</strong>，<code>就像接力赛，接力棒由前一个人放到桌子上，下一个人再去桌子上拿，这样是最稳妥安全的。</code></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212204131466.png" alt="image-20211212204131466"></p>
<p>T<sub>k,n</sub>是<strong>最理想</strong>的情况，第一条指令执行需要kt，后面的每多一条指令，总时间只增加1t，所以是$[k+(n-1)]t$</p>
<p><strong>加速比</strong>是指<strong>没有使用流水线和使用了流水线的时间之比</strong>，是一个大于1的数（所以才叫加速比）</p>
<p><strong>注意</strong>：其中分子没有使用流水线是<strong>固定的就是</strong>$nkt$，n条指令，每个需要kt时间，而分母使用了流水线的可能会有<strong>跳转</strong>的情况，会<strong>导致时间的改变</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212204913493.png" alt="image-20211212204913493"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212204955419.png" alt="image-20211212204955419"></p>
<p>当<strong>流水线中的阶段增多时，刚开始是会加快执行速度</strong>，但不是越多越好，当阶段太多，<strong>锁存延时会增加，增大开销</strong>。同时阶段越多，对<strong>硬件的使用冲突就会越大</strong>，需要更为复杂的控制逻辑</p>
<h2 id="冒险（Hazard）">冒险（Hazard）</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212192410033.png" alt="image-20211212192410033"></p>
<h3 id="结构冒险">结构冒险</h3>
<p><strong>硬件资源冲突</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212192529705.png" alt="image-20211212192529705"></p>
<p>分时使用如在时钟的上升沿和下降沿分给不同指令使用</p>
<h3 id="数据冒险">数据冒险</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212192825027.png" alt="image-20211212192825027"></p>
<p>第一条指令中r1寄存器被更新，但根据指令的周期，后面的若干条指令中获得的r1寄存器都是未更新的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212193228583.png" alt="image-20211212193228583"></p>
<p>用<strong>软件</strong>nop指令让这3个时钟周期啥也不干，直到r1被成功更新后再执行后续指令，从而不需要改动硬件</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212193309257.png" alt="image-20211212193309257"></p>
<p>插入气泡——即<strong>硬件</strong>通过<strong>阻塞</strong>阻止可能出问题的指令的执行，因此需要判断哪些指令相关，怎么去阻塞的问题，虽然没有加nop指令，但在判断处理过程中也会有<strong>时间开销</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212193513871.png" alt="image-20211212193513871"></p>
<p><strong>把需要的结果从中间就取过来，而不必去等指令的完全执行。</strong></p>
<blockquote>
<p>如r1要存放的新数据在经过ALU时即已经产生，只是结果没有更新到所在的r1寄存器中。此时第二条指令可以把这个结果取过来直接用，而不必等待第一条指令完全执行完。因为ALU不会同时被两条指令占用，第一条用完ALU，才会给第二条使用，因此上面的取中间结果是可行的</p>
</blockquote>
<p>这就是<strong>转发/旁路</strong>。<strong>当后面要用到的数据是<code>前面算出来的</code>经过ALU即可得到时，这时候旁路很有效</strong>，当不是时，旁路无法解决，如下</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212194118012.png" alt="image-20211212194118012"></p>
<p>r1寄存器此时要从内存中加载数据，而下面sub r1就要用这个数据进行alu计算，但数据还没有从内存中读取过来，所以必须<strong>要等待到从内存中取到数据</strong>才行，根据转发机制，<strong>同样不必等待这个数据加载到r1即可取到</strong>。即上面的红线的</p>
<p>解决办法就是<strong>交换指令的顺序</strong>，如右，lw b 和lw c到两个寄存器中，当执行add时，还没加载好，所以要等待。因此可以通过把下面的一条不相关的指令换上来，这样可以<strong>把等待的时间变成执行后面指令的时间</strong>。<strong>总体执行时间会缩短</strong></p>
<h3 id="控制冒险">控制冒险</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212194833356.png" alt="image-20211212194833356"></p>
<p>当指令的执行顺序被改变，那么就会出现一部分的指令执行白处理了，原因就是取错了。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212195029198.png" alt="image-20211212195029198"></p>
<p>即把跳转指令之后的指令和跳转到的指令都取过来，<strong>因为不知道这个跳转指令是不是真的要跳转（如多个条件跳转指令），所以就不能确定到底是执行后面的指令还是执行跳转指令中的指令</strong></p>
<p>所以把两个都取过来，两条流水线处理，那么就保证了流水线的正常运行，即使有一条是失效的，那么不管它即可，另外一条在按照流水线正常运行</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212195049933.png" alt="image-20211212195049933"></p>
<p>预测会不会发生转移，<strong>如果预测会发生转移，那么就直接取跳转指令中指出的指令，而不去取跳转指令后面的指令。</strong></p>
<p><code>如果预测失败了，那么就造成了流水线中已经执行的部分指令的失效；反之如果预测成功了，那么就避免了指令的失效，从而提高了流水线的效率</code></p>
<p>静态预测是和当前状态没有关系的，不会去根据刚刚处理的历史来改变，<strong>仅仅是按照规则</strong></p>
<h4 id="动态预测">动态预测</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212195529046.png" alt="image-20211212195529046"></p>
<p>根据状态来动态预测</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212195749976.png" alt="image-20211212195749976"></p>
<p>遇到条件分支，看是不是第一次遇到，如果是就加入表中，如果发生过，看前面的预测是怎么样的，然后根据现在的状态来调整</p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>14 指令系统</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/14%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>14 指令系统</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212092749737.png" alt="image-20211212092749737"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212092911122.png" alt="image-20211212092911122"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212093045231.png" alt="image-20211212093045231"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212093132151.png" alt="image-20211212093132151"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212093330607.png" alt="image-20211212093330607"></p>
<h2 id="操作码">操作码</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212093423565.png" alt="image-20211212093423565"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212094308250.png" alt="image-20211212094308250"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212094720725.png" alt="image-20211212094720725"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>寄存器可以支持没有嵌套的函数调用，如果要多层调用，多个寄存器会用来存放返回地址</p>
</li>
<li class="lvl-2">
<p>每一个过程开始的位置是空出来的，空出来存放调用它的程序需要返回的位置，可以多层调用，但不能支持如递归调用，重复调用一个过程。</p>
</li>
<li class="lvl-2">
<p>使用栈可以解决上述问题</p>
</li>
</ul>
<h2 id="操作数">操作数</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212095506376.png" alt="image-20211212095506376"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212095700587.png" alt="image-20211212095700587"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212141558649.png" alt="image-20211212141558649"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212141622889.png" alt="image-20211212141622889"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212141640355.png" alt="image-20211212141640355"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212141844113.png" alt="image-20211212141844113"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212141939122.png" alt="image-20211212141939122"></p>
<h3 id="寻址方式">寻址方式</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212141957517.png" alt="image-20211212141957517"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212142102038.png" alt="image-20211212142102038"></p>
<p>地址A指向的不一定是操作数本身，而可能是一个地址，这个地址才指向操作数，那么这个地址就叫做<strong>有效地址EA</strong></p>
<h4 id="立即寻址">立即寻址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212155348063.png" alt="image-20211212155348063"></p>
<p>地址字段存放的就是操作数，操作数以<strong>立即数</strong>的方式给出</p>
<h4 id="直接寻址">直接寻址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212155841498.png" alt="image-20211212155841498"></p>
<p>地址字段是有效地址，可以直接获取操作数的有效地址EA，操作数始终可以表示为（EA）</p>
<h4 id="间接寻址">间接寻址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212160306179.png" alt="image-20211212160306179"></p>
<p><code>地址引用的数量限制可能是有益的</code>指的是虽然采用了间接寻址，虽然A的长度会限制放EA的范围（A长度可能很小，涵盖的地址空间小）<strong>但这未必是一件坏事</strong></p>
<h4 id="寄存器寻址">寄存器寻址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212160858665.png" alt="image-20211212160858665"></p>
<p>寄存器数量少，所以需要的编号长度小，寄存器里面存放了操作数，所以EA=R</p>
<p>当一个数/变量被多次使用时，数据存放在寄存器才有意义，因为寄存器速度快，如果只是从主存中取一个数，使用一次就不用了，那么就没必要存放在寄存器中，直接从主存中读取即可</p>
<h4 id="寄存器间接寻址">寄存器间接寻址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212161338438.png" alt="image-20211212161338438"></p>
<p>寄存器中存放的是有效地址</p>
<h4 id="偏移寻址（计算出的都是EA，需要到EA中取得操作数，因此偏移寻址都是要计算出EA的，都可以看作是一种间接寻址，直接寻址的EA是直接给出的）">偏移寻址（计算出的都是EA，需要到EA中取得操作数，因此偏移寻址都是要计算出EA的，都可以看作是一种间接寻址，直接寻址的EA是直接给出的）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212162310774.png" alt="image-20211212162310774"></p>
<p>偏移寻址结合了直接寻址（A）和寄存器间接寻址（（R））两个地址字段，即上面的<strong>寄存器编号和偏移地址A</strong>。其中至少有一个必须是显式，即<strong>A必须是显式的</strong></p>
<h5 id="相对寻址">相对寻址</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212162632473.png" alt="image-20211212162632473"></p>
<p>利用程序的局部性原理，用短的地址差，去代替长的实际地址，节省指令中地址段长度</p>
<h5 id="基址寄存器寻址">基址寄存器寻址</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212163015601.png" alt="image-20211212163015601"></p>
<p>寄存器（基址寄存器）的引用可以是显式的，也可以是隐式的（隐含在操作码中）</p>
<h5 id="变址寻址">变址寻址</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212163206119.png" alt="image-20211212163206119"></p>
<p>A是地址，而寄存器中存放的是偏移量（所以是变址寄存器），比如访问数组，寄存器中的值增加，就可以逐步访问数组中的内容</p>
<p>前变址就是先变址再用间接寻址；后变址就是先对A间接寻址，再变址，得到的都是EA</p>
<h4 id="栈寻址">栈寻址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212163601750.png" alt="image-20211212163601750"></p>
<h2 id="栈">栈</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212163843782.png" alt="image-20211212163843782"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212163935559.png" alt="image-20211212163935559"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212164209420.png" alt="image-20211212164209420"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>中缀表达式转后缀表达式，<strong>对于操作数，直接输出</strong>，而对于<strong>运算符</strong>，则<strong>看这个运算符和栈顶的运算符的优先级</strong>，如果这个运算符比栈顶运算符优先级<strong>高</strong>，那么把这个运算符<strong>压栈</strong>，反之，如果<strong>小于等于</strong>，则<strong>弹出栈顶运算符</strong>，然后再比较下一个运算符</p>
</li>
<li class="lvl-2">
<p><strong>对于左括号，直接压入</strong>，但括号的优先级比其他运算符低，所以新的+遇到栈顶的括号，+优先级比括号高，直接压入</p>
</li>
<li class="lvl-2">
<p><strong>对于右括号，则把运算符弹出</strong>，直到遇到左括号，把左括号弹出就结束，即左右括号被消除了</p>
</li>
<li class="lvl-2">
<p><strong>当输入为空，则把栈中的运算符逐个弹出</strong></p>
</li>
</ul>
<h2 id="指令格式">指令格式</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212170223424.png" alt="image-20211212170223424"></p>
<h4 id="设计原则">设计原则</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212170339085.png" alt="image-20211212170339085"></p>
<h4 id="指令长度">指令长度</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212170548422.png" alt="image-20211212170548422"></p>
<h4 id="位的分配">位的分配</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212170801192.png" alt="image-20211212170801192"></p>
<p>变长操作码是指<strong>指令的长度是固定的，只是对于有些指令，操作码长度长，有些短</strong>，所以操作数的长度也会相应变化，操作码长，那么操作数就少/短</p>
<h4 id="变长指令">变长指令</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212171345310.png" alt="image-20211212171345310"></p>
<p><strong>指令的长度是变化的</strong></p>
<p>通过取至少为最长指令长度的内容，来保证每次至少能取到一条指令</p>
<blockquote>
<p>CPU内部有个指令预取单元，每周期从一级指令缓存中取16字节指令流，此时并不知道取了多少指令。随后有一个指令预译码阶段，会根据x86指令的译码规则界定出每条指令的边界。后续是指令译码阶段，将x86指令翻译成微指令。</p>
</blockquote>
<blockquote>
<p>RISC处理器是定长指令，没有这个问题，CISC处理器采用变长指令，指令预取部件会从指令缓存中取一段到指令队列中，并不限于单指令最大长度，可能达到几十字节，和每时钟周期指令发射条数有关。</p>
</blockquote>
<h2 id="指令集设计">指令集设计</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212171634673.png" alt="image-20211212171634673"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212171738524.png" alt="image-20211212171738524"></p>
<p>指令集的设计要和寄存器个数匹配</p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211212171915782.png" alt="image-20211212171915782"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>16 控制器</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/16%20%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>16 控制器</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220141451495.png" alt="image-20211220141451495"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220141603472.png" alt="image-20211220141603472"></p>
<p>左边的图中粗的箭头表示控制信息，细的箭头表示数据的流动</p>
<h2 id="寄存器分类">寄存器分类</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220141923575.png" alt="image-20211220141923575"></p>
<p>两种的划分并不严格，有些寄存器具有两种特点</p>
<h3 id="用户可见寄存器">用户可见寄存器</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220142121884.png" alt="image-20211220142121884"></p>
<p><strong>条件码寄存器不是必须的</strong>，有些机器没有条件码寄存器</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220142440645.png" alt="image-20211220142440645"></p>
<p>太多的寄存器不能显著减少存储器的访问：指的是当寄存器的数量多于一定数目时，对存储器访问的减少作用很小了，但带来了成本的上升，因此是不值得的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220142816292.png" alt="image-20211220142816292"></p>
<p>子程序的调用会自动保存用户可见寄存器，这样子程序运行时就可以随意使用用户可见寄存器，而不用担心会对调用者的数据产生影响（<em>即可以理解是如call指令包括了对寄存器保存的指令</em>）</p>
<p>但在子程序调用之外，想要保存相关的寄存器内容，就是程序员的任务了，需要编写相关的指令去保存（汇编）</p>
<h3 id="控制和状态寄存器">控制和状态寄存器</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220143225326.png" alt="image-20211220143225326"></p>
<p>从主存中读出的<strong>数据先到MBR，再通过MBR到通用寄存器</strong></p>
<p>ALU可以<strong>对MBR和用户可见寄存器</strong>直接存取</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220143400782.png" alt="image-20211220143400782"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220143441675.png" alt="image-20211220143441675"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220143456971.png" alt="image-20211220143456971"></p>
<p><strong>控制信息并不全部都是存放在寄存器中的</strong>，有相当一部分的控制信息是存放在主存中的，这样可以平衡成本（寄存器越多越贵）和速度（寄存器速度更快）</p>
<h2 id="微操作">微操作</h2>
<p>关于微操作的出现：<a href="https://blog.csdn.net/sinat_40003796/article/details/126701654">CISC和RISC：为什么手机芯片都是ARM？</a></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220144658432.png" alt="image-20211220144658432"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220144733549.png" alt="image-20211220144733549"></p>
<p><strong>涉及CPU寄存器操作的更小步骤，称为微操作</strong></p>
<h3 id="取指周期">取指周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220144902430.png" alt="image-20211220144902430"></p>
<p>第二步从主存中取指令的过程中也同时进行了PC+1（<strong>1是指一条指令的长度</strong>）的操作</p>
<p>上面的<strong>t表示一个时间单位</strong>，即微操作要表示出**<font color=#ff00>做什么、发生在哪个时间单位</font>**两个内容</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220145504299.png" alt="image-20211220145504299"></p>
<p>如上，PC+1的操作放到t2和放到t3均可以</p>
<h3 id="微操作分组的原则">微操作分组的原则</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220145554405.png" alt="image-20211220145554405"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>事件的顺序必须是<strong>恰当的</strong></p>
</li>
<li class="lvl-2">
<p><strong>同一时间段</strong>内的微操作必须是<strong>无关的</strong>，可以同时进行的，即谁先谁后都一样，如上面的PC+1</p>
</li>
<li class="lvl-2">
<p>满足前两条的情况下，要让<strong>所用时间单位尽可能少</strong>，如上面的IR&lt;—(MBR)不能放到第四个时间单位t4，因为这样所花费的时间更多了，事实上3个时间单位就能完成</p>
</li>
</ul>
<h3 id="间址周期">间址周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220150048983.png" alt="image-20211220150048983"></p>
<p><strong>注意</strong>：这里通过间接地址取回来的有效地址<strong>EA是用于修改指令寄存器中指令的里面的地址的</strong>，而<strong>不是直接放到MAR</strong>中，这样可以保证与不使用间址周期的状态一致，从而为执行周期做好准备，执行周期直接使用指令中的地址就可以得到正确的操作数，<strong>保证了兼容性</strong></p>
<h3 id="执行周期">执行周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220150843375.png" alt="image-20211220150843375"></p>
<p>BSA指令中：t1中把要保存PC的地址送到MAR，把PC的内容送到MBR，从而可以把MBR中的内容保存在MAR所存的地址中去。同时这两个微操作是不冲突的，因此放到一个时间单位中执行</p>
<h3 id="中断周期">中断周期</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220151555675.png" alt="image-20211220151555675"></p>
<p>两个时间单位即可完成</p>
<h2 id="指令周期代码（ICC）">指令周期代码（ICC）</h2>
<p>对于整个的指令、多条指令如何将不同的微操作联系起来？</p>
<p>通过<strong>ICC来实现</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220152020014.png" alt="image-20211220152020014"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220152327430.png" alt="image-20211220152327430"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220152400973.png" alt="image-20211220152400973"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220152432604.png" alt="image-20211220152432604"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220152512047.png" alt="image-20211220152512047"></p>
<h2 id="CPU内部总线">CPU内部总线</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220152617231.png" alt="image-20211220152617231"></p>
<p>上面右图中的空心圆就表示门，由控制信号来决定这些门的开关</p>
<p>这里的例子是一个加法指令，其中数据要先存放到一个Y寄存器中，<strong>Y寄存器起到暂存数据的作用，Y与ALU直接连接</strong>。</p>
<p>注意：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>总线上一次只能有一个数据，否则会出错，因此不能说把上图中红色和绿色的实心箭头的门都打开，两个数据一起到ALU运算。</p>
</li>
<li class="lvl-2">
<p>同时，当ALU运算完成后，也不能直接把数据存到AC中，因为这时候总线上还是AC的数据，因此要把结果先存放到另一个寄存器Z中，再通过关闭红色的两个箭头的门，打开蓝色的两个箭头的门，将结果送到AC中</p>
</li>
</ul>
<p><strong>因此，一个add M %eax的指令事实上包含了若干个微操作</strong></p>
<hr>
<h2 id="控制器">控制器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220153912815.png" alt="image-20211220153912815"></p>
<p>控制器的基本任务：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>定序</strong></p>
</li>
<li class="lvl-2">
<p><strong>执行</strong></p>
</li>
</ul>
<h3 id="控制器的输入">控制器的输入</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220154436278.png" alt="image-20211220154436278"></p>
<p>控制器的输入有四个：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>指令寄存器</p>
</li>
<li class="lvl-2">
<p>标志</p>
</li>
<li class="lvl-2">
<p>时钟</p>
</li>
<li class="lvl-2">
<p>来自控制总线的控制信号：一般情况下是控制器发出信号，在特定情况下，如控制器会收到中断请求</p>
</li>
</ul>
<h3 id="控制器的输出">控制器的输出</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220154808602.png" alt="image-20211220154808602"></p>
<p>控制器输出控制信号：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CPU内的控制信号</p>
</li>
<li class="lvl-2">
<p>到控制总线的控制信号（CPU外的）</p>
</li>
</ul>
<p><strong>控制信号最终作为二进制输入量（即0和1）来控制各个逻辑门，如0即关闭门，1打开门</strong></p>
<h4 id="控制信号示例：取指周期">控制信号示例：取指周期</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220155304109.png" alt="image-20211220155304109"></p>
<h3 id="控制器的最小特性">控制器的最小特性</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220155827906.png" alt="image-20211220155827906"></p>
<p><strong>最小特性意思是控制器在实现上应该尽可能的简洁</strong>，只需要知道是什么指令，逻辑运算结果的性质，无需知道要处理的是什么数据，也不需要知道结果是什么，只需要知道它们的部分性质（如是否为0，正还是负即可，比如条件转移指令中要不要跳转就要看标志信息）</p>
<h3 id="控制器的实现">控制器的实现</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220160029056.png" alt="image-20211220160029056"></p>
<h4 id="硬布线实现">硬布线实现</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220160211471.png" alt="image-20211220160211471"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220160620191.png" alt="image-20211220160620191"></p>
<p>定时器在完成一个子周期（取指周期、间址周期等）后会清零，在下一次子周期继续T<sub>1</sub>，T<sub>2</sub>的计数</p>
<p><strong>因此需要控制器在指令周期结束后通知定时器清零</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220173459074.png" alt="image-20211220173459074"></p>
<p>为输出的控制信号设计<strong>利用控制器输入的布尔表达式</strong></p>
<p>PQ的非表示0，+表示或，·表示与</p>
<p><strong>随着输入和输出的逐渐复杂，布尔表达式会变得很庞大，用电路去实现会非常困难</strong></p>
<h4 id="微程序实现">微程序实现</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220174705236.png" alt="image-20211220174705236"></p>
<p><strong>微程序即固件，位于硬件和软件之间</strong></p>
<p><strong>微指令：用一行微指令可以描述在一个时间内出现的一组微操作</strong>（因为可以同时进行，所以它们是互不干扰的，因此它们的控制字可以组合在一起）<strong>即微指令是t<sub>i</sub>内的所有微操作</strong></p>
<p><strong>微指令即为一个控制字，微指令的执行就是把控制字通过控制器输出</strong></p>
<p><strong>控制字</strong>：用一串01序列，每一位表示一根控制线，其中1表示控制线所连的门打开，0表示关闭，每个微操作对应的门的开闭是不同的，所以每个微操作可以对应一个控制字</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220175249145.png" alt="image-20211220175249145"></p>
<p>把<strong>所有情况的控制字存储到控制器存储器</strong>中，使得每一个控制字都有自己的地址</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220175527795.png" alt="image-20211220175527795"></p>
<p>在例程的最后会有一个<strong>分支或转移微指令</strong>，指出下面要到何处执行</p>
<p>上面有一个执行周期例程，<strong>它的目的仅仅在于根据当前操作码指明哪个机器指令的例程将被执行</strong></p>
<p>如上图，<strong>微程序是要存储所有可能指令的序列</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220180108834.png" alt="image-20211220180108834"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220180234225.png" alt="image-20211220180234225"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220180613466.png" alt="image-20211220180613466"></p>
<p><strong><font color=#ff00>所有的微指令都存储在控制存储器中</font></strong><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220180731607.png" alt="image-20211220180731607"></p>
<p><strong>上面的流程发生在一个时钟单位内</strong></p>
<p>控制缓冲寄存器的<strong>左半部分</strong>与控制器的控制线相连，发出控制信号，<strong>右半部分</strong>用于为定序逻辑提供下一条地址信息</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220180926089.png" alt="image-20211220180926089"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220181215826.png" alt="image-20211220181215826"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于微程序设计的易实现性，它已经成为CISC控制器的主要技术</p>
</li>
<li class="lvl-2">
<p>而对于RISC，由于指令格式简单，所以一般使用硬布线控制器</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211220181456373.png" alt="image-20211220181456373"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>17 输入输出</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/17%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>17 输入输出</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222144030233.png" alt="image-20211222144030233"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222144607958.png" alt="image-20211222144607958"></p>
<p>外设提供了<strong>外部环境与计算机系统之间的数据交换</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>人可读设备</p>
</li>
<li class="lvl-2">
<p>机器可读设备</p>
</li>
<li class="lvl-2">
<p>通信设备</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222163028529.png" alt="image-20211222163028529"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222163205466.png" alt="image-20211222163205466"></p>
<h2 id="I-O模块">I/O模块</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222163232088.png" alt="image-20211222163232088"></p>
<p><strong>I/O模块属于计算机系统</strong>，但外设是不属于的，通过I/O模块这一<strong>中介</strong>来沟通计算机系统和其他的各种外设</p>
<h3 id="外围设备接口">外围设备接口</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222163613673.png" alt="image-20211222163613673"></p>
<p><strong>状态信息是指外设的状态</strong>，如打印机会有多种不同的状态</p>
<p><strong>转换器</strong>是负责将计算机内的01信号转换成外部的如音频信号等，同时也要把外部的信号如音频信号转换成内部的01信号</p>
<h3 id="功能">功能</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222164149549.png" alt="image-20211222164149549"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222164248293.png" alt="image-20211222164248293"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222164401606.png" alt="image-20211222164401606"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222164451234.png" alt="image-20211222164451234"></p>
<h3 id="结构">结构</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222164524243.png" alt="image-20211222164524243"></p>
<p><strong>控制线传输的是对I/O模块的控制信息</strong></p>
<p>而上面的<strong>状态/控制模块传输的是CPU对外设的控制指令</strong>，如打印等，同时由于CPU传输给外设的控制信息和外设传输回来的状态信息是不会同时出现的，因此<strong>可以复用一个寄存器</strong></p>
<h3 id="外部接口">外部接口</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222165008723.png" alt="image-20211222165008723"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>并行接口</p>
</li>
<li class="lvl-2">
<p>串行接口</p>
</li>
</ul>
<p>总线上的数据都是多位同时传输的。</p>
<p>但对于外部的数据传输，并行传送要求上面每一根线的数据能同时到达。如何实现同时到达：</p>
<ol>
<li class="lvl-3">
<p>减少走的距离（距离长了，不同速度的差异会放大）：<strong>那么数据传输线不能太长</strong></p>
</li>
<li class="lvl-3">
<p>两批数据之间的传输间隔增大：<strong>那么数据传输的频率会降低</strong></p>
</li>
</ol>
<p>因此外部的数据传输入<strong>大多采用串行接口</strong>，虽然<strong>一次只传输一位</strong>，<strong>但可以以很高的频率传输，同时可以传输得非常远。</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222165634136.png" alt="image-20211222165634136"></p>
<h2 id="I-O操作技术">I/O操作技术</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222171452996.png" alt="image-20211222171452996"></p>
<p>这里的不需要处理器干涉是指<strong>数据交换的过程不需要处理器的干涉</strong>，但对于I/O的整个过程，一定是需要处理器的参与的（事实上，没有什么是处理器不管的）</p>
<h3 id="编程式I-O">编程式I/O</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222171755899.png" alt="image-20211222171755899"></p>
<p>数据<strong>先传输到CPU，再由CPU来把数据写入主存中</strong></p>
<p><strong>CPU始终在参与整个I/O过程，要判断I/O设备的状态是否为就绪</strong></p>
<h4 id="I-O命令">I/O命令</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222172128415.png" alt="image-20211222172128415"></p>
<p><strong>命令是对I/O设备的</strong></p>
<h4 id="I-O指令">I/O指令</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222172212631.png" alt="image-20211222172212631"></p>
<p><strong>指令是对CPU的</strong>，需要CPU去执行的指令</p>
<p>编址方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>存储器映射式I/O：即把I/O设备也当作一个地址，和其他存储单元地址一样统一在一起，访问这个地址就是去调用I/O设备，可以方便的编程。但会占用存储单元的地址空间</p>
</li>
<li class="lvl-2">
<p>分离式I/O：总线上有专门的输入输出线，不与存储器的线共用</p>
</li>
</ul>
<h3 id="中断驱动式I-O">中断驱动式I/O</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222172705302.png" alt="image-20211222172705302"></p>
<p>中断驱动式<strong>解决的是在等待就绪时所消耗的时间</strong>（但读取数据并写入内存的时间是两种模式都必要的）</p>
<p><strong>等待外设的状态交给I/O模块去做了，当得到状态时就发起一个中断，告诉CPU</strong>，CPU处理中断，即执行数据的传送，完成后再恢复中断前的指令执行</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222173126368.png" alt="image-20211222173126368"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222173354244.png" alt="image-20211222173354244"></p>
<h4 id="中断允许和禁止">中断允许和禁止</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222173458206.png" alt="image-20211222173458206"></p>
<p><strong>响应了中断后就会禁止中断</strong>，因为<strong>此时要保存现场</strong>，现场信息不能一次就保存完，涉及多条指令，需要多个指令周期，在这期间，是不允许又有新的中断请求的，避免出错</p>
<p>同理中断处理完要<strong>恢复现场</strong>时，也要禁止中断</p>
<p><strong>而在中断处理过程中，是允许中断的</strong>，如果此时有新的中断，那么也<strong>可以响应中断</strong>，但不是必须，要考虑中断的优先级</p>
<h4 id="响应-处理优先级">响应/处理优先级</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222173920550.png" alt="image-20211222173920550"></p>
<p><strong>在有多个中断时，会首先去响应响应优先级最高的，但最后能被处理的中断是处理优先级最高的</strong></p>
<blockquote>
<p>在同时来的一批中断中，CPU只会看到<strong>处理优先级（不是响应优先级）比当前高的中断</strong>（<strong>对相同或者低优先级的视而不见</strong>），在这些高的中断中，处理器会首先去响应响应优先级高的，但最后能拿到处理权限的是处理优先级最高的</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222175024998.png" alt="image-20211222175024998"></p>
<p><strong>掩码字/屏蔽字</strong>是根据处理优先级看这个中断能够屏蔽哪些中断，1表示能屏蔽，这一行的中断能屏蔽哪些列的中断（<strong>行屏蔽列</strong>）</p>
<p>因此，从处理优先级的角度，<strong>主程序的优先级是最低的</strong>，否则中断就没有意义了（有些中断得不到响应）</p>
<blockquote>
<p>先禁止中断，保存现场，为L3的处理做好准备。接下来就是处理中断，先中断允许，正准备去处理L3，但此时发现了L4的中断，那么又要保存现场，进而处理L4，处理完L4，就应当把L3的现场恢复，从而去执行L3的处理</p>
<p>而在其他如L1、L3、L2的中断处理中，因为之前保存的是主程序的现场，所以要恢复主程序的现场，因此此时正要执行主程序的指令，但中断判断时，发现又有中断，因此不执行主程序而是去响应中断</p>
</blockquote>
<p><strong>可以用栈来理解，从哪里来，到哪里去</strong></p>
<h4 id="设备识别">设备识别</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222180749094.png" alt="image-20211222180749094"></p>
<h4 id="分配优先级">分配优先级</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222180903441.png" alt="image-20211222180903441"></p>
<h3 id="直接存储器存取">直接存储器存取</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222192851958.png" alt="image-20211222192851958"></p>
<p>在前两种方式中，数据都需要经过CPU<strong>才能存储到主存中或者从主存中读出</strong>，因为CPU才具有控制权</p>
<p>用<strong>DMA模块</strong>来代替CPU转运数据</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222193302934.png" alt="image-20211222193302934"></p>
<p>当采取DMA模块时，主存就要<strong>同时处理DMA和CPU对主存访问的请求，可能会产生冲突</strong>。</p>
<p>这时应当<strong>以DMA优先</strong>，因为DMA连接的是高速的I/O，如果不能及时把数据存入主存，那么就可能导致数据被冲刷掉</p>
<p>因为是把任务交给DMA来做，所以需要交代很多的信息给DMA，因此会花比较多的时间，最后读写完成时CPU也要有一些处理，<strong>因此在开始和结束时都会一定的时间开销，而在中间过程中CPU无需去管，数据的传输都交给DMA</strong></p>
<h4 id="DMA内存访问">DMA内存访问</h4>
<h5 id="CPU停止法">CPU停止法</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222193948940.png" alt="image-20211222193948940"></p>
<p><strong>一次I/O中的</strong>数据不一定是连续地从I/O传输过来的，而是<strong>一波一波的传输过来的</strong>，即中间会有空闲，但此时主存的访问权限仍在DMA上，<strong>会造成浪费</strong></p>
<h5 id="周期窃取-周期挪用">周期窃取/周期挪用</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222194310204.png" alt="image-20211222194310204"></p>
<p>周期窃取是<strong>适用于数据块不是一次性全部传送过来的</strong>，如键盘，当有传送时DMA模块就请求总线，当没有时就把总线交给CPU</p>
<h5 id="交替分时访问">交替分时访问</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222194419344.png" alt="image-20211222194419344"></p>
<p>交替分时访问是固定了一个时间段，前面由CPU访问，后面由DMA访问，因此DMA不需要请求总线</p>
<p>需要满足一个前提，CPU每次处理完指令的时间内，主存不仅能把数据提供出去，还可以满足DMA的数据传送的需求</p>
<h4 id="DMA配置机制">DMA配置机制</h4>
<h5 id="单总线分离DMA">单总线分离DMA</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222194735618.png" alt="image-20211222194735618"></p>
<p>这种方式就是把编程式I/O中CPU的任务分离出来给了DMA，其他基本没有改动</p>
<h5 id="单总线集合的DMA-I-O">单总线集合的DMA-I/O</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222194918391.png" alt="image-20211222194918391"></p>
<p><strong>DMA与I/O的连接不通过总线，而是把I/O作为DMA的一个部分，通过单独的线来通讯</strong></p>
<p>这样会带来成本的上升，要为每个/多个I/O配备一个DMA，而当这个I/O没有任务时，对应的DMA就是闲置的</p>
<h5 id="I-O总线">I/O总线</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222195159331.png" alt="image-20211222195159331"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222195237853.png" alt="image-20211222195237853"></p>
<p>只有在连续读写时才交给DMA，<strong>而其他时候仍然是CPU在处理</strong>，因此CPU仍然有很高的参与度，仅仅是无需CPU负责存储器和I/O模块之间的数据传递</p>
<h2 id="I-O模块的演变">I/O模块的演变</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222195415943.png" alt="image-20211222195415943"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>I/O模块有了自己的处理器就叫做I/O通道</p>
</li>
<li class="lvl-2">
<p>I/O模块有了自己的局部存储器就叫做I/O处理器</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211222195715027.png" alt="image-20211222195715027"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2 计算机的顶层视图</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>2 计算机的顶层视图</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909141552837.png" alt="image-20210909141552837"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909142008485.png" alt="image-20210909142008485"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105151814210.png" alt="image-20220105151814210"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105151913519.png" alt="image-20220105151913519"></p>
<h2 id="CPU">CPU</h2>
<p>利用系统总线把各个部分连接起来</p>
<p>数据和指令存储在一起，存储器只需要按位置寻址，而无需去考虑其中的数据类型</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909144340448.png" alt="image-20210909144340448"></p>
<p>如I/O设备可以使得程序中断，因此CPU可以大胆去做其他的事情，因为I/O设备可以使得其他事情中断，从而继续处理待I/O输入后才发生的事情（如add），这样可以增大CPU的利用率，避免了CPU在等待I/O的过程中空闲</p>
<p><strong>为什么要禁止中断？</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909144638643.png" alt="image-20210909144638643"></p>
<h2 id="存储器">存储器</h2>
<p>内存（主存）。内存又分为随机读写存储器（RAM）和只读存储器（ROM）。前者主要用于大容量内存储器和调整缓冲存储器；后者用于存放专用的固定程序，如BIOS</p>
<p>外存（辅存）。外存包括硬盘、磁盘、磁带、光盘和U盘等，特点是容量大、价格低，但存取速度较低。磁盘是最常用的外存，一般分为软磁盘和硬磁盘两类</p>
<p><strong>外存不是冯诺依曼结构中的存储器</strong>，而是属于计算机外的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909151708072.png" alt="image-20210909151708072"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909152123388.png" alt="image-20210909152123388"></p>
<p>cache在主存和CPU之间，容量小，速度快（接近CPU），把CPU需要在主存中获取的数据先放在cache中，这样CPU需要数据时可以快速提供。从而解决了内存墙的问题</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909153134834.png" alt="image-20210909153134834"></p>
<h2 id="I-O">I/O</h2>
<p>冯诺依曼结构中的I/O不是I/O设备，如鼠标键盘，而是<strong>I/O模块</strong>，如USB接口，是帮助计算机系统与外界进行信息交换的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909154127490.png" alt="image-20210909154127490"></p>
<p>采用缓冲区来解决数据传输速度时快时慢的问题，如数据太少了就先放在缓冲区，等数据量较大时一起输入</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909154609403.png" alt="image-20210909154609403"></p>
<h2 id="总线">总线</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105154039892.png" alt="image-20220105154039892"></p>
<p>问题：计算机部件互连复杂</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909154935686.png" alt="image-20210909154935686"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210909155043045.png" alt="image-20210909155043045"></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105154430876.png" alt="image-20220105154430876"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3 数据的机器级表示</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/3%20%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>3 数据的机器级表示</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211218090244930.png" alt="image-20211218090244930"></p>
<span id="more"></span>
<h2 id="信息的二进制编码">信息的二进制编码</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210914164832038.png" alt="image-20210914164832038"></p>
<p>编码：用<strong>少量简单</strong>的<strong>基本符号</strong>对<strong>复杂多样</strong>的<strong>数据</strong>进行一定规律的组合。</p>
<p>采用二进制的原因：</p>
<ol>
<li class="lvl-3">
<p>多种物理器件可以表示为两种稳定的状态，如开和关</p>
</li>
<li class="lvl-3">
<p>二进制的规则简单</p>
</li>
<li class="lvl-3">
<p>二进制的0和1可以对应逻辑运算中的真和假</p>
</li>
</ol>
<p>用离散有限的数据去表示连续无限的数据，必然会产生偏差</p>
<h2 id="整数的二进制表示">整数的二进制表示</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210914171400831.png" alt="image-20210914171400831"></p>
<p>对于<strong>无符号整数不存在各种码的问题</strong>。各种码是用来解决如何表示带符号数的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105164323076.png" alt="image-20220105164323076"></p>
<p><strong>补码表示的数，不必关心其符号而可以直接相加</strong>，即对应机器不关心数据到底是无符号数还是带符号数</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105170903478.png" alt="image-20220105170903478"></p>
<p>补码的最高位符号位，<strong>如果是0那么和无符号一样，如果是1，那么就需要-2<sup>n-1</sup>，才是真正的值</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105171042276.png" alt="image-20220105171042276"></p>
<p>补码移码都只有一个0，而原码和反码中有两个0</p>
<blockquote>
<p>反码跟原码是正数时，一样；负数时，反码就是原码符号位除外，其他位按位取反</p>
</blockquote>
<p><strong>当移码的偏置常数为2<sup>n-1</sup>时，移码和补码仅第一位不同</strong></p>
<h2 id="浮点数的二进制数表示">浮点数的二进制数表示</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105171706899.png" alt="image-20220105171706899"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105171859823.png" alt="image-20220105171859823"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105172415066.png" alt="image-20220105172415066"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105172521518.png" alt="image-20220105172521518"></p>
<p><strong>精度和范围的大小是相互矛盾的</strong>，因为k位二进制数最多只能表示2<sup>k</sup>个数字，因此范围大精度就小</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105172626111.png" alt="image-20220105172626111"></p>
<p>由上图可见，在两个阶码之间，能表示的数字个数为2<sup>23</sup>个，而随着阶码变大，<strong>这个区间变大，所以数字的精度会变小</strong>。</p>
<p>非规格化数把阶码全0用于表示0~2<sup>-126</sup>之间的数字，和上面同理<strong>这个区间的长度是2<sup>-126</sup>-0=2<sup>-126</sup></strong>，<strong>而2<sup>-126</sup>~2<sup>-125</sup>之间的长度也是2<sup>-126</sup></strong>，因此在这<strong>两个区间内都可以均匀地表示2<sup>23</sup>个数字</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105173227836.png" alt="image-20220105173227836"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105173456901.png" alt="image-20220105173456901"></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105173947144.png" alt="image-20220105173947144"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>6 浮点数运算</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/6%20%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>6 浮点数运算</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106111044394.png" alt="image-20220106111044394"></p>
<span id="more"></span>
<h2 id="加法和减法">加法和减法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106111118500.png" alt="image-20220106111118500"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106111144297.png" alt="image-20220106111144297"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106111200885.png" alt="image-20220106111200885"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106111738061.png" alt="image-20220106111738061"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106111922628.png" alt="image-20220106111922628"></p>
<h2 id="乘法">乘法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106112054244.png" alt="image-20220106112054244"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106112148801.png" alt="image-20220106112148801"></p>
<p>这里是原码乘法，因此右移补0，注意原码乘法中符号位不参与运算，而是<strong>通过异或得到结果的符号位</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106113144292.png" alt="image-20220106113144292"></p>
<h2 id="除法">除法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106113216775.png" alt="image-20220106113216775"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106113328635.png" alt="image-20220106113328635"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106113715022.png" alt="image-20220106113715022"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106113744626.png" alt="image-20220106113744626"></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106113854572.png" alt="image-20220106113854572"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4 数据校验码</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/4%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>4 数据校验码</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105193631099.png" alt="image-20220105193631099"></p>
<span id="more"></span>
<h2 id="差错error">差错error</h2>
<p>以存储为例：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬故障：永久性物理故障</p>
</li>
<li class="lvl-2">
<p>软故障：随机非破坏性事件，改变了某些内容，但没有损坏机器</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220105195420473.png" alt="image-20220105195420473"></p>
<h2 id="纠错error-correction">纠错error correction</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925101417978.png" alt="image-20210925101417978"></p>
<p>注意，C’'不是和C去比较，<strong>因为既然D有可能出现差错变成D’，那么与之相应的校验码C也可能差错</strong>，因此，取出来的不是C，而是C‘，是将用D’生成的C‘’去和取出来的C‘比较</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925102425592.png" alt="image-20210925102425592"></p>
<p>一旦D存进存储器/网络，那么原来的D就消失了，取出来的就是D’。（<em>如果能保证存进去和取出来的是一样的，那么也就不存在纠错</em>，<strong>事实上，这是无法保证的</strong>）</p>
<h2 id="奇偶校验码">奇偶校验码</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925103619330.png" alt="image-20210925103619330"></p>
<p>奇校验码：如果有奇数个1，那么C=0，否则为1</p>
<p>偶校验码：如果有偶数个1，那么C=0，否则为1</p>
<p>（理解：<strong>把原来的数据和这个校验码拼在一起时应当还是和校验码名字中的奇偶一致</strong>，所以奇校验码当1为奇数，C=0，那么拼在一起还是奇数个）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925110201147.png" alt="image-20210925110201147"></p>
<p>当数据D中<strong>出错的位数为偶数</strong>时，那么1的个数的奇偶性仍然是不变的，因此校验码不变</p>
<p><strong>因此奇偶校验码适用于较短的数据进行检错</strong>，这样出现<strong>多位错的概率相对较小</strong>，检错的效果较好（当然还是会有可能出现多位错误，但概率很小）</p>
<p>代价很低，<strong>只需要1位</strong>即可</p>
<blockquote>
<p><strong>发现错误比发现后纠正更难</strong>，因为如果发现了，那么纠正也就是把0变成1，1变成0就好了，相对找到错误更为简单</p>
</blockquote>
<p>##　海明码</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925111310238.png" alt="image-20210925111310238"></p>
<p>分组的时候要求任何两位所属的组的情况都是不一样的，同时一位数据可能会属于若干个小组（<strong>至少两个组</strong>，与下面的故障字规则一致，否则如果只一个组的话，会和校验码出错冲突）</p>
<p><font color=#FF0000><strong>前提假设：最多一位发生错误</strong></font></p>
<p>奇偶校验码是海明码的基础</p>
<p>利用的原理就是校验码出错的几个所在小组中公共的那一位就是出错的位，这样就<strong>能够定位到错误</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925112636796.png" alt="image-20210925112636796"></p>
<p>因为K位校验码可以表示2^K种情形，而出错的情形为M+K+1，因此可以求出K的最小值</p>
<p>由表格可见，随着数据位的增加，最小校验码的位数增加较少，所占比例较小</p>
<p>但是不能通过把M的位数设成很大，来使得校验码的的位数相对少，<strong>因为如果数据位数很大，则只发生一位错误的假设就不成立了</strong></p>
<p>因此要实现一个<strong>平衡</strong>：<strong>海明码有效且所占比例较少</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925113559485.png" alt="image-20210925113559485"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925114223953.png" alt="image-20210925114223953"></p>
<p><strong>先把故障字分配给每一位数据位故障，然后再进行分组，把这一个Dn放到故障字中数值为1的那一位所对应的组中</strong>，如上，D8对应故障字1100，那么D8应当分到C1和C2组中去</p>
<p>故障字从0001开始分配，因为0000已经用于表示没有发生故障</p>
<p>这里C的计算用的是偶校验（当然奇校验也行）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925115343889.png" alt="image-20210925115343889"></p>
<p>注意：<strong>存储时是按上面表格的顺序来存储的</strong>，而不是D8D7……D1C4……C1（<em>上图蓝色的表示校验码，黑色表示数据</em>）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211219093628238.png" alt="image-20211219093628238"></p>
<p><strong>将计算出的C‘’与C‘异或，那么就可以得到故障字</strong>，从而定位到出错的是哪一位</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925120406447.png" alt="image-20210925120406447"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925120449107.png" alt="image-20210925120449107"></p>
<blockquote>
<p>主存的实际容量比用户可以使用的容量要<strong>大</strong>，因为对于存储的数据，<strong>也是可能会发生错误的</strong>，因此需要去添加纠错码，如磁盘中就有纠错区，之后的区域才是数据区等</p>
</blockquote>
<p><strong>加强版的海明码</strong></p>
<hr>
<h2 id="循环冗余校验">循环冗余校验</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925120653073.png" alt="image-20210925120653073"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925120852514.png" alt="image-20210925120852514"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925121203909.png" alt="image-20210925121203909"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211219095317053.png" alt="image-20211219095317053"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当<strong>余数位数与除数位数相同</strong>时，才进行异或运算（模二除法），<strong>即与除数对齐的第一位为1时才异或并上商为1，否则不进行异或直把除数右移并上商为0</strong>了，直到被除数最后一位</p>
</li>
</ul>
<p>如果这两个 CRC结果不一致，则说明发送中出现了差错，接收方计算机可要求发送方计算机重新发送该数据</p>
<p>CRC 算法检验的检错能力极强，且检测成本较低</p>
<p>因而，CRC 成为计算机信息通信领域最为普遍的校验方式</p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210925121237083.png" alt="image-20210925121237083"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5 整数运算</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/5%20%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>5 整数运算</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211218090925893.png" alt="image-20211218090925893"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211218090935971.png" alt="image-20211218090935971"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928164942515.png" alt="image-20210928164942515"></p>
<p><strong>异或门是不能多个一起输入的</strong>，只能两两。a⊕b = (¬a ∧ b) ∨ (a ∧¬b)，由此推断，非门的门延迟也为1ty</p>
<p><strong>而与和或则可以多个一起输入</strong>，因为如或门，只要有一个1 ，那么结果就是1，与门，只要有一个0，那么结果都是0</p>
<h2 id="串行进位加法器">串行进位加法器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928165948285.png" alt="image-20210928165948285"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928170122630.png" alt="image-20210928170122630"></p>
<p>之所以s=x⊕y⊕c，把x和y先做异或，是为了节省时间，因为c需要由前面的数据得到，如上，C<sub>n</sub>的延迟是2n ty，因此可以提前把x<sub>n</sub>⊕y<sub>n</sub>计算好，等C<sub>n-1</sub>计算好后再和C<sub>n-1</sub>异或，因此Sn的延迟为2(n-1)+3=2n+1</p>
<p>（<strong>但第一和第二位除外，它们的延迟都是6</strong>，因为得到C<sub>1</sub>为2，而此时X<sub>2</sub>和Y<sub>3</sub>还没有异或就绪，所以仍然是S<sub>2</sub>的延迟仍是6。C<sub>2</sub>的延迟是4&gt;3，因此X<sub>3</sub>和Y<sub>3</sub>已经异或完成，在等C<sub>2</sub>）</p>
<p>（<strong>所有的A<sub>i</sub>和B<sub>i</sub>是同时输入的，等到C<sub>i-1</sub>到来时，除了最低2位，A<sub>i</sub>和B<sub>i</sub>已经通过了异或门，因此这个3ty的时间延迟不算，而只用考虑与C<sub>i-1</sub>的异或</strong>）</p>
<h2 id="全先行进位加法器">全先行进位加法器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928172853824.png" alt="image-20210928172853824"></p>
<p>把C都换掉代入，形成这些式子</p>
<p>C<sub>i-1</sub>=1，P<sub>i</sub>=1则表示能把这个C<sub>i-1</sub>的1传递到C<sub>i</sub></p>
<p>只有X<sub>i</sub>和Y<sub>i</sub>都是1，G<sub>i</sub>才为1，G<sub>i</sub>表示这位能不能自己生成1</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928173321855.png" alt="image-20210928173321855"></p>
<p>第一步把P和G都计算出，需要1ty</p>
<p>第二步根据式子把C全部计算出，因为式子中只有与和或，因此与可以一起进行，或可以一起进行，所以只要2ty</p>
<p>在第一步和第二步进行的过程中，同时在进行第三步X⊕Y，刚好3ty，<strong>因此第一第二和第三步是同时进行的</strong></p>
<p>所以第四步就是进行（X⊕Y）⊕C计算出S，需要3ty</p>
<p>因此总共需要1+2+3=6ty</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928174916195.png" alt="image-20210928174916195"></p>
<h2 id="部分先行进位加法器">部分先行进位加法器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928174424653.png" alt="image-20210928174424653"></p>
<p>每8位用CLA（全先行进位加法器），整体用串行进位加法器，在时间和空间内得到平衡</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210928175133879.png" alt="image-20210928175133879"></p>
<p>最后的5是=2+3，第4个CLA要进行第二步2ty和第四步3ty，所以是5ty，当最后一个计算完成时，前面的已经计算完了，所以全部计算好了</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003094155887.png" alt="image-20211003094155887"></p>
<p><strong>两个数加的补码是两个数补码的和</strong></p>
<p>溢出的两种判定：</p>
<ol>
<li class="lvl-3">
<p>加数符号相同而和不同（若符号不同不可能溢出）</p>
</li>
<li class="lvl-3">
<p>Cn异或Cn-1</p>
</li>
</ol>
<h2 id="减法">减法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003094430337.png" alt="image-20211003094430337"></p>
<h2 id="乘法">乘法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003095101641.png" alt="image-20211003095101641"></p>
<p>计算机只能进行两两相加，因此<strong>每一步都把部分积求和</strong></p>
<p>如下图，参与运算的是红色的部分，通过右移保证高4位是参与运算的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003095842388.png" alt="image-20211003095842388"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003101651095.png" alt="image-20211003101651095"></p>
<p>刚开始积为n为0，在乘的过程中，部分积的长度会慢慢变长，最终变成2n</p>
<p>但这样的话，2n位的右边n位会空着，会产生浪费，因此把右边n位用来存放乘数Y，这样Y的一位乘完后，右移空出来的位置就可以给积用，如上图，<strong>左边一半是乘积寄存器，右边一半是乘数寄存器</strong></p>
<p><strong>加了之后再右移</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003101951588.png" alt="image-20211003101951588"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003102110215.png" alt="image-20211003102110215"></p>
<p><strong>上面的乘法只适用于原码。</strong></p>
<p>补码不能用于乘法，要用原码去乘，再把积用补码表示，<strong>但这样很麻烦，会消耗大量的计算资源</strong>。</p>
<p>因此出现了布斯乘法，可以用于补码的乘法</p>
<h3 id="布斯乘法">布斯乘法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003102745966.png" alt="image-20211003102745966"></p>
<p>在第四行中，为了保证式子的统一性，引入Y<sub>0</sub>=0</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003102848122.png" alt="image-20211003102848122"></p>
<p>2的-1次方即右移一位，与原来的乘法不同的地方就在绿色框中，原来是Y<sub>i+1</sub>，现在是Y<sub>i</sub>-Y<sub>i+1</sub>（<strong>i从0开始，Y<sub>0</sub>=0</strong>），这样，<strong>就可以适用于补码的乘法运算了</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003103243188.png" alt="image-20211003103243188"></p>
<p>因为是Y<sub>i</sub>-Y<sub>i+1</sub>，相比于原来多了一种可能性**+X，-X，+0**</p>
<p>一共n位，所以要进行n次</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003103612562.png" alt="image-20211003103612562"></p>
<p>因为这里可以处理<strong>补码整数，所以会出现负数的情况</strong>，如果右移补零那么会无论乘数如何，最后符号位总是0，即总是正数。而对于原来只能处理原码的情况，是不会出现负数的，因此始终是补零</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003104513678.png" alt="image-20211003104513678"></p>
<p>因此在布斯乘法用于处理补码整数乘法时，右移应当是<strong>算术右移，符号拓展</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003104844369.png" alt="image-20211003104844369"></p>
<h2 id="除法">除法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003104912664.png" alt="image-20211003104912664"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003105359117.png" alt="image-20211003105359117"></p>
<p>补充符号位直到<strong>除数最高位和余数的次高位对齐</strong></p>
<p><strong>因此即拓展除数位数长度的符号</strong></p>
<p>要把4位的被除数<strong>符号拓展成8位</strong>，因为最终结果商应当是4位的</p>
<p>余数实际上是2n位，但只有低n位有用，因此余数只取低n位</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003105722654.png" alt="image-20211003105722654"></p>
<h3 id="恢复余数除法">恢复余数除法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003110508948.png" alt="image-20211003110508948"></p>
<p>实际上只有n位参与运算，但为了实现移位操作，用了2n位，因此造成了浪费，同样可以类比乘法来充分利用空间</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003110809081.png" alt="image-20211003110809081"></p>
<p><strong>把除数右移的操作，改成了余数左移的操作，左移右边空出来的就作为商</strong>，这样余数同样也只要四位即可</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003110958423.png" alt="image-20211003110958423"></p>
<p>判断够不够减，是根据<strong>余数的左边四位</strong>来比较的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003111354476.png" alt="image-20211003111354476"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>余数减去除数后，余数符号不发生改变，那么就是够减的</strong></p>
</li>
<li class="lvl-2">
<p><strong><font color =#FF00>要使得余数的绝对值不断变小，并且符号不改变</font></strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003111751337.png" alt="image-20211003111751337"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003113300997.png" alt="image-20211003113300997"></p>
<p><strong>最后如果除数和被除数的符号不同，那么要将商变成相反数，即取反加一</strong></p>
<p><strong>没有办法事先去判断够不够减，因此只能运算后看符号有没有变</strong>，因此对于机器来说，尝试运算后，发现不够减，<strong>那么要恢复余数</strong></p>
<p>当商为4位时，达到所需精度，就运算完成，留下了余数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>有没有可能左移的过程中符号变号了，如果有，那么余数的符号到底应该以那个为准**?**</p>
</li>
<li class="lvl-2">
<p>我认为不会移出，如32位cpu中，除数和被除数都是32位，为了得到32位的商，应当把32位被除数符号拓展成64位，而总共运算n=32次，因此不会移出符号位，<strong>因此在这个过程中，符号一定不会发生改变，因此发生改变说明不够减，那么需要恢复</strong></p>
</li>
</ul>
<h3 id="不恢复余数的除法">不恢复余数的除法</h3>
<p>类似开车，当车偏离直线时，不会退回去变成直线，而是往右偏来纠正</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003113412552.png" alt="image-20211003113412552"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>乘2是左移</strong></p>
</li>
<li class="lvl-2">
<p><strong>这里的余数R<sub>i</sub>是不论是否够减了，都减去Y得到的</strong></p>
</li>
<li class="lvl-2">
<p>只考虑减法（当然有可能是加法，余数和除数异号时）：</p>
<ul class="lvl-2">
<li class="lvl-4">如果不够减，不需要在上一步进行恢复，而是在下一步通过加Y来<strong>同时实现上一步的恢复和这一步的减Y</strong></li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211218230006824.png" alt="image-20211218230006824"></p>
<p><strong><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003114022720.png" alt="image-20211003114022720"></strong></p>
<p><strong>第一次没有左移，是多一位商放在后面</strong></p>
<p>然后再看余数和除数符号是否相同</p>
<p>同样运算n次</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003114435963.png" alt="image-20211003114435963"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211218231331207.png" alt="image-20211218231331207"></p>
<p>最后还需要对整除可能出现的问题进行判断（原因是如果发生整除，0的符号是0，会产生错误的判断）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果余数+除数=0，说明多减去一个除数，所以商要-1，余数置0</p>
</li>
<li class="lvl-2">
<p>如果余数=除数，说明少减去一个除数，所以商要+1，余数置0</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003171509243.png" alt="image-20211003171509243"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003115033240.png" alt="image-20211003115033240"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211003115057588.png" alt="image-20211003115057588"></p>
<h2 id="原码加减法理解">原码加减法理解</h2>
<ol>
<li class="lvl-3">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-5">符号位不作为数的一部分参与运算</li>
<li class="lvl-5">符号位和加减法指令共同作为运算的依据</li>
</ul>
</li>
<li class="lvl-3">
<p>规则</p>
<ul class="lvl-2">
<li class="lvl-5">加法指令：同号求和，异号求差</li>
<li class="lvl-5">减法指令：异号求和，同号求差</li>
</ul>
</li>
<li class="lvl-3">
<p>对于求和：</p>
<ul class="lvl-2">
<li class="lvl-5">两个操作数相加得到的数值位，如果数值位最高位产生进位，则结果溢出</li>
<li class="lvl-5">若不溢出，则和的符号位采用<strong>第一操作数的符号</strong></li>
</ul>
</li>
<li class="lvl-3">
<p>对于求差：第一操作数的数值位<strong>加上</strong>第二操作数数值位的补码</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>最高数值位有进位，表明加法结果为正，结果符号位采用第一操作数的符号</p>
</li>
<li class="lvl-5">
<p>最高数值位没有进位，表明结果为负（补码形式），应对结果求补码，还原成原码形式，结果的符号位为第一操作数的符号取反</p>
</li>
<li class="lvl-5">
<p><strong>理解</strong>：事实上，是通过加模再减模（2^k）的方式把减法转成加法，因此如果加后最高位有进位，那么结果减去模就仍然是正数，那么直接取n位结果即可，最高位的进位截断（或者理解为减去了模，因此这个1被减去了）</p>
<p>如果没有进位，那么说明结果减去模是负数，那么res-2<sup>k</sup>就不够减，那么就提个负号出来变成-(2<sup>k</sup>-res)，括号里面自然就是取反加1，同时外面的负号用于把第一操作数的符号位取反</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1 词法分析</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1>1 词法分析</h1>
<p>语法分析器会按需向词法分析器索要token</p>
<p>输入一个字符串，要输出词法单元流。</p>
<p>但仅仅是字符串是不够的，还需要一个隐含的且是最重要的输入：<strong>词法单元（Token）的规约</strong></p>
<blockquote>
<p>需要有一个语言来描述每次词法单元的结构，比如要从字符串中识别出ID，那必须要知道这个ID的结构才行。词法单元（Token）的规约就是完成这样的工作</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114153952664.png" alt="image-20221114153952664"></p>
<span id="more"></span>
<h3 id="词法分析器的设计方法">词法分析器的设计方法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114155150098.png" alt="image-20221114155150098"></p>
<h4 id="使用词法分析器生成器">使用词法分析器生成器</h4>
<p>给<code>Antlr</code>输入词法单元的规约（<code>.g4文件</code>），<code>Antlr</code>作为词法分析器生成器就可以生成一个词法分析器算法，比如 <code>Lexer.java</code> (也支持生成其他语言的)</p>
<p>对于 <code>Lexer.java</code>，编译执行后，就可以输入字符串，从而输出字符流(string of  token)</p>
<p>因此 <code>Antlr</code> 帮我们完成了生成词法分析器的过程，我们只需要写一个 <code>.g4</code> 文件来描述每一个词法单元的结构是什么样子的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114160241918.png" alt="image-20221114160241918"></p>
<h4 id="手写词法分析器">手写词法分析器</h4>
<p>即上面的过程中的 <code>.java</code> 文件的生成需要我们自己来完成或者说需要我们自己编写词法分析器的源代码</p>
<h4 id="自动化词法分析器">自动化词法分析器</h4>
<p>相当于写一个 <code>Antlr</code>，因为在词法分析器的生成过程中，很多步骤都是机械化的，其实可以使用自动化来实现</p>
<hr>
<p>在生产环境中通常选择手写词法分析器，自由度更大，效率可能更高，且便于控制复杂度，如 <code>gcc</code> （左边为 <code>C</code> 语言的词法分析器，右边为 <code>C++</code> 的词法分析器）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114155555537.png" alt="image-20221114155555537"></p>
<p>目前如 <code>Antlr</code> 这类的词法分析器生成器生成的词法分析器已经能够和手写相媲美，因此使用第一种方式也是没有问题的</p>
<h2 id="代码">代码</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114160842879.png" alt="image-20221114160842879"></p>
<p>第一行 <code>grammar SimpleExpr</code>，需要和该 <code>.g4</code> 文件的名字一样</p>
<p><code>prog</code> （program）描述用这个语言写成的程序的最高层的语法结构，称为语法规则名 。在 <code>.g4</code> 文件中语法规则名要求以小写字母开头</p>
<p><code>stat</code> （statement）表示语句</p>
<p>因此第 4 行表示这个语言写成的程序是由 0 个或多个语句构成的（当然此时语句还没定义）</p>
<p>【*的语法和正则表达式一样】</p>
<p>后面的 <code>EOF</code> 的含义是一个程序前面必须是由 0 个或多个语句构成的，紧接着最后就是文件结束符了，<strong>不能有其他的非语句内容</strong>【如果不加 <code>EOF</code>，那么最后可以有非语句的内容，而仍然被编译器认为是正确的】</p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114162602684.png" alt="image-20221114162602684"></p>
<p>ID 已经不能再用语法来表示了，它是一个词法单元了，词法单元需要用大写字母开头，一般全部写成大写</p>
<p>if 也是词法单元，但比较特殊，是一个字面量，意思是 if 自己就作为词法单元的一类，而 ID 则包含很多的类型。【+ * 同理】</p>
<blockquote>
<p><code>Antlr</code> 通过将字面量隐式的表示成词法单元，如 Token0 ： ‘if’，并将这些隐式的词法单元写在我们自己定义的词法单元的前面，优先级都比显式的词法单元高，这样当发现 if 时会优先匹配前面的词法单元，而不是把它认为是一个 ID</p>
</blockquote>
<p>但是隐式的表示有时会让我们产生误解，不利于后续的处理，因此通常都将这些字面量显式地表示出来，使用 <code>alt+insert</code> 快捷键即可生成</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114205120222.png" alt="image-20221114205120222"></p>
<p>这里的 <code>EQUAL</code> 改成 <code>ASSIGN</code> 表示赋值更好</p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114162929446.png" alt="image-20221114162929446"></p>
<p>（）表示子规则</p>
<p>两行的顺序很重要，它代表了运算的优先级</p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114163452458.png" alt="image-20221114163452458"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114163641822.png" alt="image-20221114163641822"></p>
<p>其中 LETTER 和 DIGIT 不属于 Token，只是在定义更复杂的 Token 时的辅助的规则。因此我们要区分它们，即在前面加上 <code>fragment</code>，从而避免识别这两者为 Token</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114163809516.png" alt="image-20221114163809516"></p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114164145811.png" alt="image-20221114164145811"></p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114164256307.png" alt="image-20221114164256307"></p>
<p>WS white space</p>
<p>用 <code>-&gt; skip</code> 表示识别到 WS 就将其跳过</p>
<hr>
<p>到目前为止，就定义了我们这个语言的词法结构</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114164639689.png" alt="image-20221114164639689"></p>
<p>叶子节点就识别出了所有的词法单元</p>
<p>树的层次结构对应小写字母开头的语法规则</p>
<h4 id="增加更多的语法：">增加更多的语法：</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114172956075.png" alt="image-20221114172956075"></p>
<p>单行注释：以 <code>//</code> 开头，必定以 <code>\n</code> 结尾，中的 <code>.</code> 表示通配符，匹配任意字符 0 个或多个</p>
<p>注意写 <code>*</code> 和 <code>+</code> 会导致<strong>贪婪的匹配</strong>，容易出现把// 后面所有的行都当作注释</p>
<p>在 <code>*</code> 后面加上<code>?</code> 即可实现<strong>非贪婪或最小匹配</strong>。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114174530312.png" alt="image-20221114174530312"></p>
<h2 id="其他语法">其他语法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114205329844.png" alt="image-20221114205329844"></p>
<p>使用 <code>@header&#123;&#125;</code>，写在这里面的内容会复制到 <code>java</code> 代码里面</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114205932043.png" alt="image-20221114205932043"></p>
<p>可以把词法单元单独的作为一个文件，与前面的语法单元（prog，stat，expr等）分开放，但需要在开始第一行加上 <code>lexer</code></p>
<p>同时在语法文件中要 <code>import</code> 词法</p>
<p>这样的好处是，可能不同的语言对语法定义不同，但对词法定义是相同，就可以<strong>直接复用</strong></p>
<h2 id="理论">理论</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114210123710.png" alt="image-20221114210123710"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114210528559.png" alt="image-20221114210528559"></p>
<p>语言就是某种能够识别的字符串构成的集合</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114210627920.png" alt="image-20221114210627920"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114210634702.png" alt="image-20221114210634702"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114210708297.png" alt="image-20221114210708297"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114210939682.png" alt="image-20221114210939682"></p>
<p>空集也是一种语言</p>
<p>包含空串的语言和空集是不一样的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114211159261.png" alt="image-20221114211159261"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114211343450.png" alt="image-20221114211343450"></p>
<p>如 <code>*</code> 和 <code>+</code> 就是前面的正则中的<strong>理论支撑</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114213005414.png" alt="image-20221114213005414"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114213145518.png" alt="image-20221114213145518"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114213214619.png" alt="image-20221114213214619"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114213456479.png" alt="image-20221114213456479"></p>
<p>正则表达式不能很好理解，尽可能写成右边的少括号的形式，利用好优先级</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114214039758.png" alt="image-20221114214039758"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114214224877.png" alt="image-20221114214224877"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221114214408261.png" alt="image-20221114214408261"></p>
<p><strong>不同的正则语言的规则是不一样的</strong>，比如上面的 <code>&quot;s&quot;</code> ，但是在 <code>Antlr</code> 中是 <code>'s'</code>；上面 <code>.</code> 匹配除了换行符外的任何字符，而 <code>Antlr</code> 中匹配任何字符；上面用 <code>^</code> 表示不在 s 中的任意一个字符，而在 <code>Antlr</code> 中是 <code>~</code></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>7 二进制编码的十进制数运算</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/7%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>7 二进制编码的十进制数运算</h1>
<p>NCBD码用于解决<strong>精度和范围</strong>之间的矛盾，但代价是数字位数过多<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210914180115014.png" alt="image-20210914180115014"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20210915155218952.png" alt="image-20210915155218952"></p>
<h2 id="加法">加法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211012165334270.png" alt="image-20211012165334270"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对发生10进位的要补上6，如1010为十进制的10，补上0110，就利用16进制的进位实现了十进制的进位</p>
</li>
<li class="lvl-2">
<p>对于红色1，是加法本身已经超过16，发生了进位到前面一位，同样要加6，补上因为进位而丢失的6</p>
</li>
<li class="lvl-2">
<p><strong>即发生了16进制的进位或者值超过9,那么都需要进行补6操作</strong>（其中发生16进制的进位，会出现上面红色的1,这时候补6,一定不会再发生进位.值超过9,不会出现红色的1,但补6后仍然会发生16进制的进位,因此还是会产生红色的1,即两种情况都会进一位到高位）</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211012165939633.png" alt="image-20211012165939633"></p>
<p>如果要超过10，第4位必须是1，第2和第3位中至少有一个是1，因此会有上面的两个与门</p>
<p>两个与后的结果再和高位进位一起通过或门，这样就有3种情况会出现满10进位了，也就要加上0110，即6，所以C4后面有连出两条线给S2，S1</p>
<p>此外只要判断一次就可以了，因为即使是最大的结果19（9+9+1（1来自前一位的进位））加上6后，结果是25，25-16=9，结果9并不会再进位</p>
<h2 id="减法">减法</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211012172909448.png" alt="image-20211012172909448"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106114717172.png" alt="image-20220106114717172"></p>
<p>这里原理和原码计算一样，但是把2<sup>n</sup>改成10<sup>n</sup>，9999……-x+1</p>
<p><strong>先取反再加10和先加6后取反是一样的，均可</strong>，<strong>倾向于先各位加6再取反</strong></p>
<p>如果不够减10<sup>n</sup>，那么就提个负号出来，使得<strong>第一个数的符号位</strong>变反，即res-10<sup>n</sup>变成-(10<sup>n</sup>-res)，这样用取反加1表示即可</p>
<p>如果够减10<sup>n</sup>即产生了高位的进位，那么舍弃进位即可，<strong>符号取第一个数的符号</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211219100203218.png" alt="image-20211219100203218"></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211219100209577.png" alt="image-20211219100209577"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2 手写词法分析器</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2%20%E6%89%8B%E5%86%99%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h1>2 手写词法分析器</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120173533584.png" alt="image-20221120173533584"></p>
<p>要实现的词法分析器需要识别的词法单元</p>
<ol>
<li class="lvl-3">
<p>（红色）关键字，如 <code>if</code> 等自成一个词法单元</p>
</li>
<li class="lvl-3">
<p>（绿色）关系运算符，relop = relation operation，考虑 6 种</p>
</li>
<li class="lvl-3">
<p>（蓝色）标识符 id：由字母和数字组成，且以字母开头</p>
</li>
<li class="lvl-3">
<p>数字：整型、浮点型（是否为指数形式）</p>
</li>
</ol>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120174710291.png" alt="image-20221120174710291"></p>
<p>对于 3.14 不会匹配成 3 为一个 REAL，因为匹配是贪婪的，而是会把 3.14 整体匹配成 REAL</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120175442376.png" alt="image-20221120175442376"></p>
<p><code>Antlr</code> 在不能匹配很长的数字的时候，会返回它能匹配的最长的前缀</p>
<p>比如这里的 123.45E+xyz，先发现 123，匹配整数，又发现 .45，匹配浮点数，再发现 E 匹配带指数的浮点数，但发现 + 后面不是数字，那么会回退到最长能匹配的 123.45，然后继续扫描后面的 E</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120180121624.png" alt="image-20221120180121624"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120180311263.png" alt="image-20221120180311263"></p>
<ol start="3">
<li class="lvl-3">
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120180404210.png" alt="image-20221120180404210"></p>
<hr>
<p>对所有的词法单元进行分组</p>
<p>G0：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120180804408.png" alt="image-20221120180804408"></p>
<p>G1：只需要看一个字符就能知道应该去比较哪个词法单元的规则，因为 ID 和 INT 的开头第一个字符是不一样的（<em>ID ：由字母和数字组成，且以字母开头</em>）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120180824011.png" alt="image-20221120180824011"></p>
<p>G2：需要看两个字符才能确定，比如看到 &lt;，不能确定是 &lt; 还是 &lt;=</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120181002229.png" alt="image-20221120181002229"></p>
<p>G3：需要向前看任意多个字符才能确定是属于哪个类型</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120181156683.png" alt="image-20221120181156683"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120200158451.png" alt="image-20221120200158451"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120200220260.png" alt="image-20221120200220260"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120201337636.png" alt="image-20221120201337636"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120201346107.png" alt="image-20221120201346107"></p>
<p>当状态转移复杂时，直接使用 <code>if-else</code> 会导致多层嵌套以及重复的代码，采用下面这种 <code>switch case</code> 状态来处理会更好</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221120201414961.png" alt="image-20221120201414961"></p>
<p>在上图的状态图中，14、16、17没有其他的状态转移，如果在 14 遇到一个不是数字的字符，没有状态转移，因此不完整</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122120103508.png" alt="image-20221122120103508"></p>
<p>对于这样的式子，在语法上是错误的，但是对于当前的词法分析，只是会最长识别出 123.45，然后把后面的 E 当作 ID。语法上的报错是交给语法分析来做的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122132028095.png" alt="image-20221122132028095"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>8 内部存储器</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/8%20%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>8 内部存储器</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211218091500668.png" alt="image-20211218091500668"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014141312493.png" alt="image-20211014141312493"></p>
<p>原来是32位机器，那么内存一般是4GB，因为2<sup>32</sup>次方就是4GB，再多插内存条也没有用，因为地址最多2<sup>32</sup>个，因此最多就只能区分出这么多的单元</p>
<p>就相当于房间数不能增加了，如果想要增大，那么只能增加房间里可以住的人数，即提高寻址能力</p>
<p>Q：每个计算机所能访问的地址有限？</p>
<p>n长01串决定了2<sup>n</sup>个地址，由计算机的设计决定的，<strong>不由总线（地址线）决定</strong>。eg. 16位的线可以传2次表示32位地址</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014143002582.png" alt="image-20211014143002582"></p>
<p>一个位元是一个bit，有两种状态，用来代表0和1，<strong>至少要能被写入一次，否则不存储信息是没用的</strong></p>
<p>早期的存储器是由磁芯制作的，其原理为：将磁环（磁芯）带磁性或不带磁性之状态，用以代表1或0之比特，磁芯存储器是非易失性存储器(Non-volatile Memory)，即使死机或电源中断，只要没有发生错误的写入信号，则仍然可保有其内容。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014143326652.png" alt="image-20211014143326652"></p>
<h2 id="RAM">RAM</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014143631213.png" alt="image-20211014143631213"></p>
<p>易失的volatile，断电内容丢失</p>
<h4 id="动态随机存取存储器（Dynamic-Random-Access-Memory，DRAM）"><strong>动态随机存取存储器</strong>（<strong>Dynamic Random Access Memory</strong>，<strong>DRAM</strong>）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014144043754.png" alt="image-20211014144043754"></p>
<p>由于这种需要定时刷新的特性，因此被称为“动态”存储器，刷新会影响访问，所以访问速度会变慢</p>
<p><strong>一般用于主存</strong></p>
<h4 id="静态随机存取存储器（Static-Random-Access-Memory，SRAM）"><strong>静态随机存取存储器</strong>（<strong>S</strong>tatic <strong>R</strong>andom-<strong>A</strong>ccess <strong>M</strong>emory，<strong>SRAM</strong>）</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014144411503.png" alt="image-20211014144411503"></p>
<p>所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。当电力供应停止时，SRAM储存的数据还是会消失</p>
<p><strong>一般用于高速缓存</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106121310582.png" alt="image-20220106121310582"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014144835899.png" alt="image-20211014144835899"></p>
<p>与SRAM相比，DRAM的优势在于结构简单——<strong>每一个比特的数据都只需一个电容跟一个晶体管来处理，相比之下在SRAM上一个比特通常需要六个晶体管</strong>。正因这缘故，DRAM拥有非常高的密度，集成度高，体积小，单位体积的容量较高因此成本较低。但相反的，DRAM也有<strong>访问速度较慢，耗电量较大</strong>的缺点。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014150146768.png" alt="image-20211014150146768"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014150540744.png" alt="image-20211014150540744"></p>
<blockquote>
<p>传统异步DRAM，CPU不知道何时主存才能准备好数据，所以要一直等待着，而同步DRAM则为主存与时钟信号同步，会在固定的若干个事时钟周期后准备好数据，所以CPU只要那个时间点去取数据即可，中间可以完成其他的事情</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014150551277.png" alt="image-20211014150551277"></p>
<p>这样CPU就不需要区等待数据的存取，而是知道会在哪个时钟周期完成数据的存取，到时后再去执行即可，而中间时间CPU则可以进行其他操作</p>
<p>注意这里的时钟不是CPU时钟</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014150922689.png" alt="image-20211014150922689"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SDRAM在一个时钟周期内只传输一次数据，它是在时钟上升期进行数据传输；</p>
</li>
<li class="lvl-2">
<p>而DDR则是一个时钟周期内可传输两次数据，也就是在时钟的上升期和下降期各传输一次数据。<strong>使得数据传输数率更快</strong></p>
</li>
</ul>
<h2 id="ROM">ROM</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014151455163.png" alt="image-20211014151455163"></p>
<p>通过掩膜来写入，写入一次后就不能再写入，只能读</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014151912592.png" alt="image-20211014151912592"></p>
<p>使用电信号来写入</p>
<h2 id="主要进行读操作的存储器">主要进行读操作的存储器</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014153107731.png" alt="image-20211014153107731"></p>
<h4 id="EPROM">EPROM</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014153123784.png" alt="image-20211014153123784"></p>
<p>光擦除，电写入，<strong>注意要写入前要擦除之前的内容才行</strong></p>
<h4 id="EEPROM">EEPROM</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014153642509.png" alt="image-20211014153642509"></p>
<p>可以随时写入而不删除之前的内容</p>
<p>但速度慢，写操作每字节需要几百微秒</p>
<p>密度低</p>
<h4 id="Flash-Memory">Flash Memory</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014154321299.png" alt="image-20211014154321299"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014154729160.png" alt="image-20211014154729160"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211014154957475.png" alt="image-20211014154957475"></p>
<p>其中2048x2048x4，前两个表示有这么多行和列，4表示一个单元是4个bit，<strong>说明由4个2048*2048的位元阵列构成</strong><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106144909649.png" alt="image-20220106144909649"></p>
<p>尽可能排成正方形，这样可以减少线的数量，如果100个单元排成一排，那么寻址需要100根线，而如果是10X10排，那么只要20根线组合即可，只要把要寻址的行和列进行加电，那么就可以选中交叉的那个单元</p>
<p>2048=2^11，所以需要11根线，图中的行/列地址缓冲器可以一次由11位的地址线传入行，下一次再传入列，当两者都有后，再去找存储单元</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211024204118897.png" alt="image-20211024204118897"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211024204126649.png" alt="image-20211024204126649"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>集中式刷新：停止所有读写操作并刷新，这样内存就是一会工作一会不工作，对计算机影响很大</p>
</li>
<li class="lvl-2">
<p>分散式刷新：在每个存储周期中，当完成读写时刷新，刷新时间和集中式是一样长的，只是把这段时间分散到多个周期内，因此不会出现突然不工作的情况，因为刷新时间就是死区，那么没有刷新时间就没有死区，所以分散式刷新不存在死区。代价就是，由于把刷新时间融入到了存取周期中，<strong>导致存取T周期变长</strong><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106134846778.png" alt="image-20220106134846778"></p>
<p><strong>这里是每次读写完这个行后，就刷新这个行</strong>，并且不考虑CPU一直读取一行而导致其他行没有被刷新的情况，默认CPU从第一行一直读取到最后一行，<strong><font color=#ff00>所以刷新间隔就为行数个存取周期</font></strong></p>
<blockquote>
<p>再用概率的视角来看，每一行被读/写的概率几乎相同，若把时间扩展到足够长，读取次数足够多（即从宏观的视角），每一行被读取的次数几乎是相同的，那么平均来看，从微观来看，我们也可以近似的看成cpu每一次都读/写了不同行。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>异步刷新</strong>（效率高，常用）：设置一个时间间隔，在这个间隔内要保证每一行都被刷新一次，至于在间隔中什么时候刷新，是根据被不被访问来决定的，如果现在被访问，就不刷新，不被访问就刷新。<strong>但如果一直被访问，那么可能会去影响读写强行刷新</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106135525380.png" alt="image-20220106135525380"></p>
<blockquote>
<p>它将每一行的刷新都分开来，也就是说只要在规定的时间完成对每一行一次的刷新就行了，(2ms/64)间隔进行一次一行的刷新,这里的2ms是规定的，因为DRAM要求，至少2ms更新所有行一次。</p>
<p>每一行只要在最大刷新周期（不刷新/充电就丢失数据的极限时间）内，找个每一行它自己觉得方便的时候刷新即可。</p>
</blockquote>
<p>这样在读写的时候也能刷新，把刷新时间放在了读写中，读写这行就刷新其他行</p>
<p>所以说，异步式刷新所说的<strong>某行在Xms内至少刷新一次=每（Xms/行数）至少刷新一行</strong>。在上述的例子中，就是每4ms内至少刷新一次 = 每(4ms/256=15.6ms)至少刷新一行。</p>
</li>
</ul>
<blockquote>
<ol>
<li class="lvl-3">
<p><strong>某一行充一次电/刷新一次的时间，也等于一个存取周期（存储周期）。</strong></p>
</li>
<li class="lvl-3">
<p>刷新间隔：<strong>所有</strong>存储单元都刷新一遍所需要的时间，也是两次<strong>所有</strong>存储单元开始刷新之间间隔的时间。</p>
</li>
</ol>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211024205216480.png" alt="image-20211024205216480"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211024205628703.png" alt="image-20211024205628703"></p>
<p>图中内存条上黑色的是芯片，芯片连接在一起是通过板子上的金属线</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>位扩展</strong>：地址线不变，数据线增加。如1bit到8bit，<strong>数据线要增加8倍</strong>，<strong>几个bit就要几根</strong></p>
</li>
<li class="lvl-2">
<p><strong>字扩展</strong>：改变寻址单元个数，但不改变每个单元中的位数，即寻址能力不变。地址线增加，数据线不变。</p>
<p>16K=2<sup>14</sup>，所以换成行列除2，因此地址线需要7条。变成64K=2<sup>16</sup>，所以地址线需要8根 <em>（因为行列复用，所以扩大四倍只要多加1根线即可，如果不复用则要多加两根）</em></p>
</li>
<li class="lvl-2">
<p><strong>字、位同时扩展</strong>：地址线和数据线都增加</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211024210939299.png" alt="image-20211024210939299"></p>
<p>只能插1根、2根、4根，而且要先插相同颜色</p>
<p><strong>多插内存条是字扩展，寻址能力不会变</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106141216889.png" alt="image-20220106141216889"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106141242754.png" alt="image-20220106141242754"></p>
<p><strong>主存地址的低3位是用于选片的</strong>，注意数据的存放方式，在一个芯片上不是连续的，而是在不同芯片的同一位置连续存放。</p>
<p>同时<strong>地址中高位为行地址，低位为列地址</strong></p>
<p>先根据行号选出整行到缓冲中，然后在从中选出列</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220106141626007.png" alt="image-20220106141626007"></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211024211121508.png" alt="image-20211024211121508"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3 自动机理论和词法分析器生成器</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3%20%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%E5%92%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h1>3 自动机理论和词法分析器生成器</h1>
<p>在上次课中已经能够根据模拟状态转换图完成一个词法分析器，因此解决<strong>如何将写好的正则表达式转换成状态转换图</strong>，即可完成一个自动的词法分析器生成器</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122172202774.png" alt="image-20221122172202774"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122172321107.png" alt="image-20221122172321107"></p>
<p>本节课讲的是有限状态机，表达能力比较弱，但对于表达词法单元的规约是足够的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122172515902.png" alt="image-20221122172515902"></p>
<p>NFA(<em>非确定有限状态自动机</em>) 自动机容易理解但不容易模拟，因此将 NFA 转换成 DFA，DFA 就很好模拟了，上次课的内容就是模拟 DFA(<em>确定有限状态自动机</em>)</p>
<p>根据图的环形，DFA、NFA、RE 的表达能力是相同的，因为可以相互转化</p>
<h2 id="NFA">NFA</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122210834879.png" alt="image-20221122210834879"></p>
<p><strong>非确定性：</strong></p>
<ol>
<li class="lvl-3">
<p>对于相同的字符，行为可能是不确定的，比如上面的 a，可能仍在 0 状态，也可能转换到 1 状态</p>
</li>
<li class="lvl-3">
<p>对于不在字母表中的字符 ε【如空字符】，也能使状态发生改变</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122212427502.png" alt="image-20221122212427502"></p>
<p>其中 3 为接受状态</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122212608404.png" alt="image-20221122212608404"></p>
<p>一个正则表达式和一个自动机定义的语言是相同的，那么就说这两者等价</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122212942871.png" alt="image-20221122212942871"></p>
<p>对于 aabb 最终可以是处于 0 状态或者是 3 状态，因为可以到达 3 即终止状态，因此可以接受</p>
<p>注意如 1 状态没有 a 的出边则说明 1 不能接受 a 字符，根据上面的约定，即默认指向一个空状态。因此 ababab 是不能最终到 3 状态的，因此不可接受</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122213422611.png" alt="image-20221122213422611"></p>
<h3 id="更多的例子：">更多的例子：</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122213758656.png" alt="image-20221122213758656"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122213819192.png" alt="image-20221122213819192"></p>
<h2 id="DFA">DFA</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122214126878.png" alt="image-20221122214126878"></p>
<p>相比于 NFA，消除了不确定性的两个因素</p>
<p><strong>DFA 要求在每个状态上，对于 Σ 中的每一个字符都要有下一个转移状态</strong></p>
<p>但在实际画的时候，如果不画转移，那么默认转移到死状态【<em>相当于把需要画出的很多个转移到死状态的边给省略了</em>】</p>
<blockquote>
<p>死状态是指不论什么字符，都始终在死状态，不会转移走</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122215313399.png" alt="image-20221122215313399"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这个 DFA 描述的语言和上面 NFA 中的一样，但显然可以看出对于 DFA 想要写出它要描述的语言更难。</p>
</li>
<li class="lvl-2">
<p>但 DFA 的好处是，给定一个字符串，可以很容易的判断是不是符合的字符串</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122215959017.png" alt="image-20221122215959017"></p>
<h2 id="RE-到-NFA-Thompson-构造法">RE 到 NFA Thompson 构造法</h2>
<p>从 RE 到 NFA: Thompson 构造法</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122221350876.png" alt="image-20221122221350876"></p>
<p>即按照上面对正则表达式结构的定义来归纳将正则表达式转换成 NFA</p>
<h3 id="归纳">归纳</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122221633881.png" alt="image-20221122221633881"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122221642185.png" alt="image-20221122221642185"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122221656640.png" alt="image-20221122221656640"></p>
<p>加个括号不影响语言，因此直接等价</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122222032856.png" alt="image-20221122222032856"></p>
<p>对 s 和 t 加一个初始状态并用  ε 转移到 s 和 t的初始状态；同样的，增加终止状态，用 ε 从 s 和 t 的终止状态转移到这个终止状态</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122222109645.png" alt="image-20221122222109645"></p>
<p>将 s 的终止状态作为 t 的初始状态</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122222150535.png" alt="image-20221122222150535"></p>
<p>底下的 ε 表示 s 可以是 0 个；上面的 ε 表示 s 可以任意多个</p>
<h3 id="复杂度">复杂度</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122222350735.png" alt="image-20221122222350735"></p>
<p>3 表示构造出的 NFA 不会太复杂，最多只是原来正则表达式复杂度的两倍（因为上面的构造中最多就是添加一个初始状态和一个终止状态）</p>
<h3 id="构造的例子">构造的例子</h3>
<p>完成按照上面的构造方式就能成功构造出</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221122222712224.png" alt="image-20221122222712224"></p>
<h2 id="NFA-到-DFA-子集构造法">NFA 到 DFA 子集构造法</h2>
<p>思想：用 DFA 来模拟 NFA</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123170116496.png" alt="image-20221123170116496"></p>
<p>模拟就需要模拟 NFA 的所有状态和状态转移</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>上面 NFA 中的 0、1、2、4、7 都是可以通过 ε 来转移的，因此它们都是 DFA 中的初始状态</p>
</li>
<li class="lvl-2">
<p>因为是 DFA，因此要考虑所有的输入字符即 a 和 b，对于初始状态：</p>
<ul class="lvl-2">
<li class="lvl-4">输入字符 a，可以转移到 3、8，而对于 3，又可以通过 ε 转移到 6、7，6 又可以通过 ε 转移到 1，进而通过 1 到 2、4，因此第二个状态包含 3、8、6、7、1、4、2</li>
<li class="lvl-4">同理，输入字符 b 可以到 5、4、7、1、2、4</li>
</ul>
</li>
<li class="lvl-2">
<p>一直下去，需要注意转移得到的状态是不是和已经有的状态子集相同，如果相同，则这个转移是回到自己</p>
</li>
<li class="lvl-2">
<p>如果构造的状态子集中包含至少一个 NFA 的终止状态，那么它就是 DFA 的终止状态</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123171451263.png" alt="image-20221123171451263"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123171456189.png" alt="image-20221123171456189"></p>
<h3 id="公式化子集构造法">公式化子集构造法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123172625988.png" alt="image-20221123172625988"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123171931706.png" alt="image-20221123171931706"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ε 闭包也包含 s 自身，因为公式中的 ε 是 *，可以是 0 个 ε 转移</p>
</li>
<li class="lvl-2">
<p>move 是指，当前的 DFA 状态集合为 T，当看到 a 字符时，DFA 可以到达哪些状态【其实就是上面的不断找状态子集的过程】</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123172039402.png" alt="image-20221123172039402"></p>
<p>公式化上面的构造过程</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123172106671.png" alt="image-20221123172106671"></p>
<p>最坏情况下复杂度是指数级别的：如下例子，得到的 DFA 非常复杂</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123172315437.png" alt="image-20221123172315437"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123172326017.png" alt="image-20221123172326017"></p>
<h2 id="DFA-最小化">DFA 最小化</h2>
<p>通过子集构造法得到的 DFA 不一定是<strong>最简的</strong>，如下图上面的 DFA 的状态数就比用子集构造法得到的更少</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123174351307.png" alt="image-20221123174351307"></p>
<p>DFA 最小化算法基本思想: <strong>等价的状态可以合并</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123175738586.png" alt="image-20221123175738586"></p>
<p>如下反例：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123175902674.png" alt="image-20221123175902674"></p>
<p>采取相反的策略，先假设<strong>全部都等价</strong>，再根据不等价定义【<em>转移的状态都不同，那肯定是不等价的</em>】进行不等价的分裂：注意下面的不等价定义是存在 a，因此需要把每一个字母表中的都试一下，找到或者试完为止</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123181305524.png" alt="image-20221123181305524"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先把 E 从其他状态中分裂出来，E 所在的集合只有 E 一个，因此不用再分裂，接下来对剩余状态进一步分裂</p>
</li>
<li class="lvl-2">
<p>D 通过 b 会到 E，而 ABC 通过 b 都还是到 ABCD 这个等价类，因此分裂出 D</p>
</li>
<li class="lvl-2">
<p>然后分裂出 B</p>
</li>
<li class="lvl-2">
<p>对于 A、C，不能分裂出来，因此 AC 就等价了，此时达到了不动点，不能再继续分裂了</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123182148356.png" alt="image-20221123182148356"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123182253383.png" alt="image-20221123182253383"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123182606312.png" alt="image-20221123182606312"></p>
<p>合并后一定是 DFA，否则就说明分裂不完全，还需要继续分裂</p>
<p>合并后的初始状态是合并后包含初始状态的等价类，接受状态同理</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123182820639.png" alt="image-20221123182820639"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201201000573.png" alt="image-20221201201000573"></p>
<h2 id="DFA-到-词法分析器">DFA 到 词法分析器</h2>
<p>下面展示了从 RE =&gt; NFA =&gt; DFA =&gt; 词法分析器</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201201719715.png" alt="image-20221201201719715"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201201728844.png" alt="image-20221201201728844"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201201734138.png" alt="image-20221201201734138"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201201741539.png" alt="image-20221201201741539"></p>
<p>**注意：**如果在 DFA 中的接受状态包含 NFA 中的多个接受状态，如上面的 68，都要确定到底是要接受其中的哪个，因为我们需要最前优先匹配，所以 68 这个状态应该接受 abb</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201202116272.png" alt="image-20221201202116272"></p>
<p>**注意：**其中 68 对于输入 a 没有状态转移，默认是转移到一个死状态的，如果加上了死状态，那么在 68 接受到 a 时就会进入死状态，并且永远停留在死状态，这是不合理的，所以要消除死状态，让状态机在 68 接收到 a 时就停止</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201202333097.png" alt="image-20221201202333097"></p>
<p>上面的模拟过程就是手写词法分析器中的要考虑的步骤。报错会忽略第 1 个字符，从第 2 个字符开始重新识别</p>
<p>例子：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201202539258.png" alt="image-20221201202539258"></p>
<p>对于 DFA 最小化，根据之前 DFA 最小化的方法，我们把 0137 和 7 作为一类，其他 4 个终止状态为一类。</p>
<p>但如果这个 DFA 是用于生成词法分析器的，那么在一开始的时候不能把所有的终止状态分为一类，因为它们识别的是不同的词法单元。如下的 Π<sub>0</sub>。其中的空就是死状态，因为在之前已经提到，要保证这是一个 DFA，所以需要补齐没有转移的线条。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208172013713.png" alt="image-20221208172013713"></p>
<p>最小化的结果是 Π<sub>1</sub>，和原来一样，即原图就是一个最小化的 DFA 了。</p>
<h2 id="DFA-到-RE">DFA 到 RE</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208172421163.png" alt="image-20221208172421163"></p>
<p>对于 DFA 要找到与之等价的 RE，它们表达的是一个语言</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208173122845.png" alt="image-20221208173122845"></p>
<p>所有的路径的集合，就是这个语言，因此正则就是所有的路径的或</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208173355802.png" alt="image-20221208173355802"></p>
<p>使用 floyed 算法找到所有的路径</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208174323606.png" alt="image-20221208174323606"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208174811492.png" alt="image-20221208174811492"></p>
<p>上面的箭头上的是转移条件</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208174837335.png" alt="image-20221208174837335"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208175002663.png" alt="image-20221208175002663"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208175016382.png" alt="image-20221208175016382"></p>
<p>过程：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208175340138.png" alt="image-20221208175340138"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208175350339.png" alt="image-20221208175350339"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208175357852.png" alt="image-20221208175357852"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208175405165.png" alt="image-20221208175405165"></p>
<p>只需要选择我们要的，即从初始状态到接受状态的结果，上面就是 R<sup>2</sup><sub>01</sub></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>9 高速缓冲存储器（Cache）</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/9%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88Cache%EF%BC%89/</url>
    <content><![CDATA[<h4 align="center">图片来源：南京大学软件学院COA课程PPT</h4>
<h5 align="center">©author:zzb</h5>
<div style="text-align: center"><a href="https://github.com/wbl-z">Github主页</a>  <a href="https://blog.csdn.net/m0_51691879">CSDN主页</a></div> 
<h1>9 高速缓冲存储器（Cache）</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028134654827.png" alt="image-20211028134654827"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028134803191.png" alt="image-20211028134803191"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028134847367.png" alt="image-20211028134847367"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028135033591.png" alt="image-20211028135033591"></p>
<p>大部分是集成在CPU内部的，存放的还是主存内的信息，是主存内部分信息的副本</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028141114903.png" alt="image-20211028141114903"></p>
<p>如果不在cache中，那么会将<strong>包含这个字的固定大小的块</strong>读入cache，然后<strong>再从cache中把这个字传给CPU</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028141432926.png" alt="image-20211028141432926"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028141818855.png" alt="image-20211028141818855"></p>
<p>cache中除了<strong>要存内容，还得存这个内容的位置</strong>，因为CPU是通过位置来访问主存中的内容的，而不关心其中的内容。</p>
<p>cache不是存放了完整的位置，<strong>而是通过tags标记</strong>来对应内容在内存中的位置</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028142420549.png" alt="image-20211028142420549"></p>
<p>如果大部分时间都是未命中，那么使用cache后反而时间会更慢，而事实上cache很好的处理了内存墙问题，因此大部分情况应当是命中的</p>
<p>这是由于程序访问的局部性原理，<strong>即CPU总是会频繁的访问相同位置或者是相邻位置的内容</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间局部性：在相对短时间内，重复访问相同位置的信息</p>
</li>
<li class="lvl-2">
<p>空间局部性：在相对短时间内，会访问相邻存储位置的数据</p>
<ul class="lvl-2">
<li class="lvl-4">顺序局部性：相邻位置的按顺序的，如访问数组</li>
</ul>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028142834398.png" alt="image-20211028142834398"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028144013339.png" alt="image-20211028144013339"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028144140819.png" alt="image-20211028144140819"></p>
<p>注意这个块是<strong>事先就在内存中划分好了（哪一部分属于哪个块都是确定的）</strong>，要哪个字时，只要把这个字的所在块搬过去，而不是临时从这个字开始再划分块</p>
<p>所以只要想要访问的字所属的块在cache中，那么这个字就在cache中，因此只要对每个块做一个标记（块号）就可以知道有没有命中</p>
<p><strong>cache中每一行是一个块，记录了块的标记和块中的K个字</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211028145432136.png" alt="image-20211028145432136"></p>
<p>T<sub>A</sub>的两个式子，是<strong>两种不同的理解</strong>，第一行是分为命中和未命中来理解，第二行是分成check检查阶段和到主存取数据阶段来理解的，<strong>一般第二行使用更多</strong></p>
<p>Tc很快，Tm相对慢，因此Tc/Tm是比较小的值，所以p是相对很小时就能满足条件。但事实上这个条件虽然小也很难满足，因为cache容量远小于主存容量，p实际上按概率来算应该是cache的容量/主存容量，是非常小的，但之所以能满足，就是<strong>因为前面提到的局部性原理</strong></p>
<h1>Cache的设计要素</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211030133530602.png" alt="image-20211030133530602"></p>
<h2 id="一、cache容量">一、cache容量</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211030133602704.png" alt="image-20211030133602704"></p>
<p>cache容量不是越大越好，也不是越小越好。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为内存是以地址来寻找的，所以直接解码地址就能找到要的信息，而cache则是通过遍历来找的（遍历块的标号），所以如果cache很大的话，会导致遍历检查的时间增加，增大了T<sub>c</sub>。</p>
</li>
<li class="lvl-2">
<p>如果cache很小的话，则可能出现从内存中复制的新的块把原来cache中的块覆盖后，又需要原来的块中的内容，因此又需要从内存中复制到cache，浪费时间</p>
</li>
</ul>
<h2 id="二、映射功能">二、映射功能</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211030134508748.png" alt="image-20211030134508748"></p>
<p>cache中记录的是块号，块号要能反映地址</p>
<p>块内地址：如果一个块内有K个字节，那么地址的后log<sub>2</sub>K位表示块内地址</p>
<p>而cache中分辨不同块的标记可以直接使用块号来作为标记，但这样会造成一些浪费（块号不是我们想要的信息），<strong>因此就要去想怎么尽可能缩短标记的长度</strong></p>
<h3 id="1-直接映射"><strong>1.直接映射</strong></h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211104160957975.png" alt="image-20211104160957975"></p>
<p>比如0~7块只能放到第一行，8~15块只能放到第二行，因此如果加载了第2个块，想再加载第3个块，那么第3个块会把第二个覆盖</p>
<p>如上图$i=jmodC$是间隔的把块规定放到同一行，而不是上面的连续的几个块都只能在一个行中，显然下面这种更合理，因为局部性原理，访问相邻块的概率更大，<strong>因此间隔的放，可以把连续的块都加载到cache中，而不会出现上面的覆盖情况</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105091155893.png" alt="image-20211105091155893"></p>
<p>映射到同一行的块号（二进制表示）的后$log_2C$位都是一样的</p>
<p>因此只要比较块号的前面$log_2M-log_2C$位即可（M是块的数量，C是cache中行的数量）<strong>相当于把C个块当作一个组，只要记录这个组的地址即可</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105091937397.png" alt="image-20211105091937397"></p>
<p>再看主存中一个具体的字节，它在主存的地址可以被分成三个部分：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>块内地址（用于块内寻址）</p>
</li>
<li class="lvl-2">
<p>块映射到cache的行号</p>
</li>
<li class="lvl-2">
<p>若干个块分为一个组对应的标号，用于区分映射到相同行的不同块，记录为cache标号</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105092857092.png" alt="image-20211105092857092"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>优点</strong>：因为块映射到cache中的行的位置是固定的，因此检查时，只要去找这一行中有没有要的数据即可，而不必全部搜索一遍，<strong>所以T<sub>c</sub>是固定的，不会因cache容量增大而使得T<sub>c</sub>变大</strong></p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：抖动现象：如果要重复访问的两个块刚好映射到同一行，就会降低命中率，<strong>当两个块比较相邻（才可能被重复访问）时并被映射到同一行，说明cache比较小，即行数比较少</strong>时会出现这种情况。</p>
</li>
<li class="lvl-2">
<p>因此<strong>直接映射适合大容量cache使用</strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105093628480.png" alt="image-20211105093628480"></p>
<ol>
<li class="lvl-3">
<p>根据内存地址的块地址去找cache对应行</p>
</li>
<li class="lvl-3">
<p>再比较cache标记和主存地址的块标记是否相等</p>
</li>
<li class="lvl-3">
<p>相等就命中，命中就再根据主存地址的块内地址到cache取对应字节</p>
</li>
</ol>
<h3 id="2-关联映射">2.关联映射</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105094020890.png" alt="image-20211105094020890"></p>
<p>关联映射中的标记<strong>必须是块号</strong>，所以长度只能是$log_2M$，不像直接映射中有规律，可以缩短。<strong>关联映射是可以按一定规则放的，只要有空位就能放</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105094456359.png" alt="image-20211105094456359"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105094539163.png" alt="image-20211105094539163"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>优点</strong>：在cache比较小时<strong>不会出现抖动</strong>，想加载哪些块都可，不会出现反复加载，除非cache行数不够了</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：怎么规定放块实现比较复杂，同时检查时要<strong>平均检查$\frac{1}{2}$的cache，在cache很大时开销太大</strong></p>
</li>
<li class="lvl-2">
<p>因此<strong>关联映射适合容量小的cache</strong></p>
</li>
</ul>
<h3 id="3-组关联映射（介于前面两种方法之间）">3.组关联映射（介于前面两种方法之间）</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105100521745.png" alt="image-20211105100521745"></p>
<p><strong>K是指每组里面包含的行数</strong>，<strong>S是组数</strong></p>
<p><strong>即将cache分成不同的组，一个块只能映射到对应的组中，但在这个组中可以放在任意一行</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105100934013.png" alt="image-20211105100934013"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105102834862.png" alt="image-20211105102834862"></p>
<p>标记中不需要存全部块号，因为组号是固定的，只要$log_2M-log_2S$位即可</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105110048821.png" alt="image-20211105110048821"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105110041424.png" alt="image-20211105110041424"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105110328246.png" alt="image-20211105110328246"></p>
<p>**关联度：**一个块映射到cache中可能存放的位置个数</p>
<p><strong>关联度越低，命中率越低，检查是否命中的时间越短，标记所占的额外空间开销越小</strong></p>
<h2 id="三、替换算法">三、替换算法</h2>
<p><strong>目的：将最不可能被使用的行替换掉，尽可能增大命中率</strong></p>
<p><strong>替换算法使用硬件来实现，因为替换需要非常快的速度</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105111310863.png" alt="image-20211105111310863"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105111503677.png" alt="image-20211105111503677"></p>
<h3 id="1-最近最少使用算法（LRU）">1.最近最少使用算法（LRU）</h3>
<p><em><strong>假设前提相当于看文件被修改过到现在的时间</strong></em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105111643511.png" alt="image-20211105111643511"></p>
<p><strong>需要限定路的数目</strong>，多路会很复杂，在模拟中可以通过设置时间戳的方式来记录最近使用的时间，要替换时最早的那个就是最近最少使用的</p>
<h3 id="2-先进先出算法（FIFO）">2.先进先出算法（FIFO）</h3>
<p><em><strong>假设前提相当于看文件被创建到现在的时间</strong></em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105112007246.png" alt="image-20211105112007246"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105113453795.png" alt="image-20211105113453795"></p>
<p><strong>无需限定路的数目</strong>，只要循环轮下来即可</p>
<p>最开始初始化是应该把每一行的use位设为0，因为相当于替换哪行都可以。</p>
<p><strong>替换时把被替换的行设为1，把它的下一行设为0</strong>（如果是最开始，那么它的下一行本来就是0），如果被替换的是最后一行，那么把第一行设为0，这样循环，<strong>可以保证一个组中至少存在一个use位为0的行</strong>，从而用新数据去替换这一行</p>
<h3 id="3-最不经常使用算法（LFU）">3.最不经常使用算法（LFU）</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105113541410.png" alt="image-20211105113541410"></p>
<h3 id="4-随机替换算法（Random）">4.随机替换算法（Random）</h3>
<p><em><strong>能到cache中的的块都是使用率较高的，否则不会进到cache中，所以不再去区分cache中块的使用率</strong></em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105113638088.png" alt="image-20211105113638088"></p>
<p>性能只比其他区分cache中块优先级的差一点点，但实现起来相对简单很多</p>
<h2 id="四、写策略">四、写策略</h2>
<p>写数据时，CPU同样会<strong>优先修改cache中的数据</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105114158557.png" alt="image-20211105114158557"></p>
<p><strong>对cache的修改不需要直接同步到内存中</strong>，因为之后CPU读的还是cache中的内容，因此只要存在cache中即可；<strong>只有在cache中这个块要被替换时，才要把修改同步到内存</strong>，否则这个修改就丢失了</p>
<h3 id="1-写直达">1.写直达</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105114613288.png" alt="image-20211105114613288"></p>
<p>对于多CPU共享一个内存的情况，实时同步数据是必要的</p>
<h3 id="2-写回法">2.写回法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105114926754.png" alt="image-20211105114926754"></p>
<p>缺点就是如果这个块被修改但没有被替换，<strong>那么它不会写回主存同步修改</strong>，而I/O模块对主存如打印时就得不到最新的数据了，只能增加设计：<strong>在打印时把所有cache中脏位为1的都同步到主存</strong></p>
<h2 id="五、行大小">五、行大小</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105115851686.png" alt="image-20211105115851686"></p>
<h2 id="六、cache数目">六、cache数目</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105184945853.png" alt="image-20211105184945853"></p>
<p>L2容量比L1更大，L2从内存中取了数据，L1从L2中取了数据，同样找数据时也是先在L1中找，如果未命中，再去L2中找</p>
<p><font color=#ff000>为什么不只使用大容量的L2，而是加入了L1?</font></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105185556019.png" alt="image-20211105185556019"></p>
<p><strong>分立</strong>：对指令和数据分别用不同的cache</p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20211105185857351.png" alt="image-20211105185857351"></p>
]]></content>
      <categories>
        <category>计算机组织结构</category>
      </categories>
      <tags>
        <tag>计算机组织结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4.3 语法分析——Adaptive LL(∗) 语法分析算法</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.3%20%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Adaptive%20LL(%E2%88%97)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>4.3  语法分析——Adaptive LL(∗) 语法分析算法</h1>
<p><code>Antlr</code> 使用的算法是 LL：Adaptive LL(*)</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212193950896.png" alt="image-20221212193950896"></p>
<p>（间接左递归：A→B，B→A，因此最终还是 A→A，不支持是因为工程上一般不会这么去写，且如果要改写，改写后的会非常复杂，因此干脆不支持了）</p>
<span id="more"></span>
<h2 id="Antlr-4-处理直接左递归和优先级——优先级上升算法">Antlr 4 处理直接左递归和优先级——优先级上升算法</h2>
<blockquote>
<p>如果想在当前层的下一层展开，那么优先级要上升/更高。</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212194938861.png" alt="image-20221212194938861"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212194944130.png" alt="image-20221212194944130"></p>
<p><code>antlr4 LRExpr -Xlog</code> 加上这个参数后，可以在 log 中看到 <code>Antlr4</code> 重写语法后的语法（<code>Antlr4</code> 会把上面这样左递归的文法(expr:expr)改写成非左递归的）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212195251775.png" alt="image-20221212195251775"></p>
<p>下面的转化成了上面的形式</p>
<p>上面左递归的 expr 和 expr : (INT|ID)(*expr  | +expr )* 这样的非左递归的形式是等价的，也即上面改写后的形式。但是 <code>Antlr4</code>增加了：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>expr 中的 int _p 就是定义了这 expr 的优先级（<code>Antlr4</code>规定的是写在上面的优先级最高，因此 <code>*</code> 的优先级最高是 5），在展开 expr 的时候都要带上优先级，比如上面写的 expr[5]，</p>
</li>
<li class="lvl-2">
<p>{4 &gt;= $p}? 就是 if 判断，如果传入的优先级比 4 小，那么就用当前的展开</p>
</li>
<li class="lvl-2">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212201104139.png" alt="image-20221212201104139"></p>
</li>
<li class="lvl-2">
<p>在 exp[4] 处发现不能展开，因此就回到上层，展开成下面的样子</p>
</li>
<li class="lvl-2">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230221153924579.png" alt="image-20230221153924579"></p>
<p><strong>优先级控制了是在这一层展开还是回到上一层去展开</strong>，比如这里的 4，就不能满足 + 的条件，因此不能在这一层展开，会回到上一层，也即 exp[4] 所在是层进行展开 2+3，这样就实现了加法的左结合。【()*就相当于 while 循环，当循环中的都不满足，那就结束本层的递归调用回到上一层】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212203534294.png" alt="image-20221212203534294"></p>
</li>
<li class="lvl-2">
<p>因此<strong>关键</strong>就是展开后<strong>下一层递归传入的优先级</strong>是多少，在<strong>本层循环中的条件设置成多少</strong></p>
</li>
<li class="lvl-2">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212201611414.png" alt="image-20221212201611414"></p>
</li>
<li class="lvl-2">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212201743471.png" alt="image-20221212201743471"></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212201826603.png" alt="image-20221212201826603"></p>
<p>括号的优先级更高，为什么不放到 +* 的上面呢，因此它<strong>不是左递归</strong>的，<strong>因此和 INT、ID所在的位置一样，会被优先处理</strong></p>
<p>下面同理</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212201954910.png" alt=""></p>
<p>-expr 和 ID 是一组，因为不是左递归，剩下两个是一组，因此改写后是这样的形式：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212202030143.png" alt="image-20221212202030143"></p>
<p>处理<strong>右结合</strong>的：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212203711516.png" alt="image-20221212203711516"></p>
<p>对于 ^ 判断条件是 3，传入到下一层递归的参数也是 3，因此可以连续在下一层展开 ^，也即<strong>实现右结合</strong>，<strong>没有优先级上升</strong></p>
<p><strong>总结：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>处理左结合运算符，采用优先级上升</strong></p>
</li>
<li class="lvl-2">
<p><strong>处理右结合运算符，采用优先级不变</strong></p>
</li>
</ul>
<h2 id="Antlr-4-处理错误报告与恢复">Antlr 4 处理错误报告与恢复</h2>
<p>原则：报错、<strong>恢复</strong>、继续分析</p>
<p>在当前词法单元出错时：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212204344328.png" alt="image-20221212204344328"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>单词法符号移除：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212204556589.png" alt="image-20221212204556589"></p>
</li>
<li class="lvl-2">
<p>单词法符号补全</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212204631678.png" alt="image-20221212204631678"></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212204715719.png" alt="image-20221212204715719"></p>
<p>group:1 表示选择第一个备选分支进行展开</p>
<p><strong>FOLLOWING 是在运行这个文法时动态的集合</strong>【<em>相比于静态的 FOLLOW，动态可以有更多信息去利用，因此集合内的元素也更少更确定，比如已知是group:1，那么肯定不会期望 )</em>】。因为我们选择了 group 的第一个备选分支，因此我们知道，如果能从 expr 中恢复过来，我们期望的是 ]，因此跟在 expr 后面的是 ]，同理从 atom 恢复过来是期望后面的是 ^</p>
<p><strong>因此整个流程</strong>就是，先看到 [，选择第一个备选分支，然后看到 ]，当作 expr 来处理，然后当作 atom 来处理，结果发现 atom 中没有与之匹配的终结符，<strong>因此出错。现在要恢复</strong>过来：先计算 FOLLOWING(expr,atom)={^,]}，因此读取后面的输入发现了 ]，就假装 atom 成功找到了它的下一个字符，回到 expr，因为 atom 成功，所以 expr 要匹配 ^，但确实 ]，同理计算，然后假装成功并返回到 group，并与 group 想要的 ] 匹配成功。</p>
<h2 id="Adaptive-LL-∗-不做考试要求">Adaptive LL(∗) [不做考试要求]</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212210317624.png" alt="image-20221212210317624"></p>
<p>P表示的语言用正则表达式表示就是 S→a*bc | a*bd</p>
<p>这个文法<strong>不是 LL(k)文法</strong>，因为不论 k 取多少，都不能唯一确定 S 要选取哪个备选分支，因为 A 可以产生任意多个 a、</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212214909916.png" alt="image-20221212214909916"></p>
<p>在决策点，对于每个备选分支产生一个解析器，并行地看当前的输入是不是符合的，如果不是，那么这个解析器 die；如果有歧义【多个达到了一个相同的状态或者都到达了 EOF，即说明这几个解析器没有区分开，是歧义】，最后选择仍然存活的分支（如果有多个即存在歧义，那么选择其中的第一个）</p>
<p><strong>三元组的含义</strong>分别是：（当前状态，当前分支，进入下一个非终结符后并完成后要返回的状态栈【即一个递归调用栈】）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212220109822.png" alt="image-20221212220109822"></p>
<p>注意：这里更准确的说法是，f<sub>1</sub> 里两个三元组的第二个分量都是 1，所以可以确定使用第 1 条产生式，与是否进入 P<sub>s</sub>’ 没有直接关系。这里是巧合。</p>
<blockquote>
<p>什么叫做通过move，通过闭包得到的状态</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>4.1 语法分析——ANTLR 4 语法分析器</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.1%20%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ANTLR%204%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h1>4.1  语法分析——ANTLR 4 语法分析器</h1>
<h2 id="call-graphs">call graphs</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201170040681.png" alt="image-20221201170040681"></p>
<span id="more"></span>
<p>**目标：**利用语法分析功能来构建程序的函数调用图</p>
<hr>
<p>对于 <code>Cymbol</code> 语言</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129215359028.png" alt="image-20221129215359028"></p>
<p>一个程序是由变量声明或函数声明来组成的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129215704442.png" alt="image-20221129215704442"></p>
<p>block 由 stat 组成，stat 又可以由 block 组成，这样表达是嵌套，即在大括号中可以嵌套大括号</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129220356258.png" alt="image-20221129220356258"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129220421090.png" alt="image-20221129220421090"></p>
<hr>
<h3 id="二义性文法">二义性文法</h3>
<p>二义性文法：对于一个语法如果一个表达式可以有两种解释方式，即有歧义，是不可以的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129220904650.png" alt="image-20221129220904650"></p>
<p>如上述语法，对于 <code>if a then if b then c else d</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以把 <code>if b then c else</code> 整体作为 <code>stat</code>，适用第一条规则；</p>
</li>
<li class="lvl-2">
<p>也可以把 <code>if b then c</code> 作为 <code>stat</code>，适用第二条规则。</p>
</li>
<li class="lvl-2">
<p>【<strong>即 <code>else</code> 到底属于哪个 <code>if</code> 的问题</strong>】</p>
</li>
</ul>
<p><strong>没有</strong>算法<strong>可以判定</strong>语法是否有二义性，一般靠经验对一些特定结构的语法来判断，并针对性的消除二义性</p>
<p>对于上面的二义性语法通过下面的改变来消除二义性，让 <code>else</code> 与最近的 <code>if</code> 匹配</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129221552085.png" alt="image-20221129221552085"></p>
<p>但是 <code>Antlr</code> 不需要上面的改写就可以消除二义性【<em>即我们不需要改写，只需要写原来的具有二义性的语法，<code>Antlr</code> 会帮我们消除二义性</em>】，它的策略是：如果规则有多条可能性，那么在进行语法分析时会按照规则的书写顺序<strong>从上往下</strong>进行匹配，当上面的匹配不了才会采用下面的进行匹配。</p>
<p>【因此书写时一定要注意书写顺序，<strong>顺序就是匹配的优先级</strong>】</p>
<p>例如在上面的二义性规则中，<strong>优先匹配第一条规则就能解决二义性。</strong></p>
<h4 id="表达式文法的二义性">表达式文法的二义性</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129223132251.png" alt="image-20221129223132251"></p>
<p>结合性：对于 <code>1-2-3</code> 可以是 <code>(1-2)-3</code> 也可以是 <code>1-(2-3)</code></p>
<p>优先级：对于 <code>1-2*3</code> 可以是 <code>1-(2*3)</code> 也可以是 <code>(1-2)*3</code></p>
<p>上面的规则是 <code>expr</code> 是左右递归，即 <code>*</code> 的左右都有 <code>expr</code></p>
<p>可以改写成左递归和右递归的形式来<strong>实现优先级</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130094517724.png" alt="image-20221130094517724"></p>
<p>但改写会导致简单的表达式<strong>很复杂</strong>，如下：同时注意<strong>右递归会导致运算符是右结合</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130094634606.png" alt="image-20221130094634606"></p>
<p>对于 <code>Antlr</code>，可以直接处理，不需要改写，同样将书写顺序来作为优先级。并且如果不做特殊标记，默认是左结合的，如果要右结合，只需要加上一个标记告诉 <code>Antlr</code> 即可，如下：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130095611017.png" alt="image-20221130095611017"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130095927135.png" alt="image-20221130095927135"></p>
<p>对于<strong>一元运算符</strong>，不需要标记即为右结合，因为类似上面的右递归，对于一元运算法只能按照右结合进行语法树构建，没有其他的构建方式，如下：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130095907900.png" alt="image-20221130095907900"></p>
<hr>
<h3 id="Left-Factoring">Left-Factoring</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221129222810642.png" alt="image-20221129222810642"></p>
<p>有些算法没法处理有相同的左公因子的规则，因此必须要提取出来，表示成右边的样式。</p>
<p>但是显然，<code>Antlr</code> 可以处理有相同的左公因子的规则，不需要我们自己提取</p>
<hr>
<h3 id="Listener">Listener</h3>
<p><code>Antlr</code> 会为每一条规则生成监听器【<code>enterXXX, exitXXX</code>】，<strong>我们可以实现这个监听器</strong>【因为要完成自动构建函数调用图的功能，需要实现 <code>enterXXX</code>，当到达该节点的时候就执行；如果实现 <code>exitXXX</code>，一般是当前节点的信息依赖于子节点的信息时，才会在访问完子节点后才执行当前节点的函数】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130141616493.png" alt="image-20221130141616493"></p>
<p>监听器功能：在深度遍历语法树时【<em>enter和exit分别在到达和离开这个节点时监听</em>】，如果是该监听器监听的类型，那么会执行监听器中的功能。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130100922002.png" alt="image-20221130100922002"></p>
<p>在规则后面加上 <code>#name</code> 即可让 <code>Antlr</code> 遇到这个规则时生成粒度更细的 <code>name</code> 类型，而不是粗粒度的 <code>expr</code>。如果 <code>expr</code> 中的一个加上了 <code>#</code>，那么其他的 <code>expr</code> 中的<strong>其他规则</strong>也<strong>都要加上</strong> <code>#</code></p>
<p>对于同一个规则里面用 | 分隔的两个运算，使用 <code>#</code> 也无法区分，因此再加上 <code>op=</code>，这样在这条规则对应的树节点上面有一个成员 <code>op</code>，根据这个来区分，如下</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130141455875.png" alt="image-20221130141455875"></p>
<h2 id="calculator">calculator</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201175439066.png" alt="image-20221201175439066"></p>
<p><strong>目标</strong>：实现一个小计算器</p>
<p>要记录的信息即计算结果，需要在运算符节点记录叶子节点的计算结果，因此依赖于叶子节点，所以需要实现 <code>exitXXX</code></p>
<p>因为 <code>exitXXX</code> 方法都是返回值为 0 的，所以无法记录状态，可以考虑使用全局变量，但是不好。事实上，<code>Antlr</code> 提供了一个 <code>map&lt;ParseTree, T&gt;</code> <code>ParseTreeProperty&lt;T&gt;</code> 来给<strong>每个节点记录信息</strong></p>
<p>如下将 INT 节点的值放到了 map 中<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201180841366.png" alt="image-20221201180841366"></p>
<p>这样比如在计算取反操作的时候，右下角的整数值是已经知道了的，并存在 map 中，所以当回到父节点时也即执行 <code>exitXXX</code> 时就可以直接使用这个存入的整数值</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201181027643.png" alt="image-20221201181027643"></p>
<p>对于 +/- 操作因为的 <code>g4</code> 中标明了 <code>lhs,rhs,op</code> 所以它们是 <code>ctx</code> 的成员</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201181706852.png" alt="image-20221201181706852"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201181502393.png" alt="image-20221201181502393"></p>
<h2 id="理论部分">理论部分</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201191816864.png" alt="image-20221201191816864"></p>
<p>如果没有指定开始符号，那么第一条规则是开始符号</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201192156911.png" alt="image-20221201192156911"></p>
<p><code>g4</code> 中用的是 [E]BNF，即加入了 <code>*+?</code> 这类语法糖</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201192412141.png" alt="image-20221201192412141"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201192715436.png" alt="image-20221201192715436"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193233236.png" alt="image-20221201193233236"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193338765.png" alt="image-20221201193338765"></p>
<p>所有的推导都是<strong>句型</strong>，当推导到只有终结符时是<strong>句子</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193439194.png" alt="image-20221201193439194"></p>
<p>文法定义的语言就是它能推导出的所有句子的集合</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193555433.png" alt="image-20221201193555433"></p>
<p>第一个问题决定了我们怎么去设计构建语法分析树的算法</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193706323.png" alt="image-20221201193706323"></p>
<h3 id="L-G-是什么？">L(G) 是什么？</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193730169.png" alt="image-20221201193730169"></p>
<p>简单的例子：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193912595.png" alt="image-20221201193912595"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201193921986.png" alt="image-20221201193921986"></p>
<h3 id="上下文无关文法表达能力更强">上下文无关文法表达能力更强</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201195018637.png" alt="image-20221201195018637"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201195219917.png" alt="image-20221201195219917"></p>
<p><img src="C:%5CUsers%5Cwbl%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221201195357332.png" alt="image-20221201195357332"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201195417989.png" alt=""></p>
<p>因为 m &gt; k，所以肯定会有<strong>相同的状态</strong> S<sub>i</sub> 出现</p>
<p>假设在第一次碰到  S<sub>i</sub> 时输入的是 a<sup>i</sup>，那么在输入 a<sup>m</sup> 时，在 i~m 之间的 j 会重新回到  S<sub>i</sub> 。而根据定义，在输入 a<sup>i</sup> 后输入 b<sup>i</sup> 会到达终止状态，即被接受，那么输入 a<sup>i+j</sup>b<sup>i</sup> 也能到达终止状态，这与定义矛盾</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221201200310030.png" alt="image-20221201200310030"></p>
<p>这是所谓的<strong>泵引理</strong>，同理下面的语言是上下文无关文法也无法表达的</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>4.2 语法分析——递归下降的 LL(1) 语法分析器</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.2%20%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%9A%84%20LL(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h1>4.2  语法分析——递归下降的 LL(1) 语法分析器</h1>
<p>语法分析器分为两大类：<strong>LL、LR</strong>，后者不论是在理解还是实现上都比 LL 复杂得多</p>
<p>课程介绍 LL 中比较简单的一类</p>
<p>语法分析要做的事情就是<strong>构建语法分析树</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208214928911.png" alt="image-20221208214928911"></p>
<p>LL 是自顶向下，LR 是自底向上</p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208215012195.png" alt="image-20221208215012195"></p>
<p>图中的圈就是文法的表达能力</p>
<p><code>Antlr</code> 使用的算法是 LL：Adaptive LL(*)</p>
<p>LL(1) 语法分析器<strong>特点</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>自顶向下的</p>
</li>
<li class="lvl-2">
<p>递归下降的【可以递归下降的实现并不是一定要这样实现，<em>所有的递归都能改写成非递归形式</em>】</p>
</li>
<li class="lvl-2">
<p>基于预测分析表的</p>
</li>
<li class="lvl-2">
<p>适用于LL(1) 文法的</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208215627622.png" alt="image-20221208215627622"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208215632808.png" alt="image-20221208215632808"></p>
<p>对于中间节点的两个问题：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208215641601.png" alt="image-20221208215641601"></p>
<p>对于第二个问题——选择哪个产生式进行展开，可以暂时先放一下，即不管这个问题，先写一个语法分析器框架，如下【<em>任何一个语法分析器的大框架都是基本类似的，它们不同的是对于非终结符怎么选择产生式（备选分支）</em>】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221208220117781.png" alt="image-20221208220117781"></p>
<p>为每个非终结符写一个递归函数，比如上面对 A 这个非终结符进行展开</p>
<p><strong>例子</strong>：左边方框中的是语法规则</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209104500098.png" alt="image-20221209104500098"></p>
<p>同样是展开非终结符 S, 为什么前两次选择了 S → (S + F), 而第三次选择了 S → F</p>
<p><strong>因为它们面对的当前词法单元不同，根据当前看到的词法单元来决定选择哪个语法规则(备选分支)</strong></p>
<blockquote>
<p>前两次都是它看到的第一个字符是 ( ，因此选择第二个语法规则进行展开，第三次看到的不是括号，因此选择第一个进行展开</p>
</blockquote>
<p>上面的决定过程在实现上是通过<strong>预测分析表</strong>来实现的（空白表示报错，即不能展开）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209104812554.png" alt="image-20221209104812554"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209105333344.png" alt="image-20221209105333344"></p>
<p>因为每个单元格只有一个产生式可选，因此只需要<strong>根据当前字符就能确定要选择哪个产生式</strong></p>
<p>当有了预测分析表后，上面的框架就能具体化了：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209105533939.png" alt="image-20221209105533939"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209105847396.png" alt="image-20221209105847396"></p>
<p>LL(1)在预测展开时要选择哪个产生式，<strong>要考虑：</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209112145823.png" alt="image-20221209112145823"></p>
<ol>
<li class="lvl-3">
<p>【<strong>FIRST</strong>】使用的产生式后续的<strong>所有展开</strong>中，最左边的非终结符有没有我们想要的。</p>
<p>如对于 prog 的展开是选择 func_call 还是 decl，根据第一个非终结符是不是 int 即可判断</p>
</li>
<li class="lvl-3">
<p>【<strong>FOLLOW</strong>】如果想展开的非终结符，它有个备选分支<strong>是 ε，那就要考虑这个非终结符展成 ε 后</strong>，它<strong>后面的那个字符</strong>有没有我们想要的</p>
<p>如 int x; 在 optional_init 展开成 ε，那么就要看 optional_init  后面的 ; 在输入的字符串中有没有出现</p>
</li>
</ol>
<h3 id="形式化表述-FIRST和FOLLOW">形式化表述 FIRST和FOLLOW</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209113730193.png" alt="image-20221209113730193"></p>
<p>FISRT(α) 其中 α 是产生式的右部，即冒号右边的部分，FISRT(α) 是 α 所能产生的所有的句型（α 当然可以继续产生右部）的最左边的终结符的集合</p>
<p>如上面的 prog 中 FISRT(prog)={int, ID}， FISRT(decl)={int}</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221209113922505.png" alt="image-20221209113922505"></p>
<p>FOLLOW 中包含文件结束符 $ (EOF)</p>
<p>A 是产生式的左部，因此会出现在某些产生式的右部的部分中，如 optional_init 是产生式的左部，出现在 del 和 arg 的右部中</p>
<p>FOLLOW(A) 是非终结符 A 在其他所有产生式右部中紧跟在 A 右部的终结符的集合。<strong>此外</strong>如果 A 是其他产生式 B 中最右边的一个，如上面的optional_init 是 arg 最右边的，那么 FOLLOW(arg) 一定是 FOLLOW(optional_init) 的<strong>子集</strong></p>
<p>如 FOLLOW(optional_init) = {; , )}</p>
<h3 id="计算-FIRST和FOLLOW">计算 FIRST和FOLLOW</h3>
<p><strong>得到 FIRST和FOLLOW =&gt; 预测分析表 =&gt; LL(1)文法</strong></p>
<h4 id="FIRST">FIRST</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212152733310.png" alt="image-20221212152733310"></p>
<p>如果是非终结符，那么 FIRST(X) 包含 FIRST(Y<sub>1</sub>)，Y<sub>1</sub> 有可能推出 ε，这里要把 ε 给去掉，如果有  ε，那么后面的 for 循环就是看 Y<sub>2</sub> 的 FIRST</p>
<p>在 9-10 行是只有当整个 Y<sub>1</sub>~Y<sub>k</sub> 能推出 ε 时，才把  ε 加入到 FIRST(X)</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212160730782.png" alt="image-20221212160730782"></p>
<p>例子：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212161300396.png" alt="image-20221212161300396"></p>
<h4 id="FOLLOW">FOLLOW</h4>
<p>follow 集合中一定终结符，不会有 ε</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212161424240.png" alt="image-20221212161424240"></p>
<p>如之前的例子 FOLLOW(optional_init) = {; , )}</p>
<p>第一条产生式<strong>默认是开始符号</strong>，如果 X 是开始符号，那么要把 $ 加到 FOLLOW(X)，就像之前写的语法中的 prog，$ 是我们人为加进去的，prog 就是整个程序，程序结束自然是文件结束符 $</p>
<p>例子：</p>
<p>最开始的 FOLLOW 是空集，是一个个符号往里面加的，因此 FOLLOW(Z)是FOLLOW(Z)的子集，因此是空集，并且这也是不奇怪，在产生式中可以发现，在任何的产生式都不会在 Z 后有一个终结符</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212165019863.png" alt="image-20221212165019863"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212165319432.png" alt="image-20221212165319432"></p>
<h4 id="计算预测分析表">计算预测分析表</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212170216718.png" alt="image-20221212170216718"></p>
<p>对于 LL(1)，每个输入都有确定唯一的产生式，只要看最开始的终结符即可，如果选择了之后后面无法继续推下去了，说明输入的句子不符合 LL(1)，即语法错误</p>
<p>例子</p>
<p>对于每个非终结符 A，逐个看它的所有产生式，根据上面的<strong>两条规则</strong>【<em>规则(2)表示先看 FIRST 中有没有 ε，如果有，那么再看 t 是不是属于 FOLLOW</em>】，t 满足其中一条即可在这个位置 [A,t] 中填入这个产生式子的序号，即表示要展开这个非终结符并且输入字符为 t 时，应该选择的产生式</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212170736354.png" alt="image-20221212170736354"></p>
<p>显然上面的这个例子不是 LL(1) 文法</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212170801257.png" alt="image-20221212170801257"></p>
<p>（最左推导指每次选择最左边的非终结符进行展开）</p>
<p>因此 LL(0) 意思就是不需要看输入字符就知道用哪个展开式，因此只适用于每个非终结符都只有一个产生式的情况（即不需要选择产生式）</p>
<h3 id="非递归的预测分析算法">非递归的预测分析算法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212171333741.png" alt="image-20221212171333741"></p>
<p>图中的 S 就表示开始符号</p>
<p>用栈的方式来实现非递归</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212171341692.png" alt="image-20221212171341692"></p>
<p>第一个 else if 是指 X 不是 ip 所指的符号，同时又是一个终结符，说明输入的句子是语法错误的</p>
<p>注意压栈是要先压 Y<sub>k</sub>，因为是最左推导，要先推导 Y<sub>1</sub></p>
<h3 id="改造非-LL-1-文法的文法">改造非 LL(1) 文法的文法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212174759075.png" alt="image-20221212174759075"></p>
<p>这两个方法都是比较老的技术，<code>Antlr</code> 采用的是另一种新技术</p>
<h4 id="提取左公因子">提取左公因子</h4>
<p>比如 X→aB|aC，第一个字符都是 a，因此仍然无法判断选择哪个，因此可以把 a提取出来改写成 X→aD，D→B|C</p>
<h4 id="消除左递归">消除左递归</h4>
<p>要想让乘法比加法的优先级更高，那么就要在构建语法分析树的时候让乘法更靠近叶子节点。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212180724745.png" alt="image-20221212180724745"></p>
<p>要在文法中表达这个，那么就是引入一个中间的非终结符，如上面的 T，就是引入的新的，必须要 T 展开后才会去计算加法</p>
<p>对于这个左递归文法，如果用 LL(1) 算法来执行，在一开始的产生式中就要递归 E【如 E→E+T】，而不需要消耗任何词法单元，这样会造成死循环</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212181248305.png" alt="image-20221212181248305"></p>
<p>把上面的文法改造成右递归，就可以让 LL(1) 处理</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212181427062.png" alt="image-20221212181427062"></p>
<p>执行例子：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221212181543967.png" alt="image-20221212181543967"></p>
<p>最后三行体现了 $ 的必要性，那么当输入已经没有了，而栈中还有元素，因此栈中的元素都是使用生成 ε 的产生式</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>5 语义分析——符号表</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5%20%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    <content><![CDATA[<h1>5 语义分析——符号表</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213102821223.png" alt="image-20221213102821223"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213102827748.png" alt="image-20221213102827748"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213103048408.png" alt="image-20221213103048408"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213103052640.png" alt="image-20221213103052640"></p>
<p>对于通用语言有嵌套作用域，因此我们要写的其实是一个符号表树</p>
<p><strong>例子：</strong></p>
<p>一个函数带来了<strong>两个作用域</strong>：参数作用域和函数体作用域</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213103330978.png" alt="image-20221213103330978"></p>
<p><strong>实现：</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213103505911.png" alt="image-20221213103505911"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>define</code> 是在当前作用域加入符号</p>
</li>
<li class="lvl-2">
<p><code>resolve</code> 是根据名称查找符号是不是被定义过，<strong>不仅要在当前作用域查找，还要到上层父作用域查找</strong>，即沿着树不停向上查找。直到根节点都没找到就说明未定义使用，从而报错</p>
</li>
</ul>
<p>只考虑三种作用域：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213104634553.png" alt="image-20221213104634553"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>全局作用域（全局变量、函数名、内置类型如int,void）</p>
</li>
<li class="lvl-2">
<p>局部作用域（用大括号包围的作用域）</p>
</li>
<li class="lvl-2">
<p>函数作用域（函数的<strong>形参</strong>）</p>
</li>
</ul>
<p>更复杂的作用域</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213113627768.png" alt="image-20221213113627768"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>7 LLVM-IR</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/7%20LLVM-IR/</url>
    <content><![CDATA[<h1>7 LLVM-IR</h1>
<blockquote>
<p>在之前 LLVM 是 Low-Level Virtual Machine 的缩写，然后发展到现在，已经脱离的虚拟机的概念，因此 LLVM 不再是缩写，而是这个项目就叫 LLVM。</p>
</blockquote>
<p>LLVM 不是一个编译器，而是编译器的基础设施，当写一个编译器时，可以在 LLVM 上进行开发，而不是从头开始。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222200155928.png" alt="image-20221222200155928"></p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222200709146.png" alt="image-20221222200709146"></p>
<p>广义的 LLVM 是包含前端的，如 Clang 就是 LLVM 的子项目，但最核心的 LLVM 是注重优化和后端的。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222201302601.png" alt="image-20221222201302601"></p>
<p>中间表示是强类型的</p>
<h3 id="例子——没有函数体，只有函数声明">例子——没有函数体，只有函数声明</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222202516690.png" alt="image-20221222202516690"></p>
<h4 id="0-级优化">0 级优化</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222202510842.png" alt="image-20221222202510842"></p>
<p>@开头表示是全局变量/函数，%表示局部变量，align 是 4 字节对齐。</p>
<p>%8 的类型起始是 i1，因为布尔值一个 bit 就行，但返回值是 i32，因此要进行拓展。</p>
<p>LLVM 中要求 <strong>SSA 静态单赋值</strong>，即每个寄存器/变量只能被赋值一次，如上面的 %6 和 %7，再执行 %6 和 7 的操作后，不能把结果再存储到 %6 中</p>
<h4 id="1-级优化">1 级优化</h4>
<p>1 级优化-O1，其中 -g0 是指不输出调试信息，可以看到<strong>①</strong>优化后 main 函数的参数被优化掉了，因为从来没有使用过；<strong>②</strong>内存操作[上图的 store]被转换成虚拟寄存器操作[如%6,%7]：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222202958544.png" alt="image-20221222202958544"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222203308753.png" alt="image-20221222203308753"></p>
<p>SSA 在分支中会有点问题，左边的代码转换成中间的 IR 后，会出现不知道使用哪个 y 的情况：<strong>①</strong>一个解决的办法是<strong>使用 Φ 函数</strong>，根据控制流来决定；<strong>②</strong>也可以通过<strong>存到同一块内存</strong>来解决</p>
<h3 id="例子——有函数体——分支结构">例子——有函数体——分支结构</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222204823614.png" alt="image-20221222204823614"></p>
<p>图被称为 Control Flow Graph (CFG)</p>
<h4 id="0-级优化-2">0 级优化</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222204925688.png" alt="image-20221222204925688"></p>
<p>通过把值都存储到 %2 来解决分支问题</p>
<h4 id="1-级优化-2">1 级优化</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222204939222.png" alt="image-20221222204939222"></p>
<p>优化后就是使用寄存器，那么就不能用相同内存的方式来存储了，而是使用了 <strong>phi 函数</strong>来决定分支：如果是从 %3 的分支来的，那么就返回 %6 的值；如果是从 %1 的控制块来的，那就返回 1</p>
<h3 id="例子——有函数体——循环结构">例子——有函数体——循环结构</h3>
<h4 id="0-级优化-3">0 级优化</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222210011904.png" alt="image-20221222210011904"></p>
<p>这里是 <code>%8 = icmp sle i32 %6,%7</code> 是比较 <code>i</code> 是不是小于等于 <code>val</code></p>
<h4 id="1-级优化-3">1 级优化</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222210059615.png" alt="image-20221222210059615"></p>
<p>这里是 <code>%2 = icmp slt i32 %0,2</code> 是比较  <code>val</code>  是不是大于 <code>i=2</code></p>
<p>其中 %6 是在选择 i 取哪个值，%7 是在选择 tmep 取哪个值，%8 %9 分别为修改后的 i 和 temp</p>
<h2 id="？不能重复赋值"><mark>？不能重复赋值</mark></h2>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>6.1 语义分析——类型系统和类型检查</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/6.1%20%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h1>6.1 语义分析——类型系统和类型检查</h1>
<p>类型系统是一个语言的核心</p>
<blockquote>
<p>推荐学习一门函数式语言，才能更好了解类型系统的基本原理，可以更好的掌握编程【推荐书：<strong>实用编程语言理论基础</strong>、<strong>编程与类型系统</strong>】</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>类型检查</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213114403495.png" alt="image-20221213114403495"></p>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p>类型转换</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213114409676.png" alt="image-20221213114409676"></p>
<p>多个if 是冗长的，应该使用表驱动</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213114458265.png" alt="image-20221213114458265"></p>
</li>
<li class="lvl-2">
<p>类型综合</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213114615990.png" alt="image-20221213114615990"></p>
</li>
<li class="lvl-2">
<p>类型推导</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213115507573.png" alt="image-20221213115507573"></p>
<p>比如 <code>C++</code> 中的 <code>auto</code></p>
</li>
</ul>
<h3 id="数组类型文法举例">数组类型文法举例</h3>
<p>例子：定义数组类型</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221213115738444.png" alt="image-20221213115738444"></p>
<p>即其实没有二维数组，是一维数组的每个元素都是一个一维数组，递归定义</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221192042186.png" alt="image-20221221192042186"></p>
<h3 id="类型声明文法举例">类型声明文法举例</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221195848739.png" alt="image-20221221195848739"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221200026581.png" alt="image-20221221200026581"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>6.2 语义分析——属性文法</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/6.2%20%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<h1>6.2 语义分析——属性文法</h1>
<blockquote>
<p><strong>形式文法</strong>描述形式语言的基本想法是，从一个特殊的初始符号出发，不断的应用一些产生式规则，从而生成出一个字串的集合。产生式规则指定了某些符号组合如何被另外一些符号组合替换。</p>
<p>所有的文法分成四种类型：<strong><a href="https://baike.baidu.com/item/%E6%97%A0%E9%99%90%E5%88%B6%E6%96%87%E6%B3%95/8353653?fromModule=lemma_inlink">无限制文法</a></strong>、<strong><a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%96%87%E6%B3%95/19064473?fromModule=lemma_inlink">上下文相关文法</a></strong>、<strong>上下文无关文法</strong>和**<a href="https://baike.baidu.com/item/%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95/8982395?fromModule=lemma_inlink">正规文法</a>**</p>
<p>对于规则 V-&gt;<em>w</em>，上下文无关文法取名为“上下文无关”的原因就是因为字符 V 总可以被字串 w 自由替换，而无需考虑字符 V 出现的上下文。一个形式语言是上下文无关的，如果它是由上下文无关文法生成的。</p>
<p>上下文无关文法重要的原因在于它们拥有足够强的表达力来表示大多数<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">程序设计语言</a>的语法；实际上，几乎所有<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">程序设计语言</a>都是通过上下文无关文法来定义的。另一方面，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。例子可以参见LR 分析器和LL 分析器。</p>
</blockquote>
<p><strong>属性文法：为上下文无关文法赋予语义</strong></p>
<span id="more"></span>
<p>上下文无关文法是不含任何语义的，其中的语义是我们赋给它的，比如对于一个 ID，想知道它的类型，那么就赋于它一个类型属性</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221201244045.png" alt="image-20221221201244045"></p>
<p>上下文无关文法在表达语法方面是足够的，但在表达语义方面是不够的，<strong>要表达语义，那么需要使用到上下文相关文法</strong>，比如一个变量我们要求先声明才能使用，即这个变量依赖于之前它有没有被声明。</p>
<p>但是上下文相关文法的复杂度很高，即使上下文无关文法不够用了，也不愿意去用前者，因此引入了<strong>属性文法</strong>：在上下文无关文法的<strong>节点</strong>上<strong>赋予一个属性</strong>，在构建语法树的过程中计算属性，从而得到了语义。</p>
<p><strong>关键</strong>：安排好语义信息在语法分析树上的流动【DFS】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221201942685.png" alt="image-20221221201942685"></p>
<p>之前在 <code>Antlr</code> 都是离线遍历，即先构造了语法树，再去遍历一遍。</p>
<p>属性文法的想法是在构建的过程中就处理属性，减少一次对语法树的遍历：下面的 {a} 就是要执行的动作 ，相当于在离线处理中在 <code>exitX()</code> 后进行动作 a</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221202041694.png" alt="image-20221221202041694"></p>
<h2 id="例子1">例子1</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221202805121.png" alt="image-20221221202805121"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221202955462.png" alt="image-20221221202955462"></p>
<p>对 <code>exp</code> 赋予 <code>val</code> 值，因为每个 <code>exp</code>  的 <code>val </code> 都依赖它的子节点，那么要计算得到 <code>exp</code> 的值，只需要在 <code>exp</code> 文法的右部最右部执行动作即可，也即当子节点都完成后再执行动作</p>
<h3 id="code">code</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221203246304.png" alt="image-20221221203246304"></p>
<p>上面的 <code>members</code> 会在编译后<strong>完全地拷贝</strong>到生成的 <code>parser</code> 文件中，因为是生成 <code>java</code> 文件，所以这里也是用 <code>java</code> 写的内容【但没有代码提示】，这样我们就能在 <code>g4</code> 文件中使用这嵌入的 <code>java</code> 代码了</p>
<p>同时插入的动作都是写 <code>java</code> 代码</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221203832232.png" alt="image-20221221203832232"></p>
<p><code>expr</code> 有 <code>val</code> 属性，要引用时，使用 <code>$expr.val</code> 即可。前提是在 <code>expr</code> 文法处写明它的返回值 <code>expr returns [int val]</code>，用中括号</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221204403058.png" alt="image-20221221204403058"></p>
<p>直接 <code>$val</code> 表示在引用左部的 <code>expr</code> 的 <code>val</code></p>
<p>其中的 <code>getOrDefault</code> 是 <code>java8</code> 开始的 <code>HashMap</code> 中的方法：取不到就返回默认值</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221204655587.png" alt="image-20221221204655587"></p>
<p>在 <code>main</code> 中不需要 <code>listener,visitor</code>，而是在构建语法分析树的过程中就把上面的动作执行了</p>
<h2 id="例子2">例子2</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221204837195.png" alt="image-20221221204837195"></p>
<p>CSV 解析器</p>
<p>要求第一行是表格的列名，后面是表格的内容</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221205106467.png" alt="image-20221221205106467"></p>
<p>​</p>
<p>因为要得到总的行数，所以每个 <code>row</code> 被识别出来后就要有个统计行号++，并在最后输出这个行数的动作</p>
<p>要输出每行的 <code>values</code>，只有 <code>row</code> 不能得到列名，列名信息在 <code>hdr</code> 中，因此需要使用继承属性来传递列名</p>
<h3 id="code-2">code</h3>
<p>文法：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221211344739.png" alt="image-20221221211344739"></p>
<p>动作：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221211237028.png" alt="image-20221221211237028"></p>
<p>+= 所以最终 <code>rows</code> 可以得到一个 <code>row</code> 节点的 <code>list</code></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221221211411795.png" alt="image-20221221211411795"></p>
<p><code>locals</code> 表示局部变量</p>
<p><code>@init</code> 表示在还没有匹配 <code>row</code> 的时候进行初始化动作</p>
<p><code>@after</code> 是在匹配一次后执行的操作</p>
<p><strong>继承属性</strong>是通过参数的形式传递的，如 <code>row[$hdr.text.split(&quot;,&quot;)]</code> 就是把 <code>hdr</code> 分隔得到的 <code>String[]</code> 传递给 <code>row</code> ，因此在 <code>row</code> 处会用 <code>row[String[] columns] </code> 表示传入的参数</p>
<p>事实上，实践中将 <code>java</code> 和 <code>g4</code> 分开来写更好，即使用之前的离线分析（<code>listener,visitor</code>）更好，上面这样的属性文法，会导致 <code>g4</code> 文件可读性很差，因此 <code>Antlr4</code> 作者也不建议这种方式，但工业上为了性能，还是会有人这样来写。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222173741122.png" alt="image-20221222173741122"></p>
<h2 id="理论">理论</h2>
<h3 id="SDD">SDD</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222161152590.png" alt="image-20221222161152590"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SDD 唯一确定了语法分析树上每个非终结符节点的属性值</p>
</li>
<li class="lvl-2">
<p>SDD 没有规定以什么方式、什么顺序计算这些属性值</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222161644526.png" alt="image-20221222161644526"></p>
<p>S 属性定义的<strong>依赖图</strong>刻画了属性实例之间<strong>自底向上</strong>的<strong>信息流动</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222161810260.png" alt="image-20221222161810260"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222162124587.png" alt="image-20221222162124587"></p>
<p>上面是乘法的文法规则的右递归写法【因为T→T*T会有歧义，不确定是左结合还是右结合】；其中第二行的 T<sub>1</sub> 只是与左边的 T 相区分，并不是一个新的终结符</p>
<p>右递归的乘法会导致乘法是右结合的，但是我们可以通过调整语义规则来达到左结合的效果，如下使用继承属性和综合属性：【即在向下传递信息的过程中就已经开始计算了】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222162928170.png" alt="image-20221222162928170"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222163723544.png" alt="image-20221222163723544"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222163956571.png" alt="image-20221222163956571"></p>
<p>到 X<sub>i</sub> 的时候，前面的节点都已经计算完了，因此可以依赖它们</p>
<h4 id="例子1：">例子1：</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222165021176.png" alt="image-20221222165021176"></p>
<h4 id="例子2：">例子2：</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222165216368.png" alt="image-20221222165216368"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222165231575.png" alt="image-20221222165231575"></p>
<h4 id="例子3：">例子3：</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222165633498.png" alt="image-20221222165633498"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222165656924.png" alt="image-20221222165656924"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222165737146.png" alt="image-20221222165737146"></p>
<p>只使用 S 属性即可</p>
<h4 id="例子4：">例子4：</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222170056794.png" alt="image-20221222170056794"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222170101954.png" alt="image-20221222170101954"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222170114879.png" alt="image-20221222170114879"></p>
<h3 id="SDT">SDT</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222170740729.png" alt="image-20221222170740729"></p>
<p>左边即 SDD，右边为 SDT，即将 SDD 描述的语义规则翻译成动作嵌入</p>
<h4 id="S-属性后缀翻译方案">S 属性后缀翻译方案</h4>
<p>例子：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222170857375.png" alt="image-20221222170857375"></p>
<p>因为节点属性的计算仅仅取决于子节点或本身</p>
<p>实践代码见上面的 CSV 例子</p>
<h4 id="L-属性翻译方案">L 属性翻译方案</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222171038373.png" alt="image-20221222171038373"></p>
<p>对于 L 属性定义：</p>
<p>原则: 从左到右处理各个 X<sub>i</sub> 符号 对每个 X<sub>i</sub> , <strong>先计算继承属性, 后计算综合属性</strong></p>
<p>递归下降子过程 A → X1 · · · Xi · · · Xn</p>
<ol>
<li class="lvl-3">
<p>在调用 Xi 子过程之前, 计算 Xi 的继承属性</p>
<ul class="lvl-2">
<li class="lvl-5">实践中：以 Xi 的<strong>继承属性为参数</strong>调用 Xi 子过程</li>
</ul>
</li>
<li class="lvl-3">
<p>在 Xi 子过程返回之前, 计算 Xi 的综合属性</p>
<ul class="lvl-2">
<li class="lvl-5">实践中：在 Xi 子过程结束时<strong>返回 Xi 的综合属性</strong></li>
</ul>
</li>
</ol>
<p>例子：XY*</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222173302209.png" alt="image-20221222173302209"></p>
<p>伪代码：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222173523358.png" alt="image-20221222173523358"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222173535492.png" alt="image-20221222173535492"></p>
<h3 id="关于右递归">关于右递归</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222172747808.png" alt="image-20221222172747808"></p>
<p>对于不支持其他左递归的生成器，要想生成编译器，那么需要改写文法为右递归。</p>
<p>但是在<strong>左递归中的 S 属性定义</strong>，会在改写后的右递归中变成 <strong>L 属性定义</strong>。示例如下：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221222172905341.png" alt="image-20221222172905341"></p>
<p>继承属性来计算，综合属性往回传</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>0自顶向下</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/0%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</url>
    <content><![CDATA[<h1>课程主要内容</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220307171343107.png" alt="image-20220307171343107"></p>
<blockquote>
<p>每一章节分成两个部分：第一：这层的功能是什么，怎么实现这样的功能；第二：实例</p>
</blockquote>
<p>功能和服务：功能是具备的能力，服务是功能的体现，<strong>每一层的功能都通过向上层提供的接口来提供服务，当然本层的功能需要调用下层的接口才能实现</strong>。<em>即功能的涵盖面更大，比如一个设备有很强大的功能，但是不能被其他设备使用，那么就没有提供服务</em></p>
<span id="more"></span>
<p><strong>可靠性：不出错、不乱序、不重复、不丢失</strong></p>
<p>有些应用对<strong>可靠性要求非常高</strong>，因此是基于TCP的协议。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220307171445852.png" alt="image-20220307171445852"></p>
<p>而有些实时的应用<strong>对可靠性要求不高，但是对实时性要求非常高</strong>。<em>如麦克风传输到功放上面，如果一部分的信息丢失了，事实上对语言的理解没有什么影响，因此是基于UDP的。还有事务性的应用（如DNS域名解析）也是采用UDP，如果是TCP那么需要上图的两个往返，而UDP只要一个往返，请求然后就传回来，速度更快，如果出错了，那么只要再请求一次</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220307172719349.png" alt="image-20220307172719349"></p>
<p><strong>应用层</strong>协议规定了远程的应用进程之间通讯应该遵守的协议。如客户端和服务端，只要遵守这样的协议，那么不同厂商的设备也能交互</p>
<p><strong>传输层</strong>是在网络层提供的端到端的服务基础上来实现，提供在网络层主机到主机的基础上区分出并提供了进程到进程的服务，并且把IP提供的不可靠的服务通过TCP协议变成可靠的服务</p>
<p><strong>网络层</strong>（IP）是提供的端到端（end to end <strong>E2E</strong>）、主机到主机的服务，基于数据链路层提供的点到点的服务实现。特点是<strong>尽力而为</strong>（best effort）的，即没有保障的</p>
<blockquote>
<p>IP定义的是一种&quot;<strong>尽力而为</strong>&quot;（<strong>Best Effort</strong>）的通信服务，其中数据报可能被丢失、重复、延迟或乱序传递。</p>
</blockquote>
<p>网络层的工作方式有两种</p>
<ol>
<li class="lvl-3">
<p>传统方式：<strong>IP协议、路由协议</strong>。网络层<strong>基本功能</strong>是路由和转发，由路由协议交换路由信息，路由算法算出路由表，之后IP协议实体根据到来的分组的目标ip查路由表，找到合适的表项后，从相应的端口转发<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220307174255235.png" alt="image-20220307174255235">传统的方式不能增加新功能，只能按照写好的协议运行</p>
</li>
<li class="lvl-3">
<p>SDN（软件定义网络Software Defined Network）方式：<strong>数据平面（交换机）和控制平面（网络操作系统）</strong>。不仅仅根据目标IP，还有很多其他字段。可编程，可以增加新功能</p>
</li>
</ol>
<p><strong>数据链路层</strong>提供的点到点（point to point <strong>P2P</strong>）的<strong>以帧为单位</strong>的服务，即相邻的网络设备之间的连接，如上图，端到端的服务中间需要经过很多个点，两两之间就是点到点的服务</p>
<p><strong>物理层</strong>把数字信号变成物理信号，借助物理介质medium（网线，光缆，电话线等）传播。同样的也要处理物理信号到数字信号的转换</p>
<p><strong>物理介质</strong>可以说是第0层，物理层在物理介质的基础上实现</p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>8 LLVM-IR-(表达式的翻译与控制流的翻译)</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/8%20LLVM-IR-(%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E7%BF%BB%E8%AF%91)/</url>
    <content><![CDATA[<h1>8 LLVM-IR-(表达式的翻译与控制流的翻译)</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108200242191.png" alt=""></p>
<p>父节点需要为子节点传递跳转指令的目标标签，以继承属性的形式传递给子节点</p>
<p>如上面的例子中，<strong>B 是条件语句需要生成跳转指令</strong>，但 B 不知道该跳转到什么标签，如果 B 是 true，应该跳转到 S<sub>1</sub> 标签，而 S<sub>1</sub> 是 S 才知道的，因此由 S 传递给 B；如果 B 是 false，那么应该跳转到 S 后面的语句的标签，但 S 也不知道到底是什么标签，但 P 知道，因此需要由  p 传递给 B。</p>
<span id="more"></span>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108204811522.png" alt="image-20230108204811522"></p>
<h2 id="1-表达式的中间代码翻译">1. 表达式的中间代码翻译</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108204931249.png" alt="image-20230108204931249"></p>
<h2 id="2-数组引用的中间代码翻译">2. 数组引用的中间代码翻译</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108205535816.png" alt="image-20230108205535816"></p>
<p>继承属性得到数组类型的宽度</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108210004925.png" alt="image-20230108210004925"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108210108328.png" alt="image-20230108210108328"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108210132405.png" alt="image-20230108210132405"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108210832591.png" alt="image-20230108210832591"></p>
<p>a[i] 在上面中间代码中的 i64 0 是因为， %2 是 [2 × [3 × i32]]* 类型的，因此虽然它指向的是数组首地址，但因为类型是整个数组，因此直接对 %2 加上偏移量 i 会偏移 i 个数组大小的长度，这不是我们想要的，因此需要先降一层，先取偏移量为 0，得到指向同一个地址，但是类型是 [3 × i32]* 类型的，对这个类型进行我们想要的 i 偏移才是正确的</p>
<h2 id="3-控制流语句与布尔表达式的中间代码翻译">3. 控制流语句与布尔表达式的中间代码翻译</h2>
<h3 id="if-语句">if 语句</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108211354248.png" alt="image-20230108211354248"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108211603964.png" alt="image-20230108211603964"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108212423027.png" alt="image-20230108212423027"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108212415996.png" alt="image-20230108212415996"></p>
<p>上面例子中的代码生成的中间代码就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.code:</span><br><span class="line">	s.code:</span><br><span class="line">            goto L1 // 对应if(true)</span><br><span class="line">         L1:		// : 都是标签label</span><br><span class="line">            goto L0 // 对应if(false),因此assign没有被执行,直接到L0</span><br><span class="line">         L3:</span><br><span class="line">            assign  // 对应assign	</span><br><span class="line">    L0:</span><br></pre></td></tr></table></figure>
<h3 id="if-else语句">if-else语句</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108212933325.png" alt="image-20230108212933325"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108214001284.png" alt="image-20230108214001284"></p>
<p>上面例子中的代码生成的中间代码就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.code:</span><br><span class="line">	s.code:</span><br><span class="line">            goto L1 // 对应if(true)</span><br><span class="line">         L1:		// : 都是标签label</span><br><span class="line">            s1.code:</span><br><span class="line">            		goto L3 // 对应if(true)</span><br><span class="line">            	  L3:</span><br><span class="line">            	  	 assign</span><br><span class="line">            	     goto L0 // 第二层if-true结束，跳转到第二层if-else后面</span><br><span class="line">            	  L4:</span><br><span class="line">            	  	 assign</span><br><span class="line">            goto L0 // 第一层if-true结束，跳转到第一层if-else后面</span><br><span class="line">         L2:</span><br><span class="line">            assign  // 对应第一层else的assign	</span><br><span class="line">    L0:</span><br></pre></td></tr></table></figure>
<h3 id="while-语句">while 语句</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230108215139970.png" alt="image-20230108215139970"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110191037687.png" alt="image-20230110191037687"></p>
<p>上面例子中的代码生成的中间代码就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.code:</span><br><span class="line">	s.code:</span><br><span class="line">		 begin:</span><br><span class="line">            goto L1 // 对应while(true)</span><br><span class="line">         L1:		// : 都是标签label</span><br><span class="line">            s1.code:</span><br><span class="line">            		goto L4 // 对应if(false)</span><br><span class="line">            	  L3:</span><br><span class="line">            	  	 assign</span><br><span class="line">            	     goto begin // 跳到while循环开始</span><br><span class="line">            	  L4:</span><br><span class="line">            	  	 assign</span><br><span class="line">            goto begin // 跳到while循环开始</span><br><span class="line">    L0:</span><br></pre></td></tr></table></figure>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110191439360.png" alt="image-20230110191439360"></p>
<h2 id="4-布尔表达式的中间代码翻译">4. 布尔表达式的中间代码翻译</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110193632692.png" alt="image-20230110193632692"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110194827798.png" alt="image-20230110194827798"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110195006411.png" alt="image-20230110195006411"></p>
<p>短路求值，当 B<sub>1</sub> 是 true 时，那么直接就是 B 是 true 了，当 B<sub>1</sub> 是 false，才跳转到 B<sub>2</sub> 的 code</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110195133929.png" alt="image-20230110195133929"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110195337123.png" alt="image-20230110195337123"></p>
<p>关系运算符表达式：≥，&gt;等</p>
<p>例子：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110201224607.png" alt="image-20230110201224607"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230110201234027.png" alt="image-20230110201234027"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理参考书目</title>
    <url>/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE/</url>
    <content><![CDATA[<p>龙书本科教学版足够</p>
<p>《ANTLR4权威指南》</p>
<p>《自制编译器》</p>
<p>LLVM在Linux中使用</p>
<p>建议两本书都看</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>D: 龙书《编译原理》对上课的理论有帮助</p>
</li>
<li class="lvl-2">
<p>A:《ANTLR4 权威指南》对实验有帮助</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2应用层</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/2%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1>2应用层</h1>
<h2 id="2-1应用层原理">2.1应用层原理</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408083459526.png" alt="image-20220408083459526"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408083559286.png" alt="image-20220408083559286"></p>
<span id="more"></span>
<p>应用层的协议是最多的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408083923954.png" alt="image-20220408083923954"></p>
<p>网络应用在端系统中部署</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408084212167.png" alt="image-20220408084212167"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408085603973.png" alt="image-20220408085603973"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408085709771.png" alt="image-20220408085709771"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408090057554.png" alt="image-20220408090057554"></p>
<p>即时通讯，如QQ等</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408090255651.png" alt="image-20220408090255651"></p>
<p>客户端进程是主动的，服务器进程是被动的</p>
<p>P2P的会话中也有C和S之分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408090837148.png" alt="image-20220408090837148"></p>
<p>应用进程需要解决：<strong>标识</strong>（将自己和其他应用进程区分开）和<strong>寻址</strong>（让对方能够找到自己）</p>
<p>层间服务的<strong>地点</strong>（SAP）和<strong>形式</strong>（原语）</p>
<h4 id="问题一">问题一</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408091321745.png" alt="image-20220408091321745"></p>
<p>要标识和寻址一个应用进程，需要<strong>3</strong>个要素：<strong>主机IP</strong>，<strong>使用TCP还是UDP</strong>，<strong>TCP/UDP的端口号</strong></p>
<p>本质上是由<strong>端口号来区分不同的应用进程</strong>，TCP/UDP均为<strong>16bit</strong>的端口号</p>
<p>用IP和port标识端节点 <em>end point</em> 本质上主机进程的通信由2个端节点构成</p>
<h4 id="问题二">问题二</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408091806498.png" alt="image-20220408091806498"></p>
<p>层间接口需要携带的<strong>3</strong>个信息：<strong>内容即SDU</strong>，<strong>谁传的（IP+port）</strong>【<em>否则就不能由对方传回来了</em>】，<strong>传给谁（IP+port）</strong></p>
<p>TCP/UDP实体封装源和目的的端口号和数据，进一步交给IP实体来封装源IP和目标IP</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408092728670.png" alt="image-20220408092728670"></p>
<p>采用<strong>套接字  socket</strong>减少层间传输的信息量，避免在一次连接过程中频繁地封装谁传的/传给谁的信息</p>
<p>socket就是一个<strong>整数</strong>，代表了源IP，源端口，目标IP，目标端口的<strong>四元组(TCP)</strong>。在<strong>UDP</strong>中是源IP，源端口号的<strong>二元组</strong>。<strong>代表了会话session关系</strong>，而不仅仅是主机的标识，一个进程和多个不同的进程进行连接有不同的socket<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408095149125.png" alt="image-20220408095149125"></p>
<p><strong>socket是本地的标识，对方并不知道</strong>，是本地OS管理的4元组，为了<strong>便于管理</strong>而引入的</p>
<h5 id="TCP-socket">TCP socket</h5>
<p>便于<strong>应用层和传输层的约定</strong>【<em>其他层不知道，对方更不知道</em>】，<strong>建立连接时操作系统返回一个socket整数</strong><br>
所以发送时应用层的应用进程只要使用这个socket整数，OS根据socket表就知道上面的四元组，也即在传输层可以得到对应的四元组，<strong>使得穿过层间的信息量最少【只需两个：socket和SDU】，而不必在应用进程中每次都指定四元组</strong><br>
收的时候根据收到的四元组可以根据建立起的socket的表找到对应的socket，再找到哪个应用进程创建了这个socket，从而把数据发给相应的应用进程</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408094330596.png" alt="image-20220408094330596"></p>
<h5 id="UDP-socket">UDP socket</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408095556687.png" alt="image-20220408095556687"></p>
<p>UDP每次的报文都是独立的，可能上次发给A，下次就发给B</p>
<p>UDP socket<strong>只代表本地IP和本地端口</strong>，<strong>不代表会话关系</strong>，因为UDP是无连接的</p>
<p>因此发送报文时应用层的应用进程传给传输层的UDP实体需要<strong>三个信息：UDP socket、目标IP和端口、SDU</strong><br>
同理在接收报文时传输层要将对方的IP和port传给对应的应用进程，让其知道是谁传来的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408100429128.png" alt="image-20220408100429128"></p>
<h4 id="问题三">问题三</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408110805050.png" alt="image-20220408110805050"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408120454787.png" alt="image-20220408120454787"></p>
<p><strong>实体是指和网络交互有关的，实现协议的软硬件部分</strong>，而其他部分就不是网络中讲的实体了，如应用程序的应用协议是我们说的实体，但其他部分IO处理等就不是了，如html不是协议的一部分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408140107691.png" alt="image-20220408140107691"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408140738102.png" alt="image-20220408140738102"></p>
<p>UDP似乎什么服务都不能提供，那能不能直接用IP协议呢，当然是不能的，UDP能够区分出进程：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408141012843.png" alt="image-20220408141012843"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408141737019.png" alt="image-20220408141737019"></p>
<blockquote>
<p><strong>SSL <em>Secure Sockets Layer</em></strong> 安全套接字协议及其继任者传输层安全（<em><strong>Transport Layer Security，TLS</strong></em>）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密</p>
</blockquote>
<p>SSL在TCP上实现，位于<strong>应用层</strong>，应用采用SSL库如<strong>https</strong>中的s就是指SSL  <em>Hyper Text Transfer Protocol over Secure Socket Layer</em></p>
<h2 id="2-2-Web-and-HTTP">2.2 Web and HTTP</h2>
<p>web是一种应用，http是支持web应用的协议</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408143534573.png" alt="image-20220408143534573"></p>
<p>web网页本身是对象，网页中嵌了对象，但不是对象本身，而是对象的链接，任何对象都可以<strong>由URL唯一标识</strong> <em>uniform resource locator</em>统一资源定位系统</p>
<p>如果支持匿名访问，那么用户名口令可以省略</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408144657478.png" alt="image-20220408144657478"></p>
<p>客户端是浏览器，服务端是服务器</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408144925175.png" alt="image-20220408144925175"></p>
<p>服务器应用层会有一个特殊的socket <strong>wait socket守护socket</strong>，守护在80端口，当有其他web客户端与服务器建立请求时会产生新的socket，服务器可以并发和多个web客户端连接，这种是<strong>连接socket</strong></p>
<p>浏览器得到html文件后 会将其画出来，其中的图片等资源会通过URL又去请求不同的其他服务器，得到后插入。<strong>得到资源后TCP连接就会关闭</strong></p>
<p>HTTP是<strong>无状态</strong>的，即<strong>不维护客户的任何信息</strong>，仅仅是建立连接，关闭连接，在此之前和在结束之后，服务器不会有客户的任何信息，<strong>相当于没有记忆</strong></p>
<h3 id="HTTP连接">HTTP连接</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408151025542.png" alt="image-20220408151025542"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408151753283.png" alt="image-20220408151753283"></p>
<p>请求报文很短，传输时间一般可以忽略不计，但返回的对象资源需要传输时间*【注意这个不是传播时间，传播时间还是有的，局域网忽略不计】*</p>
<p><strong>HTTP 1.0</strong>默认非持久连接，每次请求返回对象资源后就会关闭连接，如果客户在这个服务器上有多个请求，那么要多次TCP连接</p>
<p><strong>HTTP 1.1</strong>默认持久连接，在返回对象资源后连接不会关闭，如果还有请求可以直接使用之前建立的连接下载（<em>可以在报文的首部行中设置connection : close来关闭</em>）</p>
<h4 id="非持久连接">非持久连接</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408152047623.png" alt="image-20220408152047623"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408152055260.png" alt="image-20220408152055260"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408153030709.png" alt="image-20220408153030709"></p>
<p><strong>往返时间RTT</strong> <em>round-trip time</em></p>
<p>所以一次http请求需要<strong>2RTT+对象的传输时间</strong></p>
<h4 id="持久连接">持久连接</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408153908013.png" alt="image-20220408153908013"></p>
<p>需要在一个服务器上请求多个对象</p>
<p><strong>非流水线方式</strong>：一次请求得到一个对象回来后，然后再发出第二个请求</p>
<p><strong>流水线方式</strong>：客户端不等待对象回来，而是发出第一个请求后再发出第二个请求，之后对象依次回来。<strong>HTTP 1.1默认方式</strong></p>
<h3 id="HTTP请求报文">HTTP请求报文</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408154045220.png" alt="image-20220408154045220"></p>
<p><strong>请求报文</strong>和<strong>响应报文</strong>两种</p>
<p>两种报文<strong>都是ASCII码可读的</strong>，都是用ASCII编码的【<em>是早期为了便于调试而采取的措施</em>】</p>
<p>请求报文格式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>请求行/命令行</strong>：<strong>GET</strong>(获取HTML head和body)、<strong>POST</strong>(上传)、<strong>HEAD</strong>(获取头，只需要HTML文件的head，不要body，一般是搜索引擎来建立索引的)</p>
<p>HTTP 1.1增加了<strong>PUT</strong>和<strong>DELETE</strong></p>
<p>PUT用来改资源，Post用来增资源</p>
<p><a href="https://blog.csdn.net/qq_36183935/article/details/80570062">HTTP中GET，POST和PUT的区别</a></p>
</li>
<li class="lvl-2">
<p><strong>首部行</strong></p>
</li>
<li class="lvl-2">
<p>(一个额外回车换行)</p>
<p>在请求行和首部行的每一行都是有回车换行的 CR LF 【<strong><em>Carriage Return</em> 对应\r 回车 <em>Linefeed</em>  对应\n 换行</strong>】</p>
</li>
<li class="lvl-2">
<p><strong>可能的实体行</strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408155225160.png" alt="image-20220408155225160"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408155922625.png" alt="image-20220408155922625"></p>
<p>提交表单信息：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>post：将表单放在实体部分</p>
</li>
<li class="lvl-2">
<p>get：将表单信息放在URL中上载，即?后表示参数，参数名=参数值，不同参数用&amp;隔开</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408160309903.png" alt="image-20220408160309903"></p>
<h3 id="HTTP响应报文">HTTP响应报文</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408162825032.png" alt="image-20220408162825032"></p>
<p>响应报文格式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态行：协议版本，状态码，状态信息(对状态码的解释，如OK)</p>
</li>
<li class="lvl-2">
<p>首部行：包含Last-Modified 记录修改时间，从而保证后面所讲的缓存能够与服务器内容保持一致</p>
<p><strong>HTTP需要自己维护报文的界限</strong>，因为<strong>TCP是以字节流</strong>的形式传输的（<strong>UDP是报文形式</strong>），因此报文的字节数很重要</p>
</li>
<li class="lvl-2">
<p>(一个额外的\r \n)</p>
</li>
<li class="lvl-2">
<p>数据</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408163445614.png" alt="image-20220408163445614"></p>
<h3 id="Cookies">Cookies</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408164117892.png" alt="image-20220408164117892"></p>
<p><strong>Cookies弥补了HTTP无状态带来的一些问题</strong></p>
<p>客户端第一次请求后，服务端在响应报文的头部加上一个cookies并保存在服务器的数据库中，客户端收到cookies由浏览器保管*(至于怎么保存，协议不管，协议只规范cookies这个传输过程)*，下次客户端发送请求时，会在请求报文的头部加上cookies，服务端对比cookies就能确定请求的客户端是谁了</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408165507430.png" alt="image-20220408165507430"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408165702704.png" alt="image-20220408165702704"></p>
<h3 id="Web-Cache-代理服务器proxy-server">Web Cache 代理服务器proxy server</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408165937799.png" alt="image-20220408165937799"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408170249449.png" alt="image-20220408170249449"></p>
<p>因为热点总是被更多的人访问，所以缓存是很有效的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408171051613.png" alt="image-20220408171051613"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408170857524.png" alt="image-20220408170857524"></p>
<p>排队延迟计算公式</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408171422030.png" alt="image-20220408171422030"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408171436894.png" alt="image-20220408171436894"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408172032549.png" alt="image-20220408172032549"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408172101286.png" alt="image-20220408172101286"></p>
<p>但有风险，可能服务器中发生改变，但缓存中没变，因此proxy server会使用Conditional GET向服务器发送请求，并在头部加入了**If-modified-since: <date>**的条件如果没有修改，那么服务器返回304 Not Modified表示没有修改；如果修改了，那么就和GET命令完全一样，将对象返回给proxy server 200 OK</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408173037727.png" alt="image-20220408173037727"></p>
<h2 id="2-3-FTP">2.3 FTP</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408173248267.png" alt="image-20220408173248267"></p>
<p>早期的文件分发方式</p>
<p>客户端和<strong>服务器的21号端口</strong>建立TCP连接，这个连接称为<strong>控制连接</strong>，完成用户认证之后客户端可以向服务器发出一系列指令，如list等</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408174001802.png" alt="image-20220408174001802"></p>
<p>当客户端发出下载命令时，服务器会<strong>主动</strong>和<strong>客户端的20号端口</strong>建立TCP连接，称为<strong>数据连接</strong></p>
<p>控制和数据传输在分别<strong>两个连接</strong>上进行，把控制连接称为<strong>带外</strong>(out of band)，带内即数据连接</p>
<p>FTP是<strong>有状态的</strong>，需要维护用户信息</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220408174530084.png" alt="image-20220408174530084"></p>
<p>命令以ASCII文本形式传输</p>
<h2 id="2-4-E-Mail">2.4 E-Mail</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410155542417.png" alt="image-20220410155542417"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410160144318.png" alt="image-20220410160144318"></p>
<p>三个主要组成部分：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>用户代理</strong> <em>user agent</em>：写邮件的软件，因此这个软件就是邮件应用的代理（如web应用的代理是浏览器）</p>
</li>
<li class="lvl-2">
<p><strong>邮件服务器</strong> <em>mail servers</em>：守护在<strong>25号端口</strong></p>
<p>包含</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>邮箱</strong>(<em>mailbox</em> contains incoming messages for user。<em>注意是保存发给用户的邮件，而不是发出去的邮件</em>)</p>
</li>
<li class="lvl-4">
<p><strong>报文队列</strong> <em>message queue</em> contains outgoing (to be sent) mail messages</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>协议</strong>：</p>
<p>发送协议：SMTP</p>
<p>拉取协议：POP3，IMAP，HTTP</p>
</li>
</ul>
<p><strong>过程</strong>：用户代理将邮件发给邮件服务器**（使用SMTP）<strong>，在邮件服务器的队列中，然后邮件服务器按照队列顺序逐个将邮件发送给对应的邮件服务器</strong>（使用SMTP）<strong>，对应的邮件服务器收到邮件后存储在对应用户的邮箱mailbox中，该用户通过它的用户代理从它在邮件服务器的邮箱中拉取邮件</strong>（使用POP3等）**，在用户代理上呈现</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410161707703.png" alt="image-20220410161707703"></p>
<h3 id="SMTP">SMTP</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410161352910.png" alt="image-20220410161352910"></p>
<p><strong>SMTP 简单邮件传输协议</strong> <em>Simple Mail Transfer Protocol</em></p>
<p>所有<strong>报文请求和响应以及邮件本身的内容</strong>都必须是<strong>7位ASCII码</strong>，即高位为0的可打印字符，不允许超过ASCII码的范围【<em>这是最原始的形式，但不能满足传输中文，附件的要求，因此下面有MIME</em>】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410162038066.png" alt="image-20220410162038066"></p>
<p>如果client发完一个邮件后，<strong>还有到达这个服务器的邮件，那么会继续发</strong>，直达client没有要发给它的邮件了，那么发出QUIT命令终止</p>
<p><em>在一次连接中可以发很多的邮件，而不是连接一次仅发送一个</em></p>
<p>因为都是ASCII码，所以外面可以手动输入上面的过程来模拟用户代理发送邮件</p>
<p><a href="https://blog.csdn.net/qq_44848479/article/details/122907746">使用telnet程序连接qq smtp协议邮箱服务器发送邮件</a></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410165723409.png" alt="image-20220410165723409"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP<strong>一个响应报文仅一个对象</strong>，即比如客户群向服务器请求一个html文件，那么html文件就是这个对象，html中的每个图片对象不会包含在其中，只会包含一个URL</p>
</li>
<li class="lvl-2">
<p>SMTP<strong>则会将多个对象包含在一个报文中</strong>，比如<strong>发送附件有10张图片，一个录音等</strong>，都是封装在一个报文中发送的</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410170222763.png" alt="image-20220410170222763"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>首部行：如to、from、subject(即title)、cc(即抄送)</p>
<p><strong>注意不是</strong>MAIL FROM, RCPT TO的<strong>命令</strong></p>
</li>
<li class="lvl-2">
<p>主体</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410170711930.png" alt="image-20220410170711930"></p>
<p><strong>MIME 多媒体邮件拓展</strong> <em>multimedia mail extension</em></p>
<p>使用<strong>base64编码</strong>，将不能用ASCII表示的文本用ASCII表示出来，<strong>从而拓展了可以传输的内容</strong>，这边base64编码，对方再解码即可</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410171204330.png" alt="image-20220410171204330"></p>
<p>可以直接使用HTTP来下载邮件（HTTP本身就能上载和下载）</p>
<h3 id="POP3">POP3</h3>
<p><strong>邮局访问协议</strong> <em>Post Office Protocol</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410171606952.png" alt="image-20220410171606952"></p>
<p>list后显示邮件编号和字节大小</p>
<h3 id="IMAP">IMAP</h3>
<p><strong>互联网邮件访问协议</strong> <em>Internet Mail Access Protocol</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410171822319.png" alt="image-20220410171822319"></p>
<p>比POP3更复杂，允许用户在服务器上建立目录来管理邮件，因此需要<strong>保留用户状态</strong></p>
<p>而POP3没有这样的功能，因此是<strong>无状态的</strong></p>
<h2 id="2-5-DNS">2.5 DNS</h2>
<p>域名解析系统/域名服务器 <em>Domain Name System</em></p>
<p>DNS不是给人使用的应用，而是给其他应用使用的应用，<strong>主要实现域名到IP地址的转换</strong>，还有<strong>其他的功能</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410172711786.png" alt="image-20220410172711786"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410173230795.png" alt="image-20220410173230795"></p>
<p>域名用平面化的命名很容易重复，因此应该使用层次化的命名</p>
<p>使用一台设备解析域名是不可行的，因此分布式的维护和解析域名（多个服务器）</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410173420630.png" alt="image-20220410173420630"  />
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410173544614.png" alt="image-20220410173544614"></p>
<p>DNS运行在<strong>UDP的53号端口</strong>，很强的<strong>事务性</strong>，询问域名-IP，响应即可，没必要建立连接，且报文长度不超过 UDP 的 512 B 限制</p>
<p><strong>互联网的很多核心功能是在网络边缘的端系统上的应用层的应用进程实现的，如DNS</strong></p>
<p>DNS：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>域名到IP地址的转换（主要）</p>
</li>
<li class="lvl-2">
<p>主机别名到规范名字的转换</p>
<p><a href="http://xn--www-eo8e.baidu.com">如www.baidu.com</a>，这个名字即为别名，不可能只有一台服务器维护百度网站，背后是一堆的服务器，<strong>因此需要将这个别名转化成具体哪个服务器的规范命名</strong>，所以转换得到的IP地址是这个服务器的IP地址【<strong>别名→规范名字→IP</strong>】</p>
</li>
<li class="lvl-2">
<p>邮件服务器别名到规范名字的转换</p>
</li>
<li class="lvl-2">
<p><strong>负载均衡</strong> <em>load distribution</em> 在主机别名到规范命名时选择负载较小的服务器</p>
</li>
</ul>
<h3 id="问题一-2">问题一</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410174759148.png" alt="image-20220410174759148"></p>
<p>对<strong>主机</strong>命名从<strong>树叶</strong>往树根走，每过一层加一个dot.区分</p>
<p>对<strong>域</strong>命名从<strong>树枝</strong>往上走，每过一层加一个dot.区分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410175414882.png" alt="image-20220410175414882"></p>
<p>如果只有一个root，那么万一宕机了，那么全部都不能使用，因此一共有13个根域名服务器，可以从最近的开始root往下找，如果宕机了，可以换成别的root。【事实上有上百台根域名服务器，由 13 个机构维护，逻辑上是 13 个根域名服务器】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410180009812.png" alt="image-20220410180009812"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410180000350.png" alt="image-20220410180000350"></p>
<p>域的划分是逻辑的，网络的划分是物理的</p>
<h3 id="问题二-2">问题二</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410191550308.png" alt="image-20220410191550308"></p>
<p>根据情况划分区域，尽可能均衡，zone和zone之间是<strong>互不相交的</strong></p>
<p>对于一个区域所属的名字服务器，<strong>这个名字服务器中的信息是权威的</strong>，但在其他区域内，就不是权威的了（<em>下面介绍为什么在其他区域也能发挥作用</em>）</p>
<blockquote>
<p><strong>域名服务器可以划分为以下四种不同的类型:</strong></p>
<ul class="lvl-1">
<li class="lvl-2"><strong>根域名服务器</strong> 根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。</li>
<li class="lvl-2"><strong>顶级域名服务器</strong> 这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</li>
<li class="lvl-2"><strong>权限域名服务器</strong> 这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。</li>
<li class="lvl-2"><strong>本地域名服务器</strong> 本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</li>
</ul>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410191932022.png" alt="image-20220410191932022"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410192148807.png" alt="image-20220410192148807"></p>
<p><strong>TLD</strong> <em>Top-level Domain</em></p>
<blockquote>
<p>例如太平洋岛国图瓦卢的顶级域名是tv，因此将其卖给了电视公司，所以不再是国家级顶级域名</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410192534380.png" alt="image-20220410192534380"></p>
<p>资源记录 <em>resource records</em></p>
<p>TTL 生存时间 <strong>对于权威记录，那么为无限大</strong>，而如果是在别的区域名字服务器中的记录，即非权威，是<strong>缓存</strong>在这里的，<strong>为的是提高性能和速度</strong>，<strong>默认生存时间为2天</strong>，2天后就会把记录<strong>删除</strong>，<strong>为的是保持和权威服务器的一致性</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410193236576.png" alt="image-20220410193236576"></p>
<p><strong>NS即上层域中要保存其子域的指针</strong>，保存了子域所属的权威服务器的<strong>域名</strong>，因此要访问这个DNS服务器，还需要有一条TYPE=A的记录来得到这个服务器的IP地址</p>
<p><strong>除了A以外的TYPE都是得到名字</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410193746954.png" alt="image-20220410193746954"></p>
<p>一台主机要上网需要<strong>4个信息</strong>：</p>
<p>①IP ②子网掩码 ③default gateway默认网关 ④local name server DNS服务器</p>
<p>这些信息是自动分配或者手动分配的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410194430915.png" alt="image-20220410194430915"></p>
<p>其实可以指定任意一台DNS作为local name server ，但local name server 一般设置比较近的/位于同一个子网的，速度更快</p>
<blockquote>
<p>本地域名服务器起着代理的作用，会将该报文转发到域名服务器的等级结构中。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</p>
</blockquote>
<h4 id="名字解析过程">名字解析过程</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410194515330.png" alt="image-20220410194515330"></p>
<p><strong>递归查询</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410194710644.png" alt="image-20220410194710644"></p>
<p>当不在区域内/缓存中没有时，local name server 联系13个根名字服务器中的一个，<strong>让根服务器代替本地DNS从根往下找，当然根服务器也让下一级服务器返回它查到的结果，递归下去，最后由根服务器返回得到的结果给本地DNS</strong>，但这样根服务器压力很大，从它这个引申出一大堆递归【<em>就像递归消耗很大一样</em>】</p>
<p><strong>迭代查询</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410195001066.png" alt="image-20220410195001066"></p>
<p>还是先问根名字服务器，但根服务器不知道的话，只是给出下一级服务器的地址，让本地DNS去问它，<strong>然后由本地服务器去逐个询问</strong>，<strong>最终由权威服务器告诉本地DNS</strong></p>
<p>如果得到了这个域名-IP映射，本地DNS会<strong>缓存</strong>下来默认两天</p>
<blockquote>
<p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。</p>
</blockquote>
<blockquote>
<p>通常采用以下模式：<strong>从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。</strong></p>
</blockquote>
<blockquote>
<p><strong>DNS解析</strong>：浏览器缓存——》系统hosts文件——》本地DNS解析器缓存——》本地域名服务器（本地配置区域资源、本地域名服务器缓存)——》根域名服务器——》主域名服务器——》下一级域名域名服务器 客户端——》本地域名服务器（递归查询) 本地域名服务器—》DNS服务器的交互查询是迭代查询</p>
</blockquote>
<h4 id="DNS协议、报文">DNS协议、报文</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410195705289.png" alt="image-20220410195705289"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410200048667.png" alt="image-20220410200048667"></p>
<p><strong>ID号可以使得查询过程流水线化</strong>，如果没有ID号，那么必须等上次查询完成才能发出下次的查询</p>
<p><strong>DNS查询和响应的报文格式一样</strong>，根据flags判断是查询还是响应</p>
<h3 id="问题三-2">问题三</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410200216555.png" alt="image-20220410200216555"></p>
<p>增加一个域需要增加两条信息：①该域的域名和其DNS名字的对应关系 ②该DNS名字和DNS的IP的对应关系</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220410200741964.png" alt="image-20220410200741964"></p>
<p>DNS比较健壮</p>
<h3 id="nslook">nslook</h3>
<p>在 cmd 中使用 nslook 程序可以进行域名解析，此外解析会<strong>自动在输入的域名后面加上当前 DNS 的域名</strong>，因此如下</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220509120525161.png" alt="image-20220509120525161"></p>
<p>如果不是当前域名下的网站，那么会逐个向上查询，根据请求可以看到，这里使用的是递归查询，所有结果都由 DNS 返回给主机</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220509120551574.png" alt="image-20220509120551574"></p>
<h2 id="2-5-P2P应用">2.5 P2P应用</h2>
<p>一类P2P应用</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411082154789.png" alt="image-20220411082154789"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411082655420.png" alt="image-20220411082655420"></p>
<p>当N很小时，服务器的能力很强，客户端的下载速度是瓶颈，随着N增加，服务器成为瓶颈，时间线性增加</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411083256812.png" alt="image-20220411083256812"></p>
<p>流媒体也是类似的，因此一个视频看的人越多反而越流畅<a href="https://blog.csdn.net/zhanghan18333611647/article/details/52135694">传统媒体—&gt;流媒体—&gt;加P2P的流媒体的演变之路</a></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411083133701.png" alt="image-20220411083133701"></p>
<h3 id="P2P的管理模式">P2P的管理模式</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411084856104.png" alt="image-20220411084856104"></p>
<h4 id="非结构化P2P">非结构化P2P</h4>
<p>peer和peer之间的有相互的TCP关系，则两者之间有一条边，这个边是应用层上逻辑的，事实上两个主机之间可能会经过很多的路由器。<strong>节点和节点之间边的关系是任意的，构成的overlay 覆盖网是任意的，称为非结构化</strong></p>
<h5 id="集中式目录">集中式目录</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411085017807.png" alt="image-20220411085017807"></p>
<p>目录服务器维护了哪些IP在线；哪些IP具有哪些资源</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411085234213.png" alt="image-20220411085234213"></p>
<h5 id="完全分布式">完全分布式</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411085435407.png" alt="image-20220411085435407"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411085920889.png" alt="image-20220411085920889"></p>
<p>一个主机向与之逻辑上连接的<strong>所有主机发出查询</strong>（假定已经构成了覆盖网），然后一传十，十传百的形式泛洪flooding查询。</p>
<p>会使用TTL来限制泛洪的跳数；或者记录自己已经查询过了，避免回环</p>
<p><strong>覆盖网的构建</strong>：在下载Gnutella软件时会有一个表，其中是很可能在线的节点，本主机向这些节点发送ping，如果这些节点中有在线的，再向它的所有邻居发送ping，和上面的泛洪一样，所有收到ping的节点以pong回应，本主机只要选择若干个节点建立TCP连接当作邻居即可。</p>
<p>当一个节点退出时，只要向其邻居发送即可，这些邻居各自再去找一个新的邻居以维持邻居树目</p>
<h5 id="混合体">混合体</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411090925779.png" alt="image-20220411090925779"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411091340324.png" alt="image-20220411091340324"></p>
<p><strong>hash</strong>作为文件的唯一标识</p>
<h4 id="DHT-分布式散列表-（结构化）P2P">DHT(分布式散列表)（结构化）P2P</h4>
<p>节点与节点之间是可以构成环，树的关系，是有结构的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411095558203.png" alt="image-20220411095558203"></p>
<p>如环状：每个节点将其IP地址做哈希，根据hash值从小到大首位相连（逻辑），然后文件也同样做哈希，约定好如上面hash值为6~88的文件存储在hash为88的peer节点中。这样的P2P网络模式有效减少了资源定位的开销，提高了P2P 网络的可扩展性</p>
<h3 id="BitTorrent">BitTorrent</h3>
<p><strong>非结构化</strong>P2P，可以看作混合体式</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411091702522.png" alt="image-20220411091702522"></p>
<p>把文件分成若干个<strong>256KB的块</strong></p>
<p><strong>BT工作原理</strong>：在文件网站/搜索引擎中下载torrent文件，其中包含了对应文件的Tracker Server，然后向Tracker Server发出请求，它会分配一些peer节点的列表给请求客户端，从而请求客户端加入洪流，互通有无：<em>拿出自己多余的东西给对方，与之进行交换，以得到自己所缺少的东西</em></p>
<p><strong>Torrent洪流</strong>：相当于一个小组</p>
<p><strong>BitMap</strong>标识一个文件的块的拥有情况，比如10表示拥有这个文件的第一个块，但没有第二个块。通过<strong>bitmap交换</strong>就可以知道相互之间的块的拥有情况</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411092252498.png" alt="image-20220411092252498"></p>
<p>新加入Torrent的节点随机的向其他的节点请求块，因为此时什么都没有，bitmap都是0，<strong>当达到4个1后</strong>，<strong>优先请求稀缺的块</strong>，即在洪流中持有该块的节点数目很少的块。<strong>这样可以让稀缺的块逐渐不稀缺，有利于集体利益</strong></p>
<p>并且有一个策略：如果作为服务方，会优先向为我提供服务最好的节点提供服务，是一种你对我好，我对你好的模式</p>
<p>因此新加入的节点得到稀缺块后，别人向他请求的会更多，那么根据策略，他得到别人服务的机会会更大，<strong>这样就可以将集体的利益转化成个人利益</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411093708760.png" alt="image-20220411093708760"></p>
<p>因为请求的节点数大于能服务的节点数，所以需要排队，Alice每隔30s随机选择一个节点，而不是根据之前周期该节点对Alice提供的服务进行评估优先选择。<strong>这样优化疏通可能可以导致如下的情况</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220411094037836.png" alt="image-20220411094037836"></p>
<h2 id="2-7-CDN">2.7 CDN</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412130235338.png" alt="image-20220412130235338"></p>
<h3 id="DASH-基于HTTP的动态自适应流">DASH 基于HTTP的动态自适应流</h3>
<p>可以看出 <strong>HTTP 可不仅仅只用于 web，还可以用于文件的上下载、音视频的播放</strong>。<strong>HTTP 就是一个传输协议，和应用无关。</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412131542549.png" alt="image-20220412131542549"></p>
<p>将每个块编码于不同的码率，形成多个内容相同，码率不同的块，分别独立存储，提前部署，可能分布于不同服务器，可以是源服务器，或者缓存服务器</p>
<p>所有的这些块（不同内容/不同码率）用<strong>告示文件 <em>manifest file</em></strong>记录它们的URL、码率、时长等信息</p>
<p>客户端根据带宽和缓冲区的情况动态地决定请求什么样的块，什么编码速率的块</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412132003989.png" alt="image-20220412132003989"></p>
<p><strong>DASH 解决了不同客户端、不同网络情况的需求问题</strong></p>
<h3 id="CDN">CDN</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412132624437.png" alt="image-20220412132624437"></p>
<p><strong>CDN解决的是单个服务器向大量用户提供服务的质量低的问题</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412132817469.png" alt="image-20220412132817469"></p>
<p><strong>ICP需要买CDN运营商的服务</strong>，从而提高他们为用户提高的服务质量</p>
<p><strong>内容加速服务：<strong>CDN运营商部署了很多的缓存节点，客户端不需要向源服务器请求，而是可以在中间</strong>域名解析重定向</strong>到离它最近，服务质量最好的缓存节点</p>
<p>显然，前提是ICP要提前将内容部署在缓存节点中，但选择哪些内容部署，是一个策略问题（根据二八定律，一般选择热门的内容部署）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412134021517.png" alt="image-20220412134021517"></p>
<p>CDN运营商部署缓存节点的方式：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412134147448.png" alt="image-20220412134147448"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>enter deep，将</strong> <strong>CDN</strong> <strong>服务器深入到许多接入网。</strong> 就是在很多的 local ISP 的范围内部署了很多的缓存节点，把一些内容预先部署到这一缓存节点当中。</p>
<p>这种部署方式更接近用户，节点数量多、离用户近，用户请求资源时跳数更少，网络带宽大。</p>
<p>但是因为部署的节点非常靠下，所以需要部署非常多的节点，这些节点管理起来很困难。</p>
</li>
<li class="lvl-2">
<p><strong>bring home，</strong> <strong>部署在少数(10个左右)关键位置节点上</strong>，比如将服务器簇安装于 POP （网络服务提供点 Point of presence）附近，离若干一级 ISP POP 较近的位置。就是在一些上层的 ISP，有很多的数据中心机房的关键节点，然后我选的位置离那些关键数据中心机房比较近。</p>
<p>这样的话，只要我卡住这些关键的位置，也可以向用户提供一些好的服务。但相比于enter deep服务稍弱</p>
</li>
</ul>
<p><strong>CDN位于应用层提供服务 over the top</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412165604792.png" alt="image-20220412165604792"></p>
<ol>
<li class="lvl-3">
<p>客户端要访问URL上的视频</p>
<p><strong>【如果采用了DASH】</strong> <strong>：先要获取告示文件</strong>（如下面的网飞的例子中），然后去<strong>动态逐个请求每个块</strong>，比如一个块的地址在源服务器并且缓存在了CDN中，那么和上图的流程一样</p>
<p><strong>【如果不考虑DASH】</strong>：那么就相当于ICP把整个视频缓存在了CDN服务器中，客户端直接去根据上图流程访问到CDN服务器上的视频</p>
</li>
<li class="lvl-3">
<p>客户端向local DNS请求域名解析</p>
</li>
<li class="lvl-3">
<p>local DNS再去请求权威名字服务器的域名解析</p>
<p>权威名字服务器知道哪些内容需要加速，因此可以将这个url的解析<strong>重定向</strong>，返回一个新的域名地址【即视频位于的CDN缓存服务器的URL】给local DNS</p>
</li>
<li class="lvl-3">
<p>local DNS再去解析这个域名地址，如果没有缓存，那么同理要请求CDN运营商的权威名字服务器，然后得到CDN服务器的IP</p>
</li>
<li class="lvl-3">
<p>local DNS将IP返回给客户端，客户端去请求这个IP即可</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220412170509774.png" alt="image-20220412170509774"></p>
<h2 id="2-8-TCP-socket编程">2.8 TCP socket编程</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413132013178.png" alt="image-20220413132013178"></p>
<p>应用进程只需要借助socket传和收即可，是逻辑是上的传输，不必关心真正是怎么传输的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413132249795.png" alt="image-20220413132249795"></p>
<p>字节流保证是可靠的，但不保证报文和报文之间的界限</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413132447084.png" alt="image-20220413132447084"></p>
<p><strong>创建-捆绑-等待</strong></p>
<p>阻塞式即如果没有发送过来的用户连接，那么函数就在这里阻塞，不往下走</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413132959115.png" alt="image-20220413132959115"></p>
<p>sockaddr_in是代表了一个端节点</p>
<p>这个数据结构不仅可以用于ip的通讯，也可以用于ipx的通讯，<strong>所以是地址簇</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413133403809.png" alt="image-20220413133403809"></p>
<p>IP地址位于h_addr_list[0]</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413133459987.png" alt="image-20220413133459987"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413134829762.png" alt="image-20220413134829762"></p>
<p>sad就是sockaddr_in结构体</p>
<p>客户端不需要bind，而服务器需要bind，如果不绑定，那么客户端不知道去找谁，但客户端OS会隐含地bind</p>
<p>当client connect【将socket表项的对方IP，port填充好】后会向server发TCP连接建立请求，client阻塞在这，server收到信息解除阻塞，返回一个新的值，即connection socket，在socket表中填充了socket，双方的IP和port，当server返回连接确认信息后，client也解除阻塞，这样就真正建立起了连接</p>
<p>close后，对应表项就会被删除</p>
<p><strong>多个进程可以使用同一个端口</strong>，如welcome socket和connection socket使用的都是80端口</p>
<blockquote>
<p>一个进程监听端口，经验告诉我们，如果多次启动一个进程会报错：“Address already in use!&quot;。这<strong>是由于bind函数导致的</strong>，由于该端口号已经被第一个进程监听了。有哪些方法可以实现多个进程监听同一个端口呢？</p>
<p>fork：只要在绑定端口号（bind函数）之后，监听端口号之前（listen函数），用fork（）函数生成子进程，这样子进程就可以克隆父进程，达到监听同一个端口的目的，而且还相互竞争，提高程序效率。</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413140334193.png" alt="image-20220413140334193"></p>
<p>main的参数传入服务器的域名和port</p>
<p>这里没有bind，是OS隐式bind，随机选取一个暂时没有用到的端口号bind，所以上面的sockaddr_in中代表的是服务器的端节点IP+port</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413140805502.png" alt="image-20220413140805502"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413140914413.png" alt="image-20220413140914413"></p>
<p>cad存放client的端节点，sad存放自己的</p>
<p>main的参数只需传入自己的port即可</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413141425906.png" alt="image-20220413141425906"></p>
<p>中间省略了将clientSentence转换成全部大写的并存储在capitalizedSentence里面的代码【<em>这个服务器执行的是将client传入的句子转换成大写返回的过程</em>】</p>
<blockquote>
<p>htons是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</p>
<p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用big-endian排序方式。</p>
</blockquote>
<p><strong>listen</strong>是把在为一个client服务的过程中又来了一个请求，那么把新的加到队列中，下次循环就从队列中取出一个服务，队列的长度为10 ，超过10就拒绝服务</p>
<h2 id="2-9-UDP-socket">2.9 UDP socket</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413144944222.png" alt="image-20220413144944222"></p>
<p>UDP的PDU为数据报datagram，IP的无连接也叫datagram，因此需要结合上下文理解具体指哪个</p>
<p>client同样是隐式bind</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413151951336.png" alt="image-20220413151951336"></p>
<p>也没有welcome和connection之分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413152123534.png" alt="image-20220413152123534"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413152247442.png" alt="image-20220413152247442"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413152253881.png" alt="image-20220413152253881"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413152323322.png" alt="image-20220413152323322"></p>
<h2 id="2-10-小结">2.10 小结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413152416540.png" alt="image-20220413152416540"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220413152527103.png" alt="image-20220413152527103"></p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>1概述</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1>1.概论</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309163725161.png" alt="image-20220309163725161"></p>
<span id="more"></span>
<h2 id="1-1-什么是Internet">1.1 什么是Internet</h2>
<p>互联网仅仅是网络的一种（是最为广泛的，有上亿的设备连接到互联网），还有其他的如银行的专用网络、军用的专用网络等</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309165049534.png" alt="image-20220309165049534"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309165745292.png" alt="image-20220309165745292"></p>
<p>计算机网络中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>节点：<strong>主机节点</strong>（可以是源、也可以是目标）（各种终端设备）、<strong>数据交换节点</strong>（既不是源，也不是目标）（如路由器【工作在网络层】、交换机【工作在数据链路层】）用<strong>方形</strong>表示主机节点，用<strong>圆形</strong>表示数据节点</p>
</li>
<li class="lvl-2">
<p>边：<strong>接入（access）链路</strong>（方的和圆的连在一起）、<strong>主干（backbone）链路</strong>（圆的和圆的连接）</p>
</li>
<li class="lvl-2">
<p>协议(protocol)</p>
</li>
</ul>
<p><strong>互联网</strong>就是多个网络通过网络互联设备连接起来的巨型的网络</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309170227294.png" alt="image-20220309170227294"></p>
<p><strong><em>hosts</em> <em>=</em> <em>end systems</em></strong></p>
<p>通信链路的传输速率即带宽以bps作为单位</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309171543056.png" alt="image-20220309171543056"></p>
<p>IETF(<em>因特网工程任务组(Internet Engineering Task Force, IETF )</em>)制定的RFC文档为<strong>请求评论</strong> <em>(Request For Comment, RFC)</em>，一个协议可能和多个RFC文档相关</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309185346935.png" alt="image-20220309185346935"></p>
<p>协议(protocol)：<strong>对等层(Peer Layers)<strong>的实体，在通信过程中，应该遵守的规范和标准。规定了</strong>报文格式、次序、动作</strong></p>
<p><strong>PDU 协议数据单元</strong> 在每个层次上都有特指：应用层——message 传输层——segment 网络层——packet(如果是无连接方式的也称datagram) 数据链路层——frame</p>
<p>互联网中所有的通信行为都有协议的约束</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309185614677.png" alt="image-20220309185614677"></p>
<p>从服务的角度：互联网是<strong>分布式的应用进程</strong>（网络存在的理由）和<strong>为应用进程提供通讯服务的基础设施</strong>（<strong>即源主机/目标主机应用层以下的所有应用实体</strong>）其中基础设施向应用进程提供服务的形式是API(<strong>套接字接口( socket interface：应用层在TCP/IP协议族中使用传输层服务的形式)</strong>)：面向连接的服务（TCP）、无连接的服务（UDP）</p>
<h2 id="1-2网络边缘">1.2网络边缘</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309190820574.png" alt="image-20220309190820574"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309191056550.png" alt="image-20220309191056550"></p>
<p><em>network edge</em>、<em>network core</em>、<em>access networks</em></p>
<p>网络核心的作用就是<strong>数据交换(switch)</strong>，让任意两个网络边缘设施都能连接</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309192041636.png" alt="image-20220309192041636"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CS客户端/服务器(client server)模式</strong>：主从模式——<strong>服务器是主</strong>，所有的资源都在服务器，<strong>客户端是从</strong>，所有的资源都来源于服务器<br>
<strong>可扩展性差</strong>，随着请求的增多，服务器能力下降，并且在达到一定的阈值后，服务器断崖式下落</p>
</li>
<li class="lvl-2">
<p><strong>P2P</strong> **peer-peer模式：**一个分布式应用进程进程既是服务器，又是客户端，因此随着peer节点增多，请求的节点增多，提供的节点也在增多。因此使用在文件分发系统之中。<em>如迅雷，可以从迅雷上下载东西，即向多个其他主机上的迅雷请求资源的不同片段，因为是分布式的，同时当我们拥有了一些片段也可以向其他主机的迅雷客户端提供服务</em></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309193316313.png" alt="image-20220309193316313"></p>
<p>面向连接：连接状态的维持仅仅是<strong>端系统维护的。中间节点不维护连接</strong></p>
<blockquote>
<p>当中间路径上的节点都知道要维护被称为有连接，如下面的分组交换中的虚电路网络</p>
</blockquote>
<p><strong>可靠性</strong>：因此应用进程不需要考虑纠错等可靠性问题，当采用TCP时就已经假定可靠了</p>
<p><strong>流量控制</strong>是可以协调发送方的发送速度和接收方的接收速度，不会出现数据传输太快把数据淹没的情况</p>
<p><strong>拥塞控制</strong>：当中间链路拥堵时，如果发送方发的太快，那么到了中间某个节点，可能无法处理，中间节点会把这些数据丢弃。因此TCP还要考虑中间通路的通畅情况，<strong>堵塞时降低发送速度</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220309194237963.png" alt="image-20220309194237963"></p>
<p><strong>无连接</strong>：无需建立连接状态，直接发送</p>
<h2 id="1-3网络核心">1.3网络核心</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314200736805.png" alt="image-20220314200736805"></p>
<p><strong>circuit switch 电路交换</strong></p>
<p><strong>packet switch 分组交换</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314201021637.png" alt="image-20220314201021637"></p>
<p><strong>建立</strong>一个<strong>独享的线路</strong>，<strong>保障了性能</strong>，利用独享的线路来进行通信，<strong>在之前需要建立链接</strong>。一般用于电话网</p>
<p>如果不用那么就会造成浪费，就像拨通了电话，但是不说话仍然需要收费</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314201622149.png" alt="image-20220314201622149"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314201719791.png" alt="image-20220314201719791"></p>
<p><strong>频分FDM</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314202141900.png" alt="image-20220314202141900"></p>
<p><strong>时分TDM</strong>是指在将一个时钟周期划分成多个片，比如每个周期开始的第一个片分给第一个用户，第二个片分给第二个用户</p>
<p><strong>波分WDM</strong>采用光链路，即光纤的方式，将可用波段划分成多片</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314202522237.png" alt="image-20220314202522237"></p>
<p>0.5s建立连接，10s传输（<strong>传输时间</strong>），但传输完并不意味着对方已经接受到了，这里面存在着<strong>传播延迟</strong>（也即在线路上传播所需要的时间）。<strong>在局域网中，传播延迟可以忽略，但在广域网中，传播延迟是不能忽略的</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314202723859.png" alt="image-20220314202723859"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314202905403.png" alt="image-20220314202905403"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>优势：<strong>节点要把整个分组都存下来，然后再转发到下一个节点，<strong>存储转发机制</strong>保证了传输过程中一个时间点</strong>只会用到一个链路</strong>，只要这个链路接收到了全部才能用下一个链路转发，这样其他的链路就可以空闲出来用于其他的通信（<strong>共享</strong>）<em>（如果不存储，直接转发，那么和线路交换就是一样的了，只不过这里使用了全部的带宽）</em></p>
</li>
<li class="lvl-2">
<p>没有建立连接的时间消耗</p>
</li>
<li class="lvl-2">
<p><strong>代价：</strong><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314203920067.png" alt="image-20220314203920067"></p>
</li>
<li class="lvl-2">
<p><strong>延迟会更大</strong></p>
</li>
<li class="lvl-2">
<p><strong>可能需要排队</strong>，因为下一条线路可能被其他连接占用 了</p>
</li>
<li class="lvl-2">
<p>如果路由器缓存用完了，那么分组会被<strong>抛弃</strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314203619477.png" alt="image-20220314203619477"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314203648517.png" alt="image-20220314203648517"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314204146968.png" alt="image-20220314204146968"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314204351989.png" alt="image-20220314204351989"></p>
<p><strong>链路上的复用</strong>（多个传输同时使用这条链路）没有固定模式，不像前面介绍的时分等，称为<strong>统计多路复用</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314221204247.png" alt="image-20220314221204247"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314221719766.png" alt="image-20220314221719766"></p>
<p>之所以是9而不算10是因为当线路上的流量满的，没有余量的时候，即流量强度=1的时候线路就会崩溃，此时的排队延迟为无穷大。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314222334629.png" alt="image-20220314222334629"></p>
<p>分组交换网络（存储-转发）按照有无网络层的连接分成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据报网络</strong> <strong>datagram</strong>（<strong>无连接</strong>）</p>
<p><strong>每个</strong>源主机发向目标主机的<strong>分组</strong>，携带了目标主机<strong>完整的地址</strong>，因此两个主机在通讯之前<strong>不需要握手</strong>，在交换节点当中也不需要维护它们的通讯状态，只是<strong>将传入的分组根据路由表转走</strong>，至于到底是哪两个主机通讯并不关注，<strong>每个分组的传输都是独立的</strong>。<em>就像写信一样，每一封信都有完整的地址</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314223223616.png" alt="image-20220314223223616"></p>
<blockquote>
<p>通往同一个目标主机的分组可能走的是不同的路径，因为路由表可能在变，使得通过的路径不同</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>虚电路网络</strong>（有连接-不仅仅体现在源和目标，而且体现在中间的所有交换节点上）</p>
<p>需要靠<strong>信令</strong>建立一条<strong>虚拟的线路</strong>，在节点之间要维护通讯状态，<strong>每个分组携带了一个虚电路号</strong>，而不是完整地址。分组按照虚电路号来标识，存储-转发。<em>就像打电话</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314223757919.png" alt="image-20220314223757919"></p>
<p>每个交换节点都有虚电路表项</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220314224006105.png" alt="image-20220314224006105"></p>
<h2 id="1-4-接入网与物理媒体">1.4 接入网与物理媒体</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322173619078.png" alt="image-20220322173619078"></p>
<p>通过<strong>接入网</strong>将网路边缘接入网络核心</p>
<p>共享/独享</p>
<h3 id="住宅接入：拨号、DSL、电缆、FTTH和卫星">住宅接入：拨号、DSL、电缆、FTTH和卫星</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322174505970.png" alt="image-20220322174505970"></p>
<p>90年代中后期</p>
<p><strong>modem 调制解调器</strong>即<strong>猫</strong>（Modulator&amp;Demodulator）</p>
<p><strong>利用已经有的电话线</strong>（而不是直接将光缆铺到每家每户-成本太大-如长城宽带），将上网数据**(数字信号)<strong>加载到音频信号</strong>(模拟信号)**上，利用电话线（能够保证4kHz）传输</p>
<p><strong>缺点</strong>：带宽窄，56Kbps左右，不能同时上网和打电话；以拨号上网速率上限56KBps为界，低于56KBps称为“窄带”，以上称为“宽带”</p>
<h4 id="DSL-数字用户线路">DSL 数字用户线路</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322180306872.png" alt="image-20220322180306872"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322175857363.png" alt="image-20220322175857363"></p>
<p>DSL调制解调器 <strong>仍然是利用电话线调制解调</strong>，0~4kHz专用于音频，4kHz以上用于传输上网数据*（电话线可以保证4kHz，在4k以上还是可以挖掘的）*，同时<strong>4k以上</strong>划分为非对称的两个部分，<strong>一段用于上行，一段用于下行</strong>，<strong>用于下行的更大</strong>，<strong>即非对称</strong>【4~50kHz为上行，50kHZ~1MHz为下行】</p>
<p>因此本地电话公司是ISP，要求住宅离电话公司比较近，如果比较远，必须采用其他形式的接入网</p>
<p><strong>专用线路</strong></p>
<blockquote>
<p>非对称数字用户线路（ADSL，Asymmetric Digital Subscriber Line）是数字用户线路（xDSL，Digital Subscriber Line）服务中最流行的一种。</p>
<p>因为普通用户通常下载速度比上传速度更重要</p>
</blockquote>
<h4 id="线缆网络">线缆网络</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322180340735.png" alt="image-20220322180340735"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322181255963.png" alt="image-20220322181255963"></p>
<p>电缆调制解调器</p>
<p>一部分用于传输原有的下行的数字电视广播，一部分用于互联网上行数据，一部分用于互联网下行数据</p>
<blockquote>
<p>上行是你的电脑发送数据到互联网上；下行是你从互联网上下载数据</p>
</blockquote>
<p>通过有线电视公司接入的互联网是<strong>共享的带宽</strong>（因为原来的广播电视也是共享广播媒体）</p>
<h4 id="FTTH-Fiber-To-The-Home光纤到户">FTTH Fiber To The Home光纤到户</h4>
<p>最简单的光纤分布网络称为直接光纤，从本地中心局到每户设置一根光纤。更为一般的是，从中心局岀来的每根光纤实际上由许多家庭共享，直到<strong>相对接近这些家庭的位置，该光纤才分成每户一根光纤</strong></p>
<p>两种光纤分布体系结构：<strong>主动光纤网络</strong>（Active Optical Network, AON)和<strong>被动光纤网络</strong>(Passive Optical Network, PON)</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407211813741.png" alt="image-20220407211813741"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322181614354.png" alt="image-20220322181614354"></p>
<h3 id="企业接入网络">企业接入网络</h3>
<p><strong>以太网</strong>：局域网技术</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407212538504.png" alt="image-20220407212538504"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407212622045.png" alt="image-20220407212622045"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407212703374.png" alt="image-20220407212703374"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322181723453.png" alt="image-20220322181723453"></p>
<p>通过交换机的级联，端系统直接连接到交换机上</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322181907009.png" alt="image-20220322181907009"></p>
<h3 id="物理媒体">物理媒体</h3>
<p>物理媒体即可以当作第0层</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322192657987.png" alt="image-20220322192657987"></p>
<p>无屏蔽双绞线(Unshielded Twisted Pair, UTP)常用在建筑物内的计算机网络中，即用于局域网(LAN)中</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322193022993.png" alt="image-20220322193022993"></p>
<p>有线电视的入户线一般是同轴电缆</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322193252969.png" alt="image-20220322193252969"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>导引性媒体</strong>：信号在固体媒介中传播，传播得远</p>
</li>
<li class="lvl-2">
<p><strong>非导引性媒体</strong>：如信号在开阔的地方传播，如无线电，传播的距离短</p>
</li>
</ul>
<h2 id="1-5-Internet结构和ISP">1.5 Internet结构和ISP</h2>
<p>ISP 网络服务提供商，如江苏移动，南京大学</p>
<p>另一种网络划分：<strong>按关系的远近来划分</strong>：将关系密切的在一个网络当中的设备称为ISP网络（其中包含很多的小的ISP），互联网是由很多的ISP网络构成的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322194640657.png" alt="image-20220322194640657"></p>
<p>如果将每两个ISP两两连接代价会很大，是不可扩展的（即扩展到一定规模，性能迅速下降，代价非常大，这种特性就是不可扩展）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322195255983.png" alt="image-20220322195255983"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322195352322.png" alt="image-20220322195352322"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322195615711.png" alt="image-20220322195615711"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322201306386.png" alt="image-20220322201306386"></p>
<p><strong>ICP 互联网内容提供商</strong>，如百度，谷歌。会构建自己的网络，建立自己的机房，因为接入他人的ISP成本高，且他人的ISP可能无法提供更好的服务。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322200256295.png" alt="image-20220322200256295"></p>
<p>因此内容提供商的机房会建在<strong>离核心的ISP比较近的地方</strong>（<em>当然也会考虑到很多因素，如很多的数据中心机房是部署在贵州的，如苹果与云上贵州，原因是贵州地形复杂山多，地震少，机房不容易受到外界影响，有些部署在极地附近，考虑的是降温方便，成本低</em>），这样用户通过核心ISP很快就能访问到谷歌的机房，很快就能返回去。同时如果这个机房没有想要的内容，那么谷歌用<strong>自己的专用线路</strong>（有的可能是自己搭建的线缆，有的可能是租用已有的线缆）从其他机房获取数据返回来，再提供给用户。</p>
<h3 id="松散的层次结构">松散的层次结构</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322200716939.png" alt="image-20220322200716939"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322200937618.png" alt="image-20220322200937618"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>节点少</strong>（多了成本高）</p>
</li>
<li class="lvl-2">
<p><strong>带宽大</strong>（覆盖国家/国际，速度慢无意义）</p>
</li>
<li class="lvl-2">
<p>ISP之间通过peering link或者通过IXP连接</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322201053710.png" alt="image-20220322201053710"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322201123499.png" alt="image-20220322201123499"></p>
<p>下层ISP是上层ISP的customer，需要通过上层ISP去连接网络的其他部分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322201229556.png" alt="image-20220322201229556"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322201413107.png" alt="image-20220322201413107"></p>
<p><strong>通过接入多个高层ISP，可以提高服务质量</strong></p>
<h2 id="1-6-分组延时、丢失和吞吐量">1.6 分组延时、丢失和吞吐量</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322202322104.png" alt="image-20220322202322104"></p>
<h3 id="延时-delay">延时 delay</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322202413624.png" alt="image-20220322202413624"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322202537762.png" alt="image-20220322202537762"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>节点处理延迟</strong></p>
</li>
<li class="lvl-2">
<p><strong>排队延迟</strong>：注意是指不同分组之间排队，而不是分组内部的bit排队</p>
</li>
<li class="lvl-2">
<p><strong>传输延迟</strong>：路由器将分组发送到链路上的时间，也即<strong>存储转发延迟</strong></p>
</li>
<li class="lvl-2">
<p><strong>传播延迟</strong>：数据在链路上传播的时间</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322203539894.png" alt="image-20220322203539894"></p>
<p><strong>广域网WAN的信道容量比局域网LAN要大</strong>：因为数据在广域网上链路长，传播延迟大，因此广域网的链路上同时可能正在传播多个数据报。而局域网链路短，传播延迟可以忽略不计，因此一个时间点链路上一般只有很少的数据报</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322203801790.png" alt="image-20220322203801790"></p>
<p><strong>Tracert 命令</strong>用 IP 生存时间 (TTL)(time to live) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。<strong>向每个路由器发出3个探测分组</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先，tracert送出一个TTL是1的IP 数据包到目的地</p>
</li>
<li class="lvl-2">
<p>IP数据报每到一个路由器就把<strong>TTL-1</strong>，直到<strong>TTL=0</strong>时，路由器会把这个数据报丢弃并送回一个**「ICMP time exceeded」<em><em>消息</em>（包括发IP包的源地址，IP包的所有内容及路由器的IP地址）</em></p>
</li>
<li class="lvl-2">
<p>接着tracert 再送出另一个TTL是2 的数据包……</p>
</li>
<li class="lvl-2">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322210303328.png" alt="image-20220322210303328"></p>
</li>
<li class="lvl-2">
<p>当数据包到达目的地后，该主机则不会送回ICMP time exceeded消息，一旦到达目的地，由于tracert通过UDP数据包向<strong>不常见端口(30000以上)</strong>（<em>即没有应用程序在监听这个端口，数据发过来只能被丢弃</em>）发送数据包，因此会收到**「ICMP port unreachable」**消息，故可判断到达目的地。</p>
</li>
</ul>
<blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322212900840.png" alt="image-20220322212900840"></p>
</blockquote>
<blockquote>
<p>如github的tracert，在中间延迟会突然增加，那么可能就是出现了trans-oceanic link跨洋的连接</p>
</blockquote>
<h3 id="丢失-loss">丢失 loss</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322210739797.png" alt="image-20220322210739797"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果丢失节点和前一个节点之间的链路是可靠的，那么会由前一个节点重传。</p>
</li>
<li class="lvl-2">
<p>如果中间的链路是不可靠的<em>如以太网，向上层提供的服务就是不可靠的</em>，且采用TCP，由源主机重传</p>
</li>
<li class="lvl-2">
<p>如果中间的链路是不可靠的，且采用的是UDP，那么根本不重传</p>
</li>
</ul>
<h3 id="吞吐量-throughput">吞吐量 throughput</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322211436294.png" alt="image-20220322211436294"></p>
<blockquote>
<p>容量capacity 有时指的是能容纳多少分组，即信道容量，有时指的是带宽，要看上下文</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322211929165.png" alt="image-20220322211929165"></p>
<p><em>bottleneck</em> <em>link</em> <strong>瓶颈链路，即最小带宽的链路</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220322212505648.png" alt="image-20220322212505648"></p>
<p>考虑最小带宽时还要考虑到多个传输都在使用的一个链路，如这里10个连接，那么R所在链路的带宽实际应为R/10</p>
<p><strong>但事实上R<sub>c</sub>、R<sub>s</sub>通常是瓶颈链路</strong></p>
<h2 id="1-7协议层次和服务模型">1.7协议层次和服务模型</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用模块化来将复杂的系统分解，模块与模块之间任意调用</p>
</li>
<li class="lvl-2">
<p>使用分层的方式来将复杂系统分解，相邻两层进行调用，不允许或者不建议跨层调用</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407093921810.png" alt="image-20220407093921810"></p>
<p>计算机网络采用分层方式：层次的内部更新换代对其他层次是透明的，问题分解，但效率会降低</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407085159872.png" alt="image-20220407085159872"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对等层采用相同的协议，交换PDU</p>
</li>
<li class="lvl-2">
<p>协议需要通过层间接口借助下层的服务实现（物理层不需要）</p>
<p><em>当然会包含所有更下层的服务，但增加了直接下层和对等实体交互的过程中形成的新特性（否则这一层没有意义）</em></p>
</li>
<li class="lvl-2">
<p>协议的目的是为了向上层提供更好的服务（最上层不需要，因此应用是整个网络存在的利用）</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407090946283.png" alt="image-20220407090946283"></p>
<p><strong>服务访问点SAP <em>service access point</em></strong> 即在层间接口有不同的访问点来<strong>区分</strong>多个上层用户——哪个报文是发给哪个上层用户的。SAP也即服务的<strong>地点</strong><br>
如<strong>套接字</strong>就是传输层和应用层的SAP：原理即从应用层往传输层往下传时进行标注，在对方往上传时加以区分</p>
<p><strong>原语 <em>primitive</em></strong>：服务的形式</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407091851148.png" alt="image-20220407091851148"></p>
<p>在通讯之前要有<strong>握手</strong>关系，为之后的通讯做好资源准备，这样的形式称为<strong>面向连接的服务</strong></p>
<p>适合大块数据的传输</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407092116211.png" alt="image-20220407092116211"></p>
<p>适合零星数据的传输</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407092357061.png" alt="image-20220407092357061"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407092653840.png" alt="image-20220407092653840"></p>
<p>SDU【<strong>真正要传输的信息</strong>】穿过层间接口需要加上控制信息ICI，一起构成IDU，之后即可将ICI丢弃，该层在SDU加上该层的头部信息n-header【<strong>一部分来自ICI，一部分是本层加的</strong>】【<em>可以理解为货车的头部</em>】，一起形成本层的n-PDU，然后n-PDU往下传输即作为n-1层的SDU，重复上面的过程</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407093226545.png" alt="image-20220407093226545"></p>
<p>有<strong>三种</strong>关系：直接在SDU上加header；SDU很大，需要拆分成多个小的，分别加上header；SDU很小且多个，可以合并在一起再加上header</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407094049374.png" alt="image-20220407094049374"></p>
<p>应用层的协议很多，有上千种传输层基本就两种TCP、UDP<br>
网络层的IP协议是做转发的，还有很多的路由选择协议链路层和物理层是配套封装在网卡中的</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407100737596.png" alt="image-20220407100737596"></p>
<p><strong>ISO</strong> <em>International Organization for Standardization</em></p>
<p><strong>OSI</strong> <em>Open System Interconnection Reference Model</em> 开放式系统互联通信参考模型</p>
<p>参考模型：模型分几层，每层什么功能，更抽象体系架构：每层有哪些协议，更具体</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407145511402.png" alt="image-20220407145511402"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407180211806.png" alt="image-20220407180211806"></p>
<h2 id="1-8历史">1.8历史</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407194744786.png" alt="image-20220407194744786"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407194827782.png" alt="image-20220407194827782"></p>
<p>每个节点既是数据交换节点，也是端</p>
<p>IMP是路由器的雏形</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407195211543.png" alt="image-20220407195211543"></p>
<p>网络互联原则：各种网络涌现，需要将不同的网络连接到一起，本质是创建一个网络的网络，即网络互联</p>
<p>cerf and kahn提出了TCP/IP，被誉为互联网之父</p>
<blockquote>
<p>1978年，温顿·瑟夫、罗伯特.卡恩、丹尼·科恩（Danny Cohen）和约翰·普斯特尔（Jon Postel）将TCP的功能分为两个协议：用来检测网络传输中差错的传输控制协议TCP，以及专门负责<strong>对不同网络进行互联</strong>的互联网协议IP。</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407200922007.png" alt="image-20220407200922007"></p>
<blockquote>
<p>1983年1月1日，ARPANET正式将其网络核心协议由NCP替换为TCP/IP协议。所有主机停止，更换协议</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407201255638.png" alt="image-20220407201255638"></p>
<blockquote>
<p>1984年，美国国家科学基金会（NSF）建立了NSFnet，作为超级计算机研究中心之间的连接。</p>
<p>最初，NSF曾试图使用ARPANET作为NSFnet的通信干线，但由于ARPANET的军方背景，以及受控于政府，这个决策没有成功。</p>
<p>于是他们决定自己出资，基于TCP/IP协议，建立完全属于自己的广域网。</p>
<p>NSFnet发展非常迅速，很快将全美各地的大学、政府和私人科研机构连接起来。NSFnet的速度也很快，比ARPANET网络快25倍以上。</p>
<p>渐渐地，NSFnet开始取代ARPANET，成为Internet的主干网。</p>
<p>80年代末，连接到NSFnet的计算机数量远远超过了ARPANET用户的数量。<strong>1990年6月1日，ARPANET被正式“拆除”。</strong></p>
<p>1991年8月6日，在瑞士日内瓦的核子研究中心（CERN）工作的英国物理学家<strong>蒂姆·伯纳斯·李</strong>（Tim Berners-Lee），正式提出了World Wide Web，也就是如今我们非常熟悉的www万维网。他还提出了HTTP（超文本传送协议）和HTML（超文本标记语言），设计了第一个网页浏览器，并建立了世界上第一个web网站。</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407202442711.png" alt="image-20220407202442711"></p>
<h2 id="小结">小结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407202926611.png" alt="image-20220407202926611"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407202946339.png" alt="image-20220407202946339"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220407203705644.png" alt="image-20220407203705644"></p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>3 传输层</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/3%20%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1>3 传输层</h1>
<h2 id="3-1-概述和传输层服务">3.1 概述和传输层服务</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414110728006.png" alt="image-20220414110728006"></p>
<span id="more"></span>
<p>传输层加强了网络层的服务，但有些服务是可以加强的，有些服务是不能加强的，如<strong>延时和带宽</strong>是不能加强的，取决于网络层</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414111155619.png" alt="image-20220414111155619"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414111518603.png" alt="image-20220414111518603"></p>
<h2 id="3-2-多路复用和解复用">3.2 多路复用和解复用</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414111650739.png" alt="image-20220414111650739"></p>
<p>复用/解复用技术:</p>
<p><strong>将多条运输连接上的数据汇集到一条网络连接上传输</strong>。本来逻辑上是有多个进程之间的通讯线路的，但通过复用（标识两者之间）只需要一条线路即可，在目标端对所有的信息解复用，分发给不同的应用进程</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414112948542.png" alt="image-20220414112948542"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因此套接字仅为本主机的IP和端口，因此即使源IP和端口不同，目标相同，那么都将定位到相同的socket</p>
</li>
<li class="lvl-2">
<p>但TCP捆绑4元组，只要有一个不一样，就是不同的socket</p>
</li>
</ul>
<h2 id="3-3-无连接传输：UDP">3.3 无连接传输：UDP</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414113438493.png" alt="image-20220414113438493"></p>
<p>仅仅在IP上增加了复用和解复用功能</p>
<p>事务性：一次往返就结束</p>
<p>要在UDP上提供可靠传输，既利用UDP的高效，又要可靠，那么<strong>只能在应用层增加可靠性</strong><br>
<em>(没有第三种协议，因为TCP、UDP能够支持85%以上的应用，再增加会出现协调等问题)</em></p>
<h3 id="UDP-报文格式">UDP 报文格式</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414114016128.png" alt="image-20220414114016128"></p>
<p><img src="https://img-blog.csdnimg.cn/20200420235146636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE0Mjc5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>数据报</strong>：无连接的，<strong>每个数据单元都是独立发送的</strong></p>
<p><strong>校验和</strong>是验证报文传输过程中有没有出错，如果发现校验不对，那么这个<strong>UDP报文会被丢弃</strong></p>
<blockquote>
<p>在计算校验和的时候，<strong>需要在UDP数据报之前增加12字节的伪首部</strong>，伪首部并不是UDP真正的首部。<strong>只是在计算校验和，临时添加</strong>在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。这样的校验和，既检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。</p>
</blockquote>
<p><strong>UDP报文的头部小，固定的8个字节的头部，如上，64 bit</strong>。<strong>载荷即有效传输的数据部分占比大</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414115052105.png" alt="image-20220414115052105"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220414115737846.png" alt="image-20220414115737846"></p>
<p>将报文段（<strong>包含数据和头部，甚至有一些IP的伪头部</strong>）切分成<strong>若干个16 bit</strong>，将所有的16 bit数字<strong>加起来</strong>，注意求和时高位有进位需要<strong>进位回滚</strong>（<em>将进到更高位的1加到最低位上去</em>）。最后和再取反码，得到校验和。</p>
<p>收到数据报校验时，计算出所有的和，<strong>然后再加上校验和，得到全1，0xFFFF</strong>，那么说明没有出错（可能有残存错误）</p>
<h2 id="3-4-RDT-可靠数据传输原理">3.4 RDT 可靠数据传输原理</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415114523805.png" alt="image-20220415114523805"></p>
<p>RDT在有些网络中在网络层实现，通常是由TCP在传输层实现</p>
<p>要向上层应用提供可靠的服务，但是所依赖的下层服务却是不可靠的 (best effort)。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415114859805.png" alt="image-20220415114859805"></p>
<p><strong>渐进地开发RDT</strong>：先假设下层是完全可靠的，再逐个去掉假设，变成不可靠的，从而处理这个不可靠，再将其变成可靠，逐个进行，直到所有假设都去掉</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415115209087.png" alt="image-20220415115209087"></p>
<h3 id="RDT-1-0">RDT 1.0</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415115526494.png" alt="image-20220415115526494"></p>
<p>仅仅是封装和解封装即可</p>
<h3 id="RDT-2-0">RDT 2.0</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415115721842.png" alt="image-20220415115721842"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415120013739.png" alt="image-20220415120013739"></p>
<p>使用<strong>校验和</strong> <em>checksum</em>来检验错误</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>发送方要编码检错，接收方要解码校验</p>
</li>
<li class="lvl-2">
<p>接收方要告诉发送方，是<strong>正确的ACK <em>Acknowledgment</em></strong>，还是<strong>错误的NAK  <em>Negative Acknowledgment</em></strong></p>
</li>
<li class="lvl-2">
<p>发送方要保存副本，ACK则无需处理，等待上层有没有新的调用，NAK则重新发送副本（<strong>检错重传</strong>）</p>
</li>
</ul>
<h3 id="RDT-2-1">RDT 2.1</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415121524024.png" alt="image-20220415121524024"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415121855666.png" alt="image-20220415121855666"></p>
<p>但是<strong>显然ACK/NAK也是可能出错的</strong>【<em>这个信息同样是需要校验的，校验和</em>】，因此发送方可能无法判断接收方返回的信息是什么</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因此对发送的packet<strong>编号0和1</strong>【在01之间切换即可】，发送方先发送p<sub>0</sub></p>
</li>
<li class="lvl-2">
<p>接收方返回的信息ACK出错了，<strong>发送方无法识别，则发送方认为是NAK，再发一次p<sub>0</sub></strong></p>
</li>
<li class="lvl-2">
<p>接收方本来在等待编号1，但收到<strong>相同编号的内容</strong>，因此知道是ACK发送失败，因此将收到的<strong>重复信息丢弃</strong>，但仍然<strong>再返回ACK确认</strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415122203332.png" alt="image-20220415122203332"></p>
<p><strong>停止等待协议 <em>stop-and-wait protocol</em></strong> ：每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<h3 id="RDT-2-2">RDT 2.2</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415170654967.png" alt="image-20220415170654967"></p>
<p><strong>取消NAK</strong>，而是对<strong>ACK编号</strong>，使用<strong>前一个分组</strong>（即最后一个正确接收的分组）的<strong>ACK作为该分组的NAK</strong></p>
<p>这样可以为后续一次发送多个分组做好准备</p>
<p>同理ACK传输错误和上面RDT 2.1一样处理即可</p>
<h3 id="RDT-3-0">RDT 3.0</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415172035771.png" alt="image-20220415172035771"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415173250336.png" alt="image-20220415173250336"></p>
<p>增加了分组可能丢失的情况</p>
<p><strong>超时重传机制</strong>：重传时间一般设置为<strong>比正常一个往返稍长一点的时间</strong>，一旦超过这个时间，一般就能确定分组丢失，然后重传即可</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据链路层的timeout一般是确定的</strong>，因为就是在两个节点之间传输</p>
</li>
<li class="lvl-2">
<p><strong>而传输层的timeout是自适应的</strong>，即需要根据情况调整，因为中间可能跨越的节点数目会变化</p>
</li>
</ul>
<p>如果是ACK丢失了，那么重传会导致数据重复问题，但接收方可以根据分组序号知道重复，从而丢弃即可</p>
<blockquote>
<p>在上面的有限状态机图中，右上角可以看到如果收到的ACK乱码/与发出的编码不匹配，说明需要重发，但这样是空，即不做处理，原因是想通过超时来处理，因为没有收到正确的，最终会导致超时，从而重发</p>
</blockquote>
<p><strong>设置一个合律的timeout很重要</strong>，如果设置时间太短了，也<strong>能正常工作</strong>，但会导致分组的发送和应答<strong>重复</strong>，<strong>效率低</strong>，如下</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415173911741.png" alt="image-20220415173911741"></p>
<p>RDT 3.0对于停止等待协议是<strong>完备的</strong>，可以处理所有的情况</p>
<h3 id="停止等待协议的问题">停止等待协议的问题</h3>
<p><strong>但停止等待协议的效率很低</strong>，特别是在<strong>信道容量（同时能容纳的“车“的数量，等于TR，<em>R是带宽，T是信道从头到尾传输的时间</em>）很大时</strong>，就像告诉公路很长，其中同一时间可以容纳很多车辆前后排列，但如果一次仅仅一辆车在行驶，行驶出高速公路后再让下一辆车上高速，显然效率太低了</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415174936461.png" alt="image-20220415174936461"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415175324810.png" alt="image-20220415175324810"></p>
<p><strong>传输时间=分组长度/链路带宽</strong></p>
<p>可见，传输时间远小于往返延迟RTT，因此时间利用率很低<strong>0.027%</strong>，只有传输时间是在忙的，其他时间都是空闲的，等待信息的返回</p>
<p><strong>有效吞吐=带宽*时间利用率=270kbps</strong>，相当于1Gbps的链路只用到了270kbps</p>
<h3 id="流水线协议">流水线协议</h3>
<p><strong>流水线协议 <em>pipeline protocol</em></strong> ：一次发送多个未经确认的分组</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415180455259.png" alt="image-20220415180455259"></p>
<h4 id="滑动窗口协议">滑动窗口协议</h4>
<p><em>Sliding-window protocol</em></p>
<table>
<thead>
<tr>
<th></th>
<th>发送窗口大小</th>
<th>接收窗口</th>
</tr>
</thead>
<tbody>
<tr>
<td>停止等待协议</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>流水线协议——GBN</td>
<td>&gt;1</td>
<td>1</td>
</tr>
<tr>
<td>流水线协议——SR</td>
<td>&gt;1</td>
<td>&gt;1</td>
</tr>
</tbody>
</table>
<h4 id="发送窗口">发送窗口</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415180604097.png" alt="image-20220415180604097"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415181334075.png" alt="image-20220415181334075"></p>
<p><strong>发送窗口是发送缓冲区的子集，是指发送但未确认的分组</strong><br>
上层应用可以继续将要发送的分组存放在发送缓冲区，当发送后发送窗口的<strong>前沿便移动一格</strong>，最大可以到发送缓冲区的大小</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415181718493.png" alt="image-20220415181718493"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415195728321.png" alt="image-20220415195728321"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415195859092.png" alt="image-20220415195859092"></p>
<h4 id="接收窗口">接收窗口</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415201457064.png" alt="image-20220415201457064"></p>
<p><strong>接收窗口=接收缓冲区</strong></p>
<p>【<strong>SR和GBN原理一样，都是序号最小的到来才移动，并且窗口中要包含到来的分组序号才会接收并返回ACK，否则丢弃</strong>】</p>
<h5 id="Go-Back-N">Go-Back-N</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415200400877.png" alt="image-20220415200400877"></p>
<p>GBN接收窗口大小是1，0，1分别到来，然后接收方分别接收<strong>解封装，并将数据data交给上层</strong>，再返回ACK<sub>0</sub>，ACK<sub>1</sub>，<strong>接收窗口向右移动</strong>，但如果下一个到来的是3而不是2，说明乱序，那么接收方会把3号分组丢弃，然后<strong>发送顺序到来的序号最大的分组的确认</strong>【<em><strong>累计确认</strong>，表明这个序号及以前的分组已经接收</em>】即ACK<sub>1</sub>，接下来又来了4号分组，同样丢弃并且返回ACK<sub>1</sub></p>
<h5 id="Selective-repeat">Selective repeat</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415200308739.png" alt="image-20220415200308739"></p>
<p>SR中滑动窗口大于1，比如上面为5，先到了0，那么接收窗口右移一格，包含12345，然后返回ACK<sub>0</sub>，顺序到来1，接收窗口再右移一格，包含23456，返回ACK<sub>1</sub>，但接下来到来3，说明乱序，但由于接收窗口中可以包含3，说明可以接收3，那么会返回ACK<sub>3</sub>【<em><strong>非累计确认</strong>，仅仅是这个分组的</em><em>独立确认</em>**】，但接收窗口不移动，仍然包含23456，接下来到来4，返回ACK<sub>4</sub>,，接收窗口仍不移动，只有接收窗口中序号最小的到来才会导致移动。<strong>如果</strong>这时候来了2，会返回ACK<sub>2</sub>，因为此时234都到了，那么<strong>接收方会将234一起有序的交给上层</strong>（<em>要<strong>有序</strong>交给上层，因此在<strong>乱序时要缓存</strong></em>），并且接受窗口右移3格</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415201858858.png" alt="image-20220415201858858"></p>
<h4 id="异常情况">异常情况</h4>
<h5 id="Go-Back-N-重发N">Go-Back-N 重发N</h5>
<p>出现了前面的2号没有收到，收到3时接收方返回ACK<sub>1</sub>，那么发送方的<strong>发送窗口不能移动</strong><br>
【<em>但是注意，如果此时发送窗口&lt;发送缓冲区，那么<strong>发送缓冲区内的分组是可以被发送的</strong>，被发送后进入发送窗口</em>。<em>同理如果缓冲区中的分组未满，那么上层是可以将新的分组放到发送缓冲区的</em>】那么<strong>2号分组的计时器会超时timeout</strong>，因此发送方需要将<strong>发送窗口</strong>（即已发送但未确认的分组）<strong>全部再顺序发送一遍</strong>【因为GBN中2号分组没到，那么后面的所有分组都会被丢弃】</p>
<p>【注意：GBN中只有一个计时器，即在滑动窗口<strong>大小从0变成1时启动一个计时器</strong>，同时也只需要<strong>对最小序号的分组计时</strong>即可。当收到最小序号的ACK时，那么会把<strong>计时器重置，发送窗口右移动</strong>；如果收到ACK后，窗口大小变成0，那么关闭计时器；在超时重发时也会重置计时器】👉详见下面的FSM</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415205342634.png" alt="image-20220415205342634"></p>
<h5 id="Selective-repeat-选择性重发">Selective repeat 选择性重发</h5>
<p>出现了前面2号分组没收到的情况，但34号分组已经收到，<strong>那么2号分组会超时timeout，那么2号分组会被单独重发</strong>，但34号分组的计时器因为收到了确认ACK，所以不会被重发但注意发送方的<strong>发送窗口仍然是不能移动的</strong>，因为2没有被确认，<strong>2被确认后，发送窗口同样移动3格</strong></p>
<p>【注意：SR的<strong>每一个分组</strong>发送后都会有一个计时器<strong>分别计时</strong>，因此较为复杂】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415205709242.png" alt="image-20220415205709242"></p>
<hr>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415204005412.png" alt="image-20220415204005412"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415204834260.png" alt="image-20220415204834260"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415205133761.png" alt="image-20220415205133761"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415205831311.png" alt="image-20220415205831311"></p>
<h4 id="思考题">思考题</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220415210649113.png" alt="image-20220415210649113"></p>
<p>对于SR，会出现如上图b的情况，因此在最坏的情况下即发送方发出的所有报文均被接收方接收，但ACK报文全部没有返回【关键是最小序号的ACK没有返回到发送方】，这时发送窗口不变，接收窗口右移发送窗口的大小，一旦超过了报文的序号，那么就会出现问题，一段的序号0的报文发给了下一段0的报文</p>
<p><strong>因此要求的是N<sub>S</sub>+N<sub>R</sub>≤2<sup>n</sup>（其中序列号为0~2<sup>n</sup>-1）</strong><br>
[因此如果<strong>SR中两个窗口大小一样</strong>的话，<strong>每个最大只能是2<sup>n</sup>/2=2<sup>n-1</sup></strong>；<strong>GBN中N<sub>R</sub>=1，因此发送窗口最大为2<sup>n</sup>-1</strong>]</p>
<h2 id="3-5-面向连接的传输：TCP">3.5 面向连接的传输：TCP</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422094901539.png" alt="image-20220422094901539"></p>
<p><strong>MSS</strong> <em>maximum segment size</em> **最大报文段大小 **</p>
<p>MSS是TCP层交互给IP层最大分段大小，不包含TCP报头，只包含数据。</p>
<p>对于以太网，数据的MTU最大传输单元是1500B，因此应用进程的数据太大是无法被链路层的帧封装的，所以需要拆分。</p>
<p>应用进程的数据到了TCP实体后要根据MSS划分成不同的报文段，并且在每一个前面加上TCP头部</p>
<p><strong>全双工</strong>（<em>Full Duplex</em>）全双工指可以同时（瞬时）进行信号的<strong>双向传输</strong>（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p>
<blockquote>
<p>单工就是在只允许甲方向乙方传送信息</p>
</blockquote>
<h3 id="TCP报文段结构">TCP报文段结构</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422142240682.png" alt="image-20220422142240682"></p>
<p>TCP头部长度<strong>至少20 B</strong>，但还有一些可选项以一起构成头部，其中的<strong>首部长度</strong>就记录了头部的长度，用以区分出数据部分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422143005451.png" alt="image-20220422143005451"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>序号</strong>指的是一个TCP数据报的数据部分的第一个字节在整个字节流中的偏移量，字节为单位。</p>
<p>即指的是segment中第一个字节的在整个字节流中的编号，<strong>而不是segment的编号</strong></p>
<p>此外序号通常不是从0开始，而是开始建立TCP连接时，<strong>双方随机选择序列号</strong>。防止被攻击者猜到，或与其他冲突，所以设置随机</p>
</li>
<li class="lvl-2">
<p><strong>确认号</strong>是指确认n-1及以前的字节，比如ACK 555，那么就表示554及之前的都已经收到了，期待555，<em>类似GBN</em>，也是<strong>累计确认</strong>：该序列号之前的所有字节均已被正确接收到</p>
</li>
</ul>
<p>Q：接收方如何处理乱序到达的Segment？</p>
<p>A：TCP规范中没有规定，由TCP的实现者做出决定，<strong>可以缓存，也可以直接抛弃</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422143513814.png" alt="image-20220422143513814"></p>
<h3 id="TCP往返延迟RTT和超时">TCP往返延迟RTT和超时</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422143750280.png" alt="image-20220422143750280"></p>
<p>动态自适应地改变计时器的时间</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422144241845.png" alt="image-20220422144241845"></p>
<p>1-α&lt;1，因此随着测量的增加，前面的SampleRTT对平均值的影响会越来越小，而逐步过渡到后面的SampleRTT</p>
<p>$EstimatedRTT= (1- \alpha)<em>EstimatedRTT+\alpha</em>SampleRTT$</p>
<p>右边的平均RTT是指之前计算出来的平均RTT</p>
<p><strong>推荐值α=0.125</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422144637496.png" alt="image-20220422144637496"></p>
<p>计算平均值的同时计算<strong>SampleRTT偏离平均值的平均情况</strong>，类似一种方差，称为安全边界时间DevRTT</p>
<p>$DevRTT= (1-\beta)<em>DevRTT+\beta</em>|SampleRTT-EstimatedRTT|$</p>
<p><strong>推荐值β=0.25</strong></p>
<p>最终得到合适的超时时间间隔为平均RTT+<strong>4倍</strong>的安全边界</p>
<p>$TimeoutInterval = EstimateRTT+4*DevRTT$</p>
<h3 id="TCP可靠数据传输">TCP可靠数据传输</h3>
<p><strong>TCP采用pipe-line 是GBN和SR的混合体</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422145815666.png" alt="image-20220422145815666"></p>
<p>RDT:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>流水线机制</strong></p>
</li>
<li class="lvl-2">
<p><strong>累计确认</strong>：是对这个字节的期待</p>
</li>
<li class="lvl-2">
<p><strong>TCP使用单一重传定时器</strong>：仅一个计时器</p>
</li>
</ul>
<p>触发重传：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>超时</strong>：只发生最早的那个未确认的段，即发生超时的这个段</p>
<p>【超时定时器是比较保守的，在4倍偏差，因此如果超时，可以有极大的把握确定报文丢失】</p>
</li>
<li class="lvl-2">
<p><strong>重复的ACK</strong>：收到了<strong>1个正确</strong>ACK，然后又收到<strong>3个冗余</strong>的重复ACK，那么重传，而此时超时定时器还没超时，因此称为<strong>快速重传</strong></p>
</li>
</ul>
<h4 id="简化的TCP-不考虑重复ACK-流量控制-拥塞控制">简化的TCP:不考虑重复ACK,流量控制,拥塞控制</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422151122843.png" alt="image-20220422151122843"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422151356578.png" alt="image-20220422151356578"></p>
<p>NextSeqNum相当于滑动窗口的前沿</p>
<p>SendBase相当于滑动窗口的后沿。</p>
<p>只不过TCP中的窗口<strong>以字节为单位</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422151826809.png" alt="image-20220422151826809"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422151903338.png" alt="image-20220422151903338"></p>
<p><strong>累计确认</strong>，因此即使ACK=100没到，也没关系，ACK=120就能代表ACK=100</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422152059304.png" alt="image-20220422152059304"></p>
<ol>
<li class="lvl-3">
<p>到了一个报文段后等待500 ms，如果第二个报文段在500 ms没来，那么发送第一个的ACK</p>
</li>
<li class="lvl-3">
<p>如果上面等待过程中<strong>第二个连续</strong>的报文段到达，立即发送第二个报文段的累计确认，<strong>同时确认两个报文段</strong></p>
</li>
<li class="lvl-3">
<p><strong>乱序到达</strong>，需要的一个报文段比如第一个字节位置为y<sub>0</sub>，而到达了第一个字节大于y<sub>0</sub>的，说明乱序，<strong>立即发送重复的ACK=y<sub>0</sub>，表示对y<sub>0</sub>的期待，让发送方重发</strong></p>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422152825411.png" alt="image-20220422152825411">如果在3的情况中，到达了能够完全补充gap，即y<sub>0</sub>到乱序报文起始处的报文，那么立即发送乱序到达的报文的后面一个字节的的位置ACK，累计确认</p>
<p>如果是部分补齐，如上，在立即发送部分补齐的报文的后一个字节的ACK，让发送方快点补齐</p>
</li>
</ol>
<h4 id="快速重传">快速重传</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422153256354.png" alt="image-20220422153256354"></p>
<p><strong>快速重传</strong>：在定时器超时之前重传</p>
<p>收到1个正确ACK后又收到<strong>3个</strong>重复ACK，那么说明丢失的可能性非常大，需要重传</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422153708762.png" alt="image-20220422153708762"></p>
<blockquote>
<p>Q：为什么是三次？</p>
<p>A：因为无法判断是因为乱序还是丢失，重传1到2次更可能是乱序，3次及以上更可能是因为丢失</p>
</blockquote>
<h3 id="TCP流量控制">TCP流量控制</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422154219979.png" alt="image-20220422154219979"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422154228603.png" alt="image-20220422154228603"></p>
<p><strong>接收buffer</strong>通常默认为<strong>4096</strong></p>
<p>接收方返回ACK时在receive window中记录其空闲的buffer的大小，从而发送方会<strong>限制其发送缓冲区中未确认的字节个数≤receive window值</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422154354055.png" alt="image-20220422154354055"></p>
<p><strong>piggyback捎带技术</strong>，即发送方和接收方是随时变化的，客户端发送数据给服务器，服务器也会发送数据给客户端，所以如果发送一次对方要返回一个确认，然后又发送数据回来，会比较麻烦，因此可以将确认放在数据中一起发送回来，即捎带</p>
<h3 id="TCP连接管理">TCP连接管理</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422154951753.png" alt="image-20220422154951753"></p>
<p><strong>连接建立的本质</strong>：知道和要对方通信，准备好资源，控制变量做置位（特别是连接的初始序号#seq，对方的receive buffer的大小）</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422155548014.png" alt="image-20220422155548014"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422155913681.png" alt="image-20220422155913681"></p>
<p>二次连接不可行</p>
<h4 id="三次握手">三次握手</h4>
<p><strong>理论上3次是最少需要的</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422162117847.png" alt="image-20220422162117847"></p>
<ol>
<li class="lvl-3">
<p>Client发送连接建立请求SYN=1并携带它将要从序号为x处开始传Seq=x</p>
</li>
<li class="lvl-3">
<p><strong>服务器会分配缓存</strong></p>
<p>server需要对这个信息进行ACK，ACKNum=x+1【期望x+1及之后的数据】</p>
</li>
<li class="lvl-3">
<p>然后server需要SYN=1并将自己从序号为y处开始传Seq=y告诉client</p>
<p><strong>这两个信息2，3可以合并在一起</strong>SYN&amp;ACK**(piggyback)**</p>
</li>
<li class="lvl-3">
<p>然后client对server的y进行确认ACKNum=y+1【期望y+1及之后的数据】</p>
<p><strong>这个ACK通常会和第一次数据传递放在一起</strong></p>
</li>
</ol>
<blockquote>
<p>Q：会不会在三次握手的第二步服务器就会分配资源？</p>
<p>A：会分配，会保留一段时间直到确认这个ACK不会再建立了（SYN泛洪攻击，DDoS）</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422161237312.png" alt="image-20220422161237312"></p>
<ol>
<li class="lvl-3">
<p>第一种情况，因为需要3次握手，因此不会存在半连接</p>
</li>
<li class="lvl-3">
<p>第二种情况，因为不会存在半连接，所以连接不存在，延迟到达的data会被丢弃</p>
</li>
<li class="lvl-3">
<p>此外第三种情况：假设客户端使用555端口与服务器80端口建立连接，在第二种情况的基础上，如果data卡了很久才到达服务器，而此时正好客户端又用555端口和服务器80端口建立连接了，那么连接存在，且收到数据。</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>如果序号都是从0开始的话</strong>，那么这个老数据会被当成当前需要的数据，<strong>而产生错误</strong>。</li>
<li class="lvl-5">因此<strong>每次选择随机的开始序号</strong>，可以避免老的滞留的数据对连接的影响，比如老数据从x开始，而新的开始序号是x+1，那么老的数据肯定会被抛弃，因为都不在连接的序号范围内(≥x+1)</li>
<li class="lvl-5">当然有可能随机选择的序号正好又包含老数据，但概率极小，那这就没有办法了👉”<strong>网络不能解决所有问题</strong>“</li>
</ul>
</li>
</ol>
<h4 id="四次挥手">四次挥手</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422162647488.png" alt="image-20220422162647488"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220422162755541.png" alt="image-20220422162755541"></p>
<p><strong>对称释放，并不完美</strong></p>
<p>四次挥手是由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了<strong>连接的一端在结束它的发送后还能接收来自另一端数据的能力</strong></p>
<p>[<strong>结束发送指的是不再发送数据，但可以对对方的请求作出应答</strong>]</p>
<p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(Four-way handshake)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p>
<p><img src="https://pics7.baidu.com/feed/8435e5dde71190ef08c7447eca4fb81efdfa602b.jpeg?token=74e81457ce3c2f49b48814839e548194&amp;s=5EA83C6229C6E0CA5A7454CA0000E0B1" alt="img"></p>
<p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。</p>
<blockquote>
<p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</p>
<blockquote>
<p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。</p>
<blockquote>
<p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p>
</blockquote>
<p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。</p>
<blockquote>
<p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong>TIME_WAIT</strong> <strong>（时间等待）状态</strong>。</p>
<blockquote>
<p>TIME-WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<p>注意 ：这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入</strong> <strong>CLOSED</strong> <strong>状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，<strong>服务端会重新发送 FIN 报文给客户端</strong>，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。**服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。**因此服务器到客户端的连接关闭，整个 TCP 连接关闭</p>
<blockquote>
<p><strong>两次挥手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次挥手</strong>。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>
</blockquote>
<h2 id="3-6-拥塞控制原理">3.6 拥塞控制原理</h2>
<h3 id="拥塞的原因-代价">拥塞的原因/代价</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425205612515.png" alt="image-20220425205612515"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425210620116.png" alt="image-20220425210620116"></p>
<p>无限大的缓存，则报文不会丢失</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425210802389.png" alt="image-20220425210802389"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425210939064.png" alt="image-20220425210939064"></p>
<p>掌握路由器空闲空间，代价太大</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425211229636.png" alt="image-20220425211229636"></p>
<p>当网络拥塞时，会出现超时重传，丢失重传等，因此此时想要达到更高的传输速率，输入的带宽要增大，比如为了能每秒传输100个分组，那么输入到链路的分组数目会大于100个</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425211410601.png" alt="image-20220425211410601"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425211614033.png" alt="image-20220425211614033"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425211804919.png" alt="image-20220425211804919"></p>
<p>当分组经过了很多路由器，但在后面的一个路由器被抛弃了，那么它在前面所做的努力都会被浪费，这在网络拥塞时更加可惜，因为资源有限，有限的资源还被浪费了</p>
<h3 id="拥塞控制方法">拥塞控制方法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425211920911.png" alt="image-20220425211920911"></p>
<h4 id="ATM-采用网络辅助的拥塞控制">ATM 采用网络辅助的拥塞控制</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220425214145348.png" alt="image-20220425214145348"></p>
<p><strong>ATM</strong> <em>Asynchronous Transfer Mode</em> 异步传输模式。具有分组交换和电路交换的优点，对应于OSI协议参考模型的第2层。</p>
<p>数据交换的单位是<strong>信元</strong>，可以认为是小分组，<strong>53B，5B的头部，48B的载荷</strong>，因此存储转发的时间非常短即可完成。</p>
<p>在电路交换中，每个节点花费1bit的存储时间，在分组交换中每个节点花费一个分组的存储时间，而在 ATM 中信元比 1bit 大，比一个分组小，只花费53B的存储时间。<strong>所以网络调度很容易，兼具两种交换网络的特性</strong></p>
<p>ATM 网络具有很多模式，如 <strong>ABR</strong> <em>available bit rate</em> <strong>弹性服务</strong>：如果网络轻载，那么用户可以使用网络的可用带宽，但当网络拥塞时，用户只能使用网络承诺的带宽，不能超过如1 Mbps</p>
<p>发送方在发送数据信元中<strong>间隔插入</strong>资源管理信元 <strong>RM</strong> ，其中的 bit 被交换机设置：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>NI bit</strong> : <em>no increase in rate</em> 轻微拥塞时</p>
</li>
<li class="lvl-2">
<p><strong>CI bit</strong> : <em>congesting indication</em> 拥塞提升</p>
<ul class="lvl-2">
<li class="lvl-4">也可能交换机将 RM 信元前面的数据信元的 <strong>EFCI bit</strong> <em>Explicit Forward Congestion Indication</em>  <code>显性前向拥塞指示</code> 置为1，那么将由接收端把 RM 信元的 CI bit 置1</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>ER</strong> 2 Byte : <em>explicit rate</em> 记录两个主机通讯过程中的交换机所能支持的最小带宽[<em>每经过一个就看是否更小，更小就修改，更大则不改</em>]，因此发送方根据最小带宽发送，就不会发送拥塞</p>
</li>
</ul>
<p>接收端不修改 RM 信元，并将其返回给发送方，从而发送方可用知道网络状况，控制发送速率</p>
<h2 id="3-7-TCP-拥塞控制">3.7 TCP 拥塞控制</h2>
<h4 id="TCP-采用端到端的拥塞控制">TCP 采用端到端的拥塞控制</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426080902560.png" alt="image-20220426080902560"></p>
<p>端系统自己感知拥塞，网络核心负担低</p>
<h3 id="如何检测拥塞">如何检测拥塞</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426081045830.png" alt="image-20220426081045830"></p>
<p><strong>超时即认为是拥塞</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>网络拥塞</strong>，段被丢弃：概率大，判断正确</p>
</li>
<li class="lvl-2">
<p><strong>段出错</strong>，段被丢弃： 概率小，判断错误，但概率小，对整个影响不大</p>
</li>
</ul>
<p>出现**3次重复的冗余 **ACK <strong>即认为轻微拥塞</strong>，即出现丢失，但还有一定传输能力(<em>后面3个段都到达了，此时还没超时，因为超时时间比较保守，加上4倍偏差</em>)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个 ACK 正确</p>
</li>
<li class="lvl-2">
<p>后续 1~2 个 ACK ，会被认为是乱序，<strong>乱序的可能性更大</strong></p>
</li>
<li class="lvl-2">
<p>出现第 3 个 ACK ，<strong>大概率是段丢失</strong></p>
</li>
</ul>
<h3 id="速率控制方法">速率控制方法</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426082135576.png" alt="image-20220426082135576"></p>
<p>$rate = \frac{CongWin}{RTT} Byte/sec$</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426091116543.png" alt="image-20220426091116543"></p>
<p>MSS 是最大报文长度</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426091444944.png" alt="image-20220426091444944"></p>
<p>保证发送窗口是<strong>拥塞窗口和对方接收窗口的最小值</strong>，从而同时满足拥塞控制和流量控制</p>
<h4 id="策略">策略</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426091628679.png" alt="image-20220426091628679"></p>
<p><strong>SS</strong> <em>slow start</em> 慢启动</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426091752613.png" alt="image-20220426091752613"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426091901163.png" alt="image-20220426091901163"></p>
<p>每收到一个 ACK，拥塞窗口加 1 == 下一次的拥塞窗口是上一次的两倍</p>
<p><strong>初始速率很慢，但是快速攀升</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426092734182.png" alt="image-20220426092734182"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>AI</strong> <em>Additive Increase</em> <strong>加性增</strong>：到达 SS 的阈值后，每个RTT将 CongWin 增大一个 MSS 线性地探测-----<strong>拥塞避免阶段</strong></p>
</li>
<li class="lvl-2">
<p><strong>MD</strong> <em>Multiplicative Decrease</em> <strong>乘性减</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">当<strong>发送超时</strong>后，将 CongWin 降为 1 MSS，开始 SS 并将 CongWin / 2 作为 SS 倍增的阈值。</li>
<li class="lvl-4">当<strong>收到 3 个冗余 ACK</strong> 时，直接将<strong>阈值降为 CongWin / 2，并将 CongWin 设置为 阈值 + 3</strong>【<em>+3是因为返回 3 个 ACK 所以后面有三个已经确认了</em>】，然后直接线性增加 1【<em>此时 CongWin &gt; 阈值</em>】，而无需从 1 开始 SS。</li>
<li class="lvl-4">当收到重复 ACK 时，什么都不做，<strong>只是对重复的个数进行计数</strong>，为上面的情况做好准备</li>
</ul>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426093527640.png" alt="image-20220426093527640"></p>
<h3 id="TCP-吞吐量">TCP 吞吐量</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426094855058.png" alt="image-20220426094855058"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426094628828.png" alt="image-20220426094628828"></p>
<p>不考虑 SS 阶段，因为指数增加，时间可以忽略不计</p>
<p>因此平均吞吐量为 <strong>0.75 W / RTT</strong></p>
<h3 id="TCP-公平性">TCP 公平性</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426095036146.png" alt="image-20220426095036146"></p>
<p>TCP 是公平的，<strong>均分瓶颈带宽</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426165108114.png" alt="image-20220426165108114"></p>
<p>以两个连接 1 和 2 共享链路为例：</p>
<p>短时间是可能超过斜线的，因为路由器存在缓存，但长期是不可能的，分组会被抛弃。</p>
<p>当检测到拥塞后（这里不看 SS 只看拥塞避免阶段，SS 时间很短），两者都会回到斜线内部，然后 45° 地增加带宽(即两者都逐步增加1 MSS[假设两者的 MSS 是一样的])，<strong>最终可以达到两者均分带宽</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426165337244.png" alt="image-20220426165337244"></p>
<p>上述两种情况就体现了一定的不公平性，还有一种情况，如果 AA’ 的 MSS 小于 BB’ 的 MSS 那么最终两者也无法达到均分带宽</p>
<p><strong>因此 TCP 的公平是大致上的公平</strong></p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426165814628.png" alt="image-20220426165814628"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220426165945346.png" alt="image-20220426165945346"></p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>商业模式部分期末复习</title>
    <url>/%E9%9C%80%E6%B1%82%E5%92%8C%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E9%83%A8%E5%88%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="商业模式部分期末复习">商业模式部分期末复习</h2>
<blockquote>
<p>参考自 zhy 的博客<a href="https://spricoder.github.io/2021/01/17/2020-Demand-and-business-model-innovation/2020-Demand-and-business-model-innovation-Exam-%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/">2020-需求与商业模式分析-Exam-商业模式 - SpriCoder的博客</a></p>
</blockquote>
<h1>1. 商业模式画布</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/%E6%AC%A3%E7%94%9F2.0.png" alt="欣生2.0"></p>
<span id="more"></span>
<ol>
<li class="lvl-3">
<p><strong>客户细分</strong></p>
<ol>
<li class="lvl-6">目标人群、取舍与细分</li>
<li class="lvl-6">基于什么进行客户细分：新供给、新分销渠道、新客户关系模型、利润率不同、为特殊改进买单</li>
<li class="lvl-6">群体划分：大众市场【不区分客户，找共性】、小众市场、求同存异的客户群体【有些许差别的客户】、多元化的客户群体【需求的问题迥异】、多边平台【把独立但依存的客户联系起来】</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>价值主张</strong></p>
<ol>
<li class="lvl-6">有价值的产品和服务</li>
<li class="lvl-6">让事情更简单(一站式、保姆式服务、便利性、价格)、更复杂(定制，设计)、更透明(风控)、创新</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>渠道通路</strong></p>
<ol>
<li class="lvl-6">价值主张通过沟通、分发以及销售渠道传递给客户</li>
<li class="lvl-6">5个阶段：知名度-评价-购买-传递-售后【售后支持是渠道通路的部分，如京东强大的售后】</li>
<li class="lvl-6">自有渠道、合作方渠道、或混用</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>客户关系</strong></p>
<ol>
<li class="lvl-6">以客户群为单位建立和维护的客户关系的类型</li>
<li class="lvl-6">客户关系的驱动
<ol>
<li class="lvl-9">开发新的客户</li>
<li class="lvl-9">留住原有的客户</li>
<li class="lvl-9">增加销售量（杀熟）</li>
</ol>
</li>
<li class="lvl-6">客户关系类型：私人服务、专属私人服务【如指定客服】、自助服务【如atm机】、自动化服务、社区、与客户协作【评论，反馈建议】</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>收入来源</strong></p>
<ol>
<li class="lvl-6">用户真正愿意付费的点</li>
<li class="lvl-6">收入来源
<ol>
<li class="lvl-9">资产销售</li>
<li class="lvl-9">使用费</li>
<li class="lvl-9">会员费</li>
<li class="lvl-9">租赁</li>
<li class="lvl-9">许可使用费【知识产权，版权】</li>
<li class="lvl-9">经纪人佣金【即中介费，提现费】</li>
<li class="lvl-9">广告费用</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>核心资源</strong></p>
<ol>
<li class="lvl-6">保证运行的最重要资产(品牌也算)</li>
<li class="lvl-6">核心资源
<ol>
<li class="lvl-9">实物资源</li>
<li class="lvl-9">知识性资源</li>
<li class="lvl-9">人力资源</li>
<li class="lvl-9">金融资源</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>关键业务</strong></p>
<ol>
<li class="lvl-6">为实现供给和交付所需要完成的关键业务活动</li>
<li class="lvl-6">与价值主张强相关，价值主张的<strong>具象化</strong></li>
<li class="lvl-6">关键业务类型
<ol>
<li class="lvl-9">生产【制造企业】</li>
<li class="lvl-9">客户问题的解决方案【咨询公司、医院等服务型机构】</li>
<li class="lvl-9">平台/网络【多边平台】</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>重要合作</strong></p>
<ol>
<li class="lvl-6">分类
<ol>
<li class="lvl-9">非竞争者的战略联盟</li>
<li class="lvl-9">竞争者的战略联盟(合作)</li>
<li class="lvl-9">为新业务建立合资公司</li>
<li class="lvl-9">建立供应商和采购商关系</li>
</ol>
</li>
<li class="lvl-6">建立合作关系的动机
<ol>
<li class="lvl-9">优化以及规模效应</li>
<li class="lvl-9">降低风险和不确定性</li>
<li class="lvl-9">特殊资源及活动的获得</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>成本结构</strong></p>
<ol>
<li class="lvl-7">固定成本</li>
<li class="lvl-7">可变成本</li>
<li class="lvl-7">规模经济</li>
<li class="lvl-7">范围经济：企业的<strong>经营范围的扩大</strong>会带来成本优势。比如同一个营销活动或分销渠道可供多个产品使用，包括渠道/资源【如品牌】的的复用</li>
</ol>
<blockquote>
<p><strong>小米台灯为什么便宜</strong>：规模经济（大量的生产采购，摊薄了固定成本，但生产了很多，卖不出去就成了库存成本，因此利用了范围经济）和范围经济（比如米家的牌子的，这是对渠道的复用，复用了已经被认可的渠道）</p>
</blockquote>
</li>
</ol>
<h1>2. 商业模式类型</h1>
<ol>
<li class="lvl-3">
<p>分拆商业模式</p>
<ol>
<li class="lvl-6">客户关系管理</li>
<li class="lvl-6">新产品开发</li>
<li class="lvl-6">基础设施管理</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>多边平台商业模式</strong>：<strong>两个或更多独立但相互依存</strong>的客户群体连接到一起。</p>
<ol>
<li class="lvl-6">价值主张：
<ol>
<li class="lvl-9"><strong>吸引用户</strong>【客户群体相互依存，无法独立】</li>
<li class="lvl-9"><strong>群体配对</strong></li>
<li class="lvl-9">利用<strong>平台交易渠道</strong>降低交易成本</li>
</ol>
</li>
<li class="lvl-6">多个收益流，<strong>补贴正确的客户群是定价决策的关键</strong></li>
<li class="lvl-6">核心资源是<strong>平台</strong>，成本主要来自于平台的维护和开发
<ul class="lvl-4">
<li class="lvl-8">关键活动
<ol>
<li class="lvl-11">平台管理</li>
<li class="lvl-11">服务实现</li>
<li class="lvl-11">平台升级</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-6">先有鸡还是先有蛋问题：
<ol>
<li class="lvl-9">解决方案是<strong>向某一个客户群体发放补贴</strong>【低价/免费也是一种补贴】</li>
<li class="lvl-9">用<strong>低廉或免费</strong>的价值主张来先吸引某一个群体加入平台，明确群体加入平台的目的。【即看哪边对价格更<strong>敏感</strong>】</li>
<li class="lvl-9">单个用户群体的价值本质上取决于平台中<strong>另一群体的用户数量</strong></li>
<li class="lvl-9">例子：B站：观众免费，补贴Up主；索尼PS：低价游戏机【用户价格低，用户基数大，游戏开发者加入】；谷歌搜索</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>免费商业模式</strong></p>
<ol>
<li class="lvl-6">
<p><strong>至少有一个关键的客户群体</strong>是可以<strong>持续免费地享受服务。</strong></p>
</li>
<li class="lvl-6">
<p>三种可行的免费商业模式：</p>
<ol>
<li class="lvl-9">
<p><strong>广告商业模式</strong>：基于多边平台的免费商品</p>
<ol>
<li class="lvl-12">广告是一种实现免费供给的、成熟的收益来源。</li>
<li class="lvl-12">平台的一边是以<strong>吸引用户为目的而设计</strong>的内容、产品或服务，另一边则是<strong>产生收益的广告位</strong>购买者。</li>
</ol>
</li>
<li class="lvl-9">
<p><strong>免费增值</strong>：免费的基本服务，可选的增值服务</p>
<ol>
<li class="lvl-12">
<p>不到10%的用户会为增值服务付费</p>
</li>
<li class="lvl-12">
<p>两个关键指标：<strong>关注免费用户平均服务成本与增值用户转化率</strong></p>
</li>
<li class="lvl-12">
<p>例子：百度网盘、印象笔记(跨平台)</p>
<p>保险行业模式:倒转的免费增值【大部分客户定期支付小额保费以补贴一小部分产生实际索赔的客户】</p>
</li>
</ol>
</li>
<li class="lvl-9">
<p><strong>诱饵&amp;陷阱</strong>：以免费或很便宜的初始价格吸引客户，并引导其重复购买</p>
<ol>
<li class="lvl-12">产品与后续产品之间要有<strong>紧密连接</strong>，从而使得极小收益的初始购买为后续高收益产品或服务的重复购买<strong>创造可能</strong></li>
<li class="lvl-12">通过<strong>专利阻断</strong>可以确保其竞争者不能以更低的价格提供相应产品</li>
<li class="lvl-12">例子：如打印机很便宜，但墨盒很贵且必须使用原厂墨盒；免费手机和长期月租合约；<strong>又肝又氪的游戏营销活动</strong>（如英雄联盟可以直接高价买皮肤，或者低价购买门票，通过肝来获取代币换取皮肤，但要真正达到换取皮肤的代币，很困难，可能仍然需要购买代币：诱饵：低价的入场券和可以通过肝得到的同等收益；陷阱：难以跟上的日常肝和付费赶进度）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>长尾商业模式</strong>：在于<strong>少量多种</strong>地销售：致力于提供相当<strong>多种类的小众产品</strong>，而其中的每一种卖出量<strong>相对很少</strong>，但是汇总的销售收入可以与传统销售媲美【传统销售是行业内20%的产品占据大多数销量】。</p>
<ol>
<li class="lvl-6">
<p><strong>要求低库存成本以及强大的平台</strong>能保证小众商品及时被感兴趣的买家发现</p>
</li>
<li class="lvl-6">
<p>出现原因：</p>
<ol>
<li class="lvl-9">生产工具的普及</li>
<li class="lvl-9">销售渠道的普及</li>
<li class="lvl-9"><strong>连接供需双方</strong>的搜索<strong>成本降低</strong></li>
</ol>
</li>
<li class="lvl-6">
<p>例子：二八定律，图书【从销售畅销书到为大量小众作家出书，收取出书费，即<strong>资产生产与销售转向佣金与平台使用费</strong>】、乐高【定制化积木到用户自己设计的积木，即复用了原来的生产渠道，又能提高用户粘性，从大量用户设计的产品中创造小收益】</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>开放商业模式</strong>：系统性与外部伙伴合作而创造和获取价值</p>
<ol>
<li class="lvl-6">开放的商业模式通常是以<strong>多边平台</strong>为基础，来降低搜索成本</li>
<li class="lvl-6">“由外到内”：将外部的理念、技术或知识产权引入内部；帮助企业实现<strong>跨越式发展</strong></li>
<li class="lvl-6">“由内到外”：以研发为核心的组织往往产生许多<strong>内部无法实用化</strong>的知识、技术、和智力资产；将内部的知识产权或技术，特别是<strong>闲置资产</strong>向外出售，如<strong>军转民</strong>，航天科技，<strong>高校成果转化</strong></li>
<li class="lvl-6">例子：宝洁、葛兰素史克</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/16.png" alt=""></p>
<h1>3. 商业模式设计</h1>
<ol>
<li class="lvl-3">
<p><strong>客户洞察</strong></p>
<ol>
<li class="lvl-6">看：描述该客户在她所处的环境中所<strong>看到的东西</strong>，同类产品、朋友、看我们的产品</li>
<li class="lvl-6">听：描述环境如何<strong>影响到这个客户</strong></li>
<li class="lvl-6">想&amp;感受：尝试勾勒你的<strong>客户思维</strong>的过程，重要、打动</li>
<li class="lvl-6">说&amp;做：想象客户可能的<strong>言辞</strong>，或公共场合的<strong>行为</strong>(本产品尚无出现)</li>
<li class="lvl-6">痛点：<strong>已遭受的挫折、正遇到的阻碍、怕承担的风险</strong></li>
<li class="lvl-6">收益：<strong>预期成就、成功衡量标准、实现目标所采用的策略</strong></li>
</ol>
</li>
<li class="lvl-3">
<p><strong>构思</strong></p>
<p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称作<strong>构思</strong>(ideation)</p>
<ol>
<li class="lvl-6">
<p><strong>灵感</strong>【从各处收集灵感】、<strong>构思</strong>【将灵感转为想法】、<strong>实施</strong>【把最佳的想法发展成计划】</p>
</li>
<li class="lvl-6">
<p>头脑风暴法</p>
</li>
<li class="lvl-6">
<p>资源驱动、供给驱动【创造全新的价值主张：次日达】、客户驱动、财务驱动、多点驱动</p>
</li>
<li class="lvl-6">
<p>如果…会怎么样？</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>视觉化思考</strong></p>
<ol>
<li class="lvl-6">识别各个元素的关系，形成共同理解</li>
<li class="lvl-6">流程：理解、对话、探索、沟通</li>
<li class="lvl-6">便利贴 + 绘画</li>
<li class="lvl-6">作用
<ol>
<li class="lvl-9">理解商业模式的本质</li>
<li class="lvl-9">提升对话效率</li>
<li class="lvl-9">探索创意</li>
<li class="lvl-9">提升沟通</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>模型构建</strong></p>
<ol>
<li class="lvl-6">
<p>通过<strong>绘制很多(粗略的)商业模式模型</strong>来代表<strong>各种战略选择</strong>，再通过对每个模型添加和移除元素的方式来<strong>探索新想法</strong>，选择最佳的模式</p>
<ol>
<li class="lvl-9">随手素描：勾勒一个粗略的主意</li>
<li class="lvl-9">精心描绘的画布</li>
<li class="lvl-9">商业案例：检查该创意的可存活度</li>
<li class="lvl-9">实地验证：调查客户的可接受度和可行性</li>
</ol>
</li>
<li class="lvl-6">
<p>为出版一本书准备的八个商业模式模型</p>
<table>
<thead>
<tr>
<th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/img/book3/6.png" alt=""></th>
<th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/img/book3/7.png" alt=""></th>
</tr>
</thead>
</table>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>讲故事</strong></p>
<p>即创造角色在使用产品的前后发生的故事，来体现产品在9个方面的特点。让听众放下对陌生事物的怀疑</p>
<ol>
<li class="lvl-6">
<p>公司视角</p>
</li>
<li class="lvl-6">
<p>客户视角</p>
</li>
</ol>
<p>尽可能地让<strong>故事简单</strong>，只设计一个故事主角，根据受众的不同，可以采用不同视角的故事主角。</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/img/book3/10.png" alt=""></p>
<p><strong>作用-为什么要讲故事？</strong>：</p>
<ol>
<li class="lvl-6">
<p>介绍新想法，尝试融入组织战略</p>
</li>
<li class="lvl-6">
<p>向投资人推销，争取外部资源</p>
</li>
<li class="lvl-6">
<p>吸引员工</p>
</li>
<li class="lvl-6">
<p>让未来触手可及</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>场景</strong></p>
<ol>
<li class="lvl-6">
<p><strong>作用</strong></p>
<ol>
<li class="lvl-9">
<p>搭建一个<strong>物理环境</strong>来给用户带来一个独立体验。</p>
</li>
<li class="lvl-9">
<p>将<strong>模型构建中</strong>明确的<strong>方向具体化</strong>，从而给出有见地的设计</p>
</li>
<li class="lvl-9">
<p>场景可以让抽象的事物变得具体。</p>
</li>
</ol>
</li>
<li class="lvl-6">
<p>场景类型</p>
<ol>
<li class="lvl-9">
<p><strong>不同客户结构</strong></p>
<ol>
<li class="lvl-12">产品或服务将被如何使用</li>
<li class="lvl-12">什么样的客户会用到它们</li>
<li class="lvl-12">客户的担忧、诉求和目标</li>
<li class="lvl-12">以上都是基于<strong>客户洞察</strong>而产生的。</li>
</ol>
</li>
<li class="lvl-9">
<p><strong>未来的竞争环境</strong></p>
<ol>
<li class="lvl-12">描述一个商业模式未来可能的竞争环境</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">
<p>为故事补充场景</p>
<ol>
<li class="lvl-9">了解与评估</li>
<li class="lvl-9">购买与获得</li>
<li class="lvl-9">交互</li>
<li class="lvl-9">售后</li>
<li class="lvl-9">评价</li>
<li class="lvl-9">复购</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>4. 商业模式评估</h1>
<ol>
<li class="lvl-3">
<p>商业模式环境</p>
<ol>
<li class="lvl-6">市场影响力：<strong>市场问题</strong>【市场发展趋势】、<strong>分类</strong>【客户群体是哪些】、<strong>需求与诉求</strong>【客户想要什么，想解决什么】、**切换成本(**转向竞争对手)【什么是我们能提供但其他人提供不了的】、<strong>收入影响力</strong>【客户在在我们的什么服务上付费】</li>
<li class="lvl-6">行业影响力：<strong>竞争对手</strong>【现有对手的优劣势和影响】、<strong>新进入者</strong>、<strong>替代品和竞品</strong>、<strong>供应链和价值链上的其他厂商</strong>【与我们合作的】、<strong>利益相关者</strong>【哪些人会影响我们的商业模式：员工、政府】</li>
<li class="lvl-6">关键趋势：<strong>行业管理趋势</strong>、<strong>技术趋势</strong>、<strong>社会文化趋势</strong>、<strong>社会经济趋势</strong>【人口趋势，经济趋势】</li>
<li class="lvl-6">宏观经济影响：<strong>全球市场经济</strong>、<strong>资本市场经济</strong>【获得投资容易吗】、<strong>大宗商品和其他资源</strong>【如人力资源】、<strong>经济基础设施</strong>【社会基础设施、税费】</li>
</ol>
</li>
<li class="lvl-3">
<p>评估商业模式(SWOT)</p>
<ol>
<li class="lvl-6"><strong>价值主张</strong>
<ol>
<li class="lvl-9"><strong>S/W</strong>：用户需求是否匹配、价值主张有没有网络效应(即相互关联促进)、产品和服务强耦合、用户满意</li>
<li class="lvl-9"><strong>O</strong>：能为客户再做什么、产品服务能不能优化</li>
<li class="lvl-9"><strong>T</strong>：有可替代的产品服务吗</li>
</ol>
</li>
<li class="lvl-6"><strong>成本/收入</strong>——<strong>成本结构、收入来源</strong>
<ol>
<li class="lvl-9"><strong>S/W</strong>：利润高、收入可预期、收入可持续、收入多样化、支出前有进账、客户想买的就是我们提供的；成本可预测、规模经济中收益</li>
<li class="lvl-9"><strong>O</strong>：客户还愿意为什么付费、把一次性收入变成持续收入；能否消减成本、能否有新的盈利点</li>
<li class="lvl-9"><strong>T</strong>：利润受竞争对手威胁吗、过多依赖一项收入吗、哪些成本不能预测、成本会不会超过收入</li>
</ol>
</li>
<li class="lvl-6"><strong>基础设施</strong>——<strong>核心资源、关键业务、重要合作</strong>
<ol>
<li class="lvl-9"><strong>S/W</strong>：竞争对手能复制我们核心资源吗、需求可预期、合适时间部署合适资源、有效执行关键业务、关键业务难以被复制、合作关系融洽吗</li>
<li class="lvl-9"><strong>O</strong>：资源能否成本更低、哪些资源被闲置可以转让吗、关键业务能提高效率吗、有更好的合作吗、能扩大合作以让我们聚焦核心业务吗</li>
<li class="lvl-9"><strong>T</strong>：资源会短缺吗，资源质量能否保证、哪些业务会受影响、合作伙伴会失去吗、是否过于依赖一个合作伙伴</li>
</ol>
</li>
<li class="lvl-6"><strong>客户界面</strong>——<strong>渠道通路、客户关系、客户细分</strong>
<ol>
<li class="lvl-9"><strong>S/W</strong>：用户流失吗、用户分类很好吗、新用户多吗、渠道有效果吗、客户可以轻易接触渠道吗、渠道产生规模经济吗、客户关系强吗、切换成本高吗、品牌强吗</li>
<li class="lvl-9"><strong>O</strong>：能服务新客户群体吗、能更细致的划分客户吗、能提高渠道的效率如去中间商吗、能与客户关系更紧密吗、如何提高用户的切换成本</li>
<li class="lvl-9"><strong>T</strong>：竞争对手会威胁渠道吗，会占用我们的市场份额【即占据我们的客户细分吗】、客户关系会恶化吗【公关的重要性】</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>从商业模式角度看蓝海战略</p>
<ol>
<li class="lvl-6">
<p>蓝海战略：通过<strong>根本性的差异化</strong>来创造全新的行业，而不是通过<strong>模仿现有商业模式在当前行业中竞争</strong>(价值创新)</p>
</li>
<li class="lvl-6">
<p>蓝海战略强调在<strong>增加价值</strong>的同时<strong>减少成本</strong>，通过删除和消减低价值产品或服务来降低成本，通过<strong>提升和创造</strong>对成本影响弱的<strong>高价值</strong>产品或服务来实现增加价值</p>
</li>
<li class="lvl-6">
<p>四项行动架构：增加价值、减少成本</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/img/book4/24.png" alt=""></p>
<ol>
<li class="lvl-9">
<p><strong>删除</strong></p>
</li>
<li class="lvl-9">
<p><strong>削减</strong></p>
</li>
<li class="lvl-9">
<p><strong>提升</strong></p>
</li>
<li class="lvl-9">
<p><strong>创造</strong></p>
</li>
</ol>
</li>
<li class="lvl-6">
<p>三个出发点</p>
<ol>
<li class="lvl-9"><strong>客户群体</strong>
<ol>
<li class="lvl-12">你可以聚焦哪些新的客户群体，哪些客户群体可以消减或删除？</li>
<li class="lvl-12">新的客户群体真正希望你帮他们完成哪些工作？</li>
</ol>
</li>
<li class="lvl-9"><strong>价值主张</strong>
<ol>
<li class="lvl-12">哪些低价值的功能或者服务可以被删除或消减？</li>
<li class="lvl-12">可以通过新增或加强哪些功能或服务来产生有价值的客户新体验？</li>
</ol>
</li>
<li class="lvl-9"><strong>成本</strong>
<ol>
<li class="lvl-12">
<p>哪些业务、资源和合作伙伴关系的成本最高？</p>
</li>
<li class="lvl-12">
<p>如果消减或删除这些成本项，会发生什么？</p>
</li>
<li class="lvl-12">
<p>在删减或消除代价高昂的KR、KA或KP后，如何利用低成本的元素来代替它们创造价值</p>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">
<p>蓝海精神：持续打造和运营产品体系</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p>管理多种商业模式</p>
<ol>
<li class="lvl-6">成功应对如何在实施和管理新商业模式的同时维持现有的商业模式。这个挑战的组织被称为:<strong>二元组织</strong>。</li>
<li class="lvl-6">双变量准则【合并还是拆分】：冲突程度、战略相似性</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>需求和商业模式创新</category>
      </categories>
      <tags>
        <tag>需求和商业模式创新</tag>
      </tags>
  </entry>
  <entry>
    <title>4 网络层-数据平面</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/4%20%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h1>4 网络层-数据平面</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429111116397.png" alt="image-20220429111116397"></p>
<span id="more"></span>
<h2 id="4-1-导论">4.1 导论</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429111936600.png" alt="image-20220429111936600"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429112347623.png" alt="image-20220429112347623"></p>
<p><strong>转发</strong>——数据平面，决定从哪个端口入，从哪个端口出，是局部功能</p>
<p><strong>路由</strong>——控制平面，决定分组该怎么走，是全局功能</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429112447141.png" alt="image-20220429112447141"></p>
<p>转发和路由分别有传统方式的 SDN 方式，因此共有四种组合</p>
<p>传统方式是数据平面和控制平面<strong>强耦合</strong>在一起，在一个路由器上一起实现，并且控制平面的路由表是分布式地在不同的路由器各自计算的【因此要修改非常难】</p>
<p>传统方式：<strong>控制平面算出路由表，数据平面根据路由表和分组的目标 IP 地址进行转发</strong> <strong>不可编程</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429113624038.png" alt="image-20220429113624038"></p>
<blockquote>
<p>SDN 根据多个字段而不是仅仅根据 IP 可以有多个动作：转发、block、泛洪、修改字段，<strong>因此是可编程的</strong></p>
<p>流表是网络操作系统(一个服务器)算出来，通过南向接口交给分组交换设备，分组交换设备把流表装载上之后就可以根据流表进行多个字段的匹配。<strong>因此控制平面是集中式的</strong></p>
<p><strong>这里的路由器叫做分组交换机</strong></p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429114444557.png" alt="image-20220429114444557"></p>
<p><strong>网络服务模型</strong>（<em>network service model</em>）定义了分组在发送与接收端系统之间的<strong>端到端运输特性</strong>。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429115302243.png" alt="image-20220429115302243"></p>
<p><strong>（可见 IP 网络是尽力而为的，即什么都不保证。尽力而为服务看起来是根本无服务的一种委婉说法）</strong></p>
<p>主机到主机的网络层连接不仅仅体现在端主机之上，而且体现在中间路径上经过的所有交换节点</p>
<p><strong>TCP / IP 网络中 IP 网络层向上层提供的服务（不存在连接建立）：</strong> 路由表由控制平面产生，交给 IP 协议，根据路由表对到来的分组进行转发，实现数据平面的功能</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429115117104.png" alt="image-20220429115117104"></p>
<p>对有一些网络，要提供连接建立的功能</p>
<h2 id="4-2-路由器组成">4.2 路由器组成</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220429120911015.png" alt="image-20220429120911015"></p>
<p>任何一个端口都可以既输入又输出混合在一起的，没有独立的输入/输出端口</p>
<p>每个端口有 3 个方框，分别为物理层，链路层，网络层。路由表要交给每个端口的网络层</p>
<blockquote>
<p>指的是路由器的物理输入和输出接口，这完全 不同于第2、3章中所讨论的与网络应用程序和套接字相关联的软件端口</p>
</blockquote>
<h3 id="输入端口">输入端口</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430093745617.png" alt="image-20220430093745617"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430094051788.png" alt="image-20220430094051788"></p>
<p>当出现多个输入端口转到相同输出端口时，需要排队，因此会导致交换速率小于输入速率，所以需要排队</p>
<p><strong>队头阻塞</strong> <strong>HOL blocking</strong>  <em>head of the line blocking</em> ：队列的首个packet由于它的目的端口正忙而被延迟转发，导致后面的packets被blocked</p>
<h3 id="交换结构">交换结构</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430104949033.png" alt="image-20220430104949033"></p>
<p>交换速率应当是 N 倍于输入线路的输入速率（ N 为输入端口数量）</p>
<p><strong>通过内存交换</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430105129633.png" alt="image-20220430105129633"></p>
<p>通过 bus 两次</p>
<p><strong>通过总线交换</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430105514365.png" alt="image-20220430105514365"></p>
<p>分组通过 bus 时要加上输出端口的地址，输出端口发现是自己的端口，那么就将其从这个端口输出</p>
<p><strong>通过互联网络交换</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430105713225.png" alt="image-20220430105713225"></p>
<p>同时可以<strong>转发多个分组</strong></p>
<h3 id="输出端口">输出端口</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430110116587.png" alt="image-20220430110116587"></p>
<p>队列中的分组发送顺序不一定是 FIFO 的，可以采用一些调度规则，实现按优先级发送</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430110458097.png" alt="image-20220430110458097"></p>
<p>输入和输出端口都有可能导致分组的丢弃</p>
<h3 id="调度机制">调度机制</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430110602462.png" alt="image-20220430110602462"></p>
<p>通常默认是 FIFO</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430110730870.png" alt="image-20220430110730870"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430110923709.png" alt="image-20220430110923709"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430111048050.png" alt="image-20220430111048050"></p>
<h2 id="4-3-Internet-Protocol">4.3 Internet Protocol</h2>
<p>所有网络从IP 角度看都是 IP 网络，<strong>IP 是 over everything 的</strong>，IP 是在各种物理网络上运行的。<strong>能够成功的兼容不同的物理网络【不同的链路协议】让不同的链路协议可以组合在一起，在网络层都是 IP 协议，在链路层的不同跳上则是不同类型的链路协议</strong>，IP 的提出就是为了让当时不同类型的网络能够相互兼容地运行</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430111344286.png" alt="image-20220430111344286"></p>
<p><strong>IP 协议</strong>根据分组头部的 DA 字段匹配路由表，<strong>实现数据平面的转发功能</strong></p>
<h3 id="IP-数据报格式">IP 数据报格式</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430111703747.png" alt="image-20220430111703747"></p>
<p><strong>20 B 的头部</strong> + 可能的 option 【由 head len 字段记录头部总长】+ data</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>版本号</strong>：在 IPv4 为 4【4 bit】</p>
</li>
<li class="lvl-2">
<p><strong>首部长度</strong> head len 的单位是 4 B ，因此如果head len = 5 ，那么表示 4*5 = 20 B 【4 bit】</p>
</li>
<li class="lvl-2">
<p><strong>区分服务</strong>: 用来区分不同的数据报，以便按优先级获得更好的服务,但实际上一直没被用过【8 bit】</p>
</li>
<li class="lvl-2">
<p><strong>总长度</strong>：IP 报头+数据的长度【16 bit】</p>
</li>
<li class="lvl-2">
<p><strong>标识</strong> identification：在IP软件在存储器中维持着一个计数器，每产生一个数据报，计数器就+1，并将此值赋值给标识字段。当IP数据报长度超过 MTU 而必须进行分片，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各个数据报片最后的能正确地重装成为原来的数据。【16 bit】</p>
</li>
<li class="lvl-2">
<p><strong>标志</strong> flag：目前只有两位有意义【3 bit】</p>
<ul class="lvl-2">
<li class="lvl-4">标志字段中的<strong>最低位为MF</strong> <em>more fragments</em>。MF=1即表示后面“还有分片”的数据报。MF=0表示的是这个数据报的最后一个。</li>
<li class="lvl-4">标志字段中的<strong>中间一位记为DF</strong> <em>don’t fragment</em>，当DF记为1时，表示的是“不能分片”。</li>
<li class="lvl-4">最高位：<em>reversed bit</em></li>
</ul>
</li>
<li class="lvl-2">
<p><strong>片偏移</strong>：某片在原分组中的相对位置，便于后续接收时正确地重组。<strong>片偏移以8字节为单位</strong>。这就是说，<strong>每个分片长度一定是8字节的整数倍。</strong>【13 bit】</p>
</li>
<li class="lvl-2">
<p><strong>生存时间</strong> ：数据报能在因特网中经过的路由器的最大数值是<strong>255</strong>【8 bit】</p>
</li>
<li class="lvl-2">
<p><strong>上层协议</strong> protocol：指出此数据携带的数据是使用何种协议，以便让目的 IP 层知道将数据部分上交到哪个处理过程。如TCP，UDP**[17]**等等【8 bit】</p>
</li>
<li class="lvl-2">
<p><strong>首部检验和</strong>：检验头部是否正确【16 bit】</p>
</li>
<li class="lvl-2">
<p><strong>源IP地址</strong>：【32 bit】</p>
</li>
<li class="lvl-2">
<p><strong>目的IP地址</strong>：【32 bit】</p>
</li>
</ul>
<h3 id="分片和重组">分片和重组</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430142315368.png" alt="image-20220430142315368"></p>
<p>以太网对数据帧的长度都有一个限制，即 <strong>最大传输单元 MTU</strong> <em>Maximum Transmission Unit</em> 为<strong>1500 B</strong></p>
<p>因此需要将大的 IP 数据报/包分片，但不能直接分片，要拷贝头部信息</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430142132152.png" alt="image-20220430142132152"></p>
<p>每一个片的载荷/数据部分【不包括头部】都一定是 8 B 的倍数，如上的 1480 B</p>
<p>每一片都具有<strong>相同的标识</strong>【用于确定哪些是一个组的】，但不同的偏移量，偏移量记录的是<strong>分片的数据部分在原来的数据部分的偏移量【均不涉及头部】</strong></p>
<p><strong>重组一定只在最终的目标主机上进行</strong>，减少对中间路由器的压力，同时，不同的片可能走不同的路径，也无法在中间路径上全部重组</p>
<p><strong>如果有某分片丢失了</strong>，那么所有该标识的分片都会被目标主机丢弃，如果上层是 TCP，那么超时重发。因此分片会增加丢失的概率，导致重发增加，效率降低，因此不建议切分 IP 数据报。</p>
<blockquote>
<p>TCP协议为了减少IP报被切分的概率，双方主机在握手阶段会交换自己的MSS</p>
<p>MSS是TCP层交互给IP层最大分段大小，不包含TCP报头，只包含数据所以TCP为了减少被切分的概率，就确定一个MSS限制每一次交互给IP层的数据大小。MSS数据大小去掉IP报头和TCP报头，IP报头和TCP报头都是20个字节（不考虑扩展项）。因此：<strong>MSS数据大小=MTU-20-20</strong>（MTU默认值是1500个字节，也可以是其它值）。</p>
<p><strong>所以双方主机在建立连接的时候会交换自己的MSS大小值</strong>，最终大小<strong>取决于双方主机的较小值</strong>，如果一台主机的MSS是1200个字节，另一台主机的MSS是1300个字节，所以双方主机MSS都取1200个字节，那么双方通信的时候TCP层面发送的数据都是1200个字节。<br>
<a href="https://blog.csdn.net/sjp11/article/details/124170051">https://blog.csdn.net/sjp11/article/details/124170051</a></p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430142925705.png" alt="image-20220430142925705"></p>
<h3 id="IP-编址">IP 编址</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430143913198.png" alt="image-20220430143913198"></p>
<p><strong>IP 地址用来标识接口</strong>，如主机，IP 地址不是用来标识主机，而是标识主机连接的那个接口/点的，一个主机也可以有多个接口，包含多个 IP</p>
<h4 id="子网">子网</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430144422811.png" alt="image-20220430144422811"></p>
<p>IP 地址：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>子网部分（高位 bit）</p>
</li>
<li class="lvl-2">
<p>主机部分（低位 bit）</p>
</li>
</ul>
<p>一个子网内部的主机的到达<strong>在 IP 层面一跳可达</strong>，<strong>不需要借助路由器，可以借助交换机即可</strong></p>
<blockquote>
<p>链路层：在长途链路中采用点到点的连接，减少绕路；在局域网中采用多点连接即多个设备连到交换机上，经过交换机到达其他点</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430144733795.png" alt="image-20220430144733795"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430145144550.png" alt="image-20220430145144550"></p>
<p>如上，有 <strong>6</strong> 个子网</p>
<h4 id="IP-地址分类">IP 地址分类</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430145244700.png" alt="image-20220430145244700"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>A 类地址：<strong>最高地址为0</strong>，2<sup>7</sup>-2 = 126 个网络，<strong>注意减 2 是因为全 0 和全 1 的网络不使用</strong>，每个网络有 2<sup>24</sup>-2 个主机</p>
</li>
<li class="lvl-2">
<p>B 类地址：<strong>最高地址为 10</strong>，2<sup>14</sup>-2 个网络，2<sup>16</sup>-2 个主机</p>
</li>
<li class="lvl-2">
<p>C 类地址：<strong>最高地址为 110</strong>，2<sup>21</sup>-2 个网络，2<sup>8</sup>-2个 主机</p>
<p>ABC 类地址均为单播地址，D类地址为组播地址<a href="https://m.elecfans.com/article/1163386.html">单播与组播、广播及任播有什么区别-电子发烧友网 (elecfans.com)</a></p>
<blockquote>
<p>组播解决了单播和广播方式效率低的问题，组播路由器借助组播路由协议为组播数据包建立树型路由，被传递的信息在尽可能远的分叉路口才开始复制和分发。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>D 类地址：<strong>最高地址为 1110</strong>，2<sup>28</sup>-2 个，D类地址不能出现在IP报文的<strong>源IP地址</strong>字段。</p>
</li>
<li class="lvl-2">
<p>E 类地址：<strong>最高地址为 11110</strong>，为未来预留的</p>
</li>
</ul>
<p>互联网的路由是**以网络为单位【而不是一个 IP 地址一个表项】**来路由信息的发布和计算的，<strong>一个子网在路由器中就是一个表项</strong></p>
<p>而且如上面的子网图中，可以将 3 个子网<strong>聚集</strong>成一条<strong>向外发布</strong> <em>【即这些子网从更短的掩码或者从外部来看，也可以看作一个子网，因此只要是这些子网【即根据更短的掩码】的数据报，都发给这个路由器即可，接下来往哪个子网发，这个路由器会知道】</em>，进一步减少在广域网中路由表表项的数目和计算的代价</p>
<h4 id="特殊-IP-地址">特殊 IP 地址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430152710393.png" alt="image-20220430152710393"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430154658524.png" alt="image-20220430154658524"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>网络地址</strong>：{<Network-number>，<Host-number>}={<Network-number>，0} 该地址用于标识网络，不能分配给主机，因此不能作为数据的源地址和目的地址。</p>
</li>
<li class="lvl-2">
<p><strong>直接广播地址</strong>：{<Network-number>，<Host-number>}={<Network-number>, -1} 向某个网络上所有的主机发送报文。<strong>直接广播地址只能作为目的地址。</strong></p>
</li>
<li class="lvl-2">
<p><strong>受限广播地址</strong>：{<Network-number>，<Host-umber>}={-1, -1} 受限广播地址是在本网络内部进行广播的一种广播地址。TCP/IP规定，32比特全为“1”的IP地址用于本网络内的广播。**受限广播地址只能作为目的地址。 **</p>
<blockquote>
<p>直接广播要求发送方必须知道信宿网络的网络号。但有些主机在启动时，往往并不知道本网络的网络号，这时候如果想要向本网络广播，只能采用受限广播地址（Limited Broadcast Address）。 <a href="https://www.bilibili.com/read/cv14336375">https://www.bilibili.com/read/cv14336375</a></p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>回环地址</strong>：127开头，后面任意*【除了全0，全0表示网络地址和全1，全1表示该网络的广播地址】*到了 IP 层会直接返回</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430152840849.png" alt="image-20220430152840849"></p>
</li>
<li class="lvl-2">
<p><strong>0.0.0.0</strong>，特殊的源地址，表示的是网络上的所有主机，一般在写服务端程序绑定监听地址时常用此地址。</p>
</li>
</ul>
<h4 id="专用-内网-IP-地址">专用(内网) IP 地址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430154844277.png" alt="image-20220430154844277"></p>
<p><strong>内网地址用于区分局部网络中的不同设备</strong></p>
<p>路由器不对目标地址是内网地址的分组进行转发，即不能在公网中转发，只能在内网中使用</p>
<blockquote>
<p>因此 ping 上述的内网地址一定会超时，分组被丢弃。但 ping 除内网地址外的地址都是可以 ping 到的【也有可能超时，有些 IP 不能访问】，因为 IPv4 地址早已分配完了</p>
</blockquote>
<h4 id="CIDR">CIDR</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430155530440.png" alt="image-20220430155530440"></p>
<p>B 类地址主机太多，C 类地址主机太少，因此都不太合适，所以产生了<strong>无类域间路由</strong>，不分类，可以任意划分前多少个 bit 为网络号，这样就可以控制主机数目适中。</p>
<p>但这样看到 IP 地址时就不能像按类划分那样看前面几位就能确定前面多少位是网络号了，<strong>因此需要将 IP 与子网掩码与操作，即可得到网络号</strong></p>
<h3 id="转发">转发</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430160426352.png" alt="image-20220430160426352"></p>
<p>对于到来的 IP 数据报中的目标地址，需要对每一个表项进行掩码与并和对应的网络号对比，相同则从这个端口转发出去</p>
<h3 id="如何获得-IP-地址">如何获得 IP 地址</h3>
<h4 id="主机如何获得-IP-地址">主机如何获得 IP 地址</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430160854594.png" alt="image-20220430160854594"></p>
<p>需要配置4个信息：<strong>IP、子网掩码、默认网关、local DNS</strong></p>
<h5 id="DHCP">DHCP</h5>
<p><em>Dynamic Host Configuration Protocol</em> 动态主机配置协议</p>
<p><strong>DHCP 是基于 UDP 的应用</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430161109899.png" alt="image-20220430161109899"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430161402186.png" alt="image-20220430161402186"></p>
<p>自动申请IP地址的过程：</p>
<ol>
<li class="lvl-3">
<p>主机**广播请求【全1的 IP 广播】**寻找能够提供IP地址的DHCP服务器</p>
<p>【DHCP 请求报文👉目的端口 <strong>67</strong> （DHCP服务器）和源端口 <strong>68</strong> （DHCP客户）的UDP报文段👉有广播 IP 目的地址（<strong>255.255.255.255</strong>）和源 IP 地址 <strong>0. 0. 0. 0</strong> 的 IP 数据报👉有目的 MAC 地址 <strong>FF : FF : FF : FF : FF : FF</strong> 和 源 MAC 地址的以太网帧】</p>
</li>
<li class="lvl-3">
<p>服务器收到请求后，查看自己是否有可提供的IP地址（需要事先在DHCP服务器上配置地址池和可以提供的IP地址范围）。如果有，就回应可以提供的IP地址和可使用的时间（通常叫租期）</p>
</li>
<li class="lvl-3">
<p>主机收到服务器回应的消息后，知道可以使用这个IP地址和租期，会发送确认请求</p>
</li>
<li class="lvl-3">
<p>服务器收到来自主机的请求，再 ACK</p>
</li>
</ol>
<p>为什么需要再发一次 request 呢？</p>
<p>因为<strong>可能有多个</strong> DHCP 服务器，主机只需要选择一个 DHCP 提供的 IP 即可【一般第一个】，因此要告诉其余的 DHCP 服务器，不需要它们分配的 IP 了</p>
<h4 id="机构如何获得-IP-地址池">机构如何获得 IP 地址池</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430162535943.png" alt="image-20220430162535943"></p>
<p>通过将 ISP 的网络号增加几位，如上增加 3 位，则前 20 位为网络号，后 3 位为子网号【<em>可以分配给 8 个机构</em>】，再后面为主机号，这样就能从 ISP  获取一个 IP 地址池</p>
<h5 id="层次编址：可以路由聚集">层次编址：可以路由聚集</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430163526208.png" alt="image-20220430163526208"></p>
<p>路由器 IP0 向前面的路由器 IPx 发布通告，凡是通过掩码（23）得到是 IP0 的，那么下一跳 <em>hop</em> 都是 IP0 路由器，IPx 需要转发到连接 IP0 的接口。</p>
<p>其他的同理，因此上图左下可见 IPx 的路由表。</p>
<p>而对于 IPx 它要把路由表信息发布给更前面的路由器 IPw，可以把路由表中每一条都转发，只不过在 IPw 中相应 IP 的下一跳会变成 IPx，但这样会导致越往上，路由表越大。</p>
<p>因此这里可以<strong>路由聚集</strong>，显然 IP0~IP3 都是从 IPx 划分出来的子网，因此 IPx 可以向 IPw 发布这样的信息，凡是掩码（20） 得到是 IPx 的都转发到 IPx路由器，等报文到了 IPx 中，它根据自己的路由表可以将其进行进一步的转发</p>
<p><strong>要可以聚集才能聚集，如果不是由一个大的划分成小的，那么必须一条一条的发布通告</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430164719591.png" alt="image-20220430164719591"></p>
<p>当 IP1 被分到另外一个 ISP时，原来的 ISP 的路由器 IPx <strong>即使有空洞</strong>，即并不是掩码（20）后为 IPx 的都应该转发给它，IP1 就不是，但为了减少表项数目，<strong>仍然可以进行路由聚集</strong>。在 IPy 中 IP1 不能聚集，因此需要单条地发布给上层 IPw。</p>
<p><em><em>因此在路由表项匹配时，可能会出现多个能够匹配的表项</em>【如上 IPw 的第一和第二条都能匹配 200.23.18.1】*，要选择其中匹配长度最长的表项作为转发</em>*</p>
<h4 id="ISP-如何获取-IP-地址池">ISP 如何获取 IP 地址池</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430162425118.png" alt="image-20220430162425118"></p>
<p>ISP 则可以从 ICANN <em>Internet Corporation for Assigned Names and Numbers</em> 获取 IP 地址池</p>
<h3 id="NAT">NAT</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430165900248.png" alt="image-20220430165900248"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430170049881.png" alt="image-20220430170049881"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430170418853.png" alt="image-20220430170418853"></p>
<p>内网可以访问到外网，但外网不能主动访问到内网，需要内网穿透</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430171112883.png" alt="image-20220430171112883"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430171153839.png" alt="image-20220430171153839"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430171830343.png" alt="image-20220430171830343"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430172053958.png" alt="image-20220430172053958"></p>
<p>如 Skype</p>
<h3 id="IPv6">IPv6</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430172244401.png" alt="image-20220430172244401"></p>
<p>IPv4 的问题</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每到一个路由器，<strong>TTL要减去 1，因此首部校验和也要作相应的改变</strong>，会加重路由器负担</p>
</li>
<li class="lvl-2">
<p>会产生分片</p>
</li>
<li class="lvl-2">
<p>IPv4 的头部没有机制对 <strong>QoS</strong> <em>Quality of Service</em>，<strong>服务质量</strong> 的支持，即是尽力而为的</p>
</li>
</ul>
<blockquote>
<p>IPv5是一个<strong>实验性的</strong>资源预留协议，被称为因特网流协议(ST)，目的是提供服务质量-QOS。</p>
<p><a href="https://zhuanlan.zhihu.com/p/383008986">为什么有IPv4、IPv6，却没有IPv5？IPv10又是什么新鲜物种？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430173422178.png" alt="image-20220430173422178"></p>
<p>头部固定 40 B，options被 next header 标识，放在 data 部分</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430173733458.png" alt="image-20220430173733458"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430174322411.png" alt="image-20220430174322411"></p>
<p>只能<strong>平滑过渡</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220430174346683.png" alt="image-20220430174346683"></p>
<h2 id="4-4-通用转发和-SDN【了解】">4.4 通用转发和 SDN【了解】</h2>
<h3 id="传统方式的弊端">传统方式的弊端</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501153930425.png" alt="image-20220501153930425"></p>
<p>传统方式：<strong>垂直集成</strong>：每个路由器既实现数据平面的功能又实现控制平面的功能。路由表粘合两个平面</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501153802620.png" alt="image-20220501153802620"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501154014259.png" alt="image-20220501154014259"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501155022133.png" alt="image-20220501155022133"></p>
<p>而在 SDN 中很容易实现，因为 SDN 可以匹配多个字段，而不是传统的仅仅为 DA 字段，因此可以区分出不同的主机通信等，实现流量分路</p>
<h3 id="SDN-2005">SDN ~2005</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501154124348.png" alt="image-20220501154124348"></p>
<p><strong>CA</strong> <em>control agent</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501154429238.png" alt="image-20220501154429238"></p>
<p>注意：这里的分组交换机就是路由器，不是链路层的交换机</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501154625154.png" alt="image-20220501154625154"></p>
<p>这里所说的<strong>网络操作系统</strong>是指 <strong>SDN 下的远程控制器</strong>，不是指 windows 等【SDN 控制器在<strong>逻辑上是集中的</strong>，但为了可拓展性、性能等也可以采用分布式实现】</p>
<p>SDN 体系结构的 <strong>4 个关键特征</strong>：</p>
<ol>
<li class="lvl-3">
<p>通用“flow-based”<strong>基于流</strong>的匹配+行动</p>
</li>
<li class="lvl-3">
<p>控制平面和数据平面分离</p>
</li>
<li class="lvl-3">
<p>控制平面功能在数据交换设备外实现，由两个组件组成：一个 SDN 控制器或网络 OS；若干的网络控制应用</p>
</li>
<li class="lvl-3">
<p>可编程控制：在远程控制器之上以网络应用的形式【<em>如防火墙、负载均衡等</em>】实现各种网络功能，<strong>SDN 控制器通过北向接口 API 和网络控制应用交互</strong></p>
<p>编程的结果形成流表，控制器通过<strong>南向接口 API （如 OpenFlow 标准）<strong>下发给</strong>分组交换机</strong>，南向接口同时支持分组交换机将自身的状态上报给 SDN 控制器</p>
<p>OpenFlow协议运行在<strong>TCP</strong>之上，<strong>使用6653的默认端口号</strong></p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160327162.png" alt="image-20220501160327162"></p>
<p>在SDN中<strong>数据平面交换机</strong>，<strong>SDN控制器</strong>和<strong>网络控制应用程序</strong>是分离的实体。因此可以由不同的厂商来生产，有利于竞争和更良好的业态</p>
<h3 id="OpenFlow">OpenFlow</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160357280.png" alt="image-20220501160357280"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160508718.png" alt="image-20220501160508718"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160546054.png" alt="image-20220501160546054"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160641579.png" alt="image-20220501160641579"></p>
<p>如上，可以根据 MAC 进行转发，起到了交换机的作用</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160719695.png" alt="image-20220501160719695"></p>
<p><strong>几乎所有的网络设备</strong>都能通过<strong>匹配不同的流表+行动</strong>来实现</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501160940364.png" alt="image-20220501160940364"></p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>5 网络层-控制平面</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/5%20%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h1>5 网络层-控制平面</h1>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501163220684.png" alt="image-20220501163220684"></p>
<span id="more"></span>
<h2 id="5-1-导论">5.1 导论</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501163321330.png" alt="image-20220501163321330"></p>
<h2 id="5-2-路由选择算法">5.2 路由选择算法</h2>
<p><strong>路由可以看作是子网到子网的路由</strong>【<em>因此就是找到路由器到其他路由器的较好路径（到了这个路由器就到了这个子网）</em>】，<strong>而不是主机到主机的路由</strong>，因为可以想象 IPv4 那么 40 亿多个主机，要确定其中两个主机的最佳路由路径，很困难。</p>
<p>事实上，对于不在一个子网的主机的<strong>第一跳</strong>一定是发送给这个子网的网关，<strong>最后一跳</strong>一定是由目标子网的网关发送给目标主机</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501164618299.png" alt="image-20220501164618299"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501164659310.png" alt="image-20220501164659310"></p>
<h3 id="原则">原则</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501165222896.png" alt="image-20220501165222896"></p>
<p>汇集树：sink tree 这个节点到其他所有路由器的最优路径形成的树</p>
<p><strong>路由选择算法就是要为所有的路由器找到并使用汇集树</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501165607293.png" alt="image-20220501165607293"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501165721998.png" alt="image-20220501165721998"></p>
<h3 id="分类">分类</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501170151575.png" alt="image-20220501170151575"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>全局/分布式</p>
</li>
<li class="lvl-2">
<p>静态/动态：非自适应/自适应</p>
</li>
</ul>
<h3 id="link-state-全局算法">link state-全局算法</h3>
<p>链路状态算法：<strong>即Dijkstra 算法</strong></p>
<p>贪心算法</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501170746624.png" alt="image-20220501170746624"></p>
<ol>
<li class="lvl-3">
<p>获得整个网络拓扑</p>
</li>
<li class="lvl-3">
<p>使用Dijkstra 算法获得到达其他路由器的最短路径</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501171117187.png" alt="image-20220501171117187"></p>
<p>扩散即泛洪 <em>flooding</em> 让所有的路由器都能得到这个链路状态分组 LS。大家都这么做，所有可以让每个路由器都能得到其他所有节点的状况</p>
<p><strong>迭代算法即 Floyed 算法 所有顶点的最短路径(非负权值)</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501172715884.png" alt="image-20220501172715884"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501172724932.png" alt="image-20220501172724932"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501172829106.png" alt="image-20220501172829106"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501172900437.png" alt="image-20220501172900437"></p>
<p>一个节点 A 收到来自其他节点 B 的泛洪分组，那么要给这个节点发送 ACK 确认，同时将这个分组发送给 A 的其他的邻居 C D E……并期待它们的确认，如果没有收到确认，那么会 A 会一直重复发这个泛洪分组</p>
<p><strong>因此泛洪是可靠的</strong>，能够保证所有的节点都得到这个分组的信息</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501173145193.png" alt="image-20220501173145193"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501174900775.png" alt="image-20220501174900775"></p>
<h3 id="distance-vector-分布式算法">distance vector-分布式算法</h3>
<p>即 Bellman-Ford 算法</p>
<p>动态规划</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501175221942.png" alt="image-20220501175221942"></p>
<p>距离矢量中要记录</p>
<ol>
<li class="lvl-3">
<p>目标节点</p>
</li>
<li class="lvl-3">
<p>到达目标节点路径上的下一跳</p>
</li>
<li class="lvl-3">
<p>到达目标节点所需要的 cost</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501180228299.png" alt="image-20220501180228299"></p>
<p>和邻居交换距离矢量，再加上自己到邻居的代价，即可得到到达目标的最低代价</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501180410731.png" alt="image-20220501180410731"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501180516601.png" alt="image-20220501180516601"></p>
<p><strong>定期测量；定期交换</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501180819621.png" alt="image-20220501180819621"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501181100156.png" alt="image-20220501181100156"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501181731171.png" alt="image-20220501181731171"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501182023121.png" alt="image-20220501182023121"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>自己到邻居的代价改变了，<strong>要重新计算</strong></p>
</li>
<li class="lvl-2">
<p>邻居给自己的到达目标节点的代价改变了，邻居重新发给自己了，<strong>要重新计算</strong></p>
</li>
<li class="lvl-2">
<p>自己的 DV 更新改变后要通知其他的邻居</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501182434262.png" alt="image-20220501182434262"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501182718158.png" alt="image-20220501182718158"></p>
<p>特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>好消息传得快</p>
</li>
<li class="lvl-2">
<p>坏消息传的慢，需要很多次迭代才能发现不可达</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解决办法</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501195112398.png" alt="image-20220501195112398"></p>
<p>因为 C 要通过 B 才能到达 A，所以当 B 向 C 请求到达 A 时，C 应当告诉 B 为 INF。但告诉 D 时 C 会告诉 D 自己是可达的，这样就形成了水平分裂，<strong>C 的左右两边的信息不一样</strong></p>
</li>
<li class="lvl-4">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501200139928.png" alt="image-20220501200139928"></p>
<p>但水平分裂在<strong>环状的网络拓扑中效果不好</strong>，可以<strong>缓解</strong>传得慢【C 立即知道不可达】，<strong>但不能解决</strong>【A，B 需要很长时间才能发现】</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501200647260.png" alt="image-20220501200647260"></p>
<h3 id="LS-和-DV-的比较">LS 和 DV 的比较</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501201342351.png" alt="image-20220501201342351"></p>
<p>上面的<strong>振荡</strong>是指可能上个时间选择这条路径，这个时间因为这条路径拥塞，所以换了一条，下个时间因为拥塞用换回来</p>
<h2 id="5-3-自治系统内部的路由选择协议-内部网关协议">5.3 自治系统内部的路由选择协议-内部网关协议</h2>
<p>前面介绍的是抽象的算法，接下来是具体的协议，协议来实现算法</p>
<h3 id="RIP-适合小网">RIP-适合小网</h3>
<p><em>Routing Information Protocol</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501201958125.png" alt="image-20220501201958125"></p>
<p>基于 DV 算法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每条链路的 cost = 1，<strong>最大跳数为 15</strong>，如果跳数超过 15，即当作不可达</p>
</li>
<li class="lvl-2">
<p>通告 advertisements：</p>
<ol>
<li class="lvl-5">邻居定期<strong>每隔 30 s</strong>，则交换通告</li>
<li class="lvl-5"><strong>如果对方请求</strong>，那么可以直接发送通告</li>
</ol>
</li>
<li class="lvl-2">
<p>每个通告<strong>最多通告 25 个目标网络的 DV</strong>，因此<strong>适合小网的自治</strong></p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501202834977.png" alt="image-20220501202834977"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501202845156.png" alt="image-20220501202845156"></p>
<p>毒性逆转就是水平分裂</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501203009738.png" alt="image-20220501203009738"></p>
<p>网络层的功能借助应用进程来实现，为了实现这个功能，还借助了传输层的 UDP</p>
<h3 id="OSPF-适合大网">OSPF-适合大网</h3>
<p><strong>开放最短路径优先</strong> <em>Open Shortest Path First</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501203154282.png" alt="image-20220501203154282"></p>
<p>基于 LS 算法</p>
<p>直接在 IP 数据报上传送 OSPF 报文，不需要借助传输层协议</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501203457611.png" alt="image-20220501203457611"></p>
<p><strong>允许根据多个代价（跳数、延迟等）来计算最优</strong></p>
<p>在<strong>大型网络</strong>中支持<strong>层次性 OSPF</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501203810484.png" alt="image-20220501203810484"></p>
<p>分成多个 Area 分组<strong>只在一个 area 内进行泛洪</strong>，不会扩散到外面。area 之间来进行通信需要先交给骨干 area，由骨干 area 交给其他 area 其他 area 再在内部交给目标子网对应的路由器</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220501204152339.png" alt="image-20220501204152339"></p>
<h2 id="5-4-ISP-之间的路由选择">5.4 ISP 之间的路由选择</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504151614606.png" alt="image-20220504151614606"></p>
<p>前面讲的 RIP OSPF 等都是一个自治区内的路由选择，也就是一个平面内的路由。</p>
<p>但对于全球这么大的网络，显然用这些方法是非常困难的：<strong>规模问题、管理问题、安全问题</strong></p>
<p><strong>自治系统 AS</strong>  <em>Autonomous System</em></p>
<p>因此采用层次性路由，分为两层：</p>
<ol>
<li class="lvl-3">
<p>将网络划分成一个个的自治区域【<em>规模小，使用之前的路由协议可以轻松解决</em>】，<strong>自治区域内使用内部网关协议</strong> <em>intra-AS routing protocol</em>，且没有要求使用哪种协议，可以是 RIP 也可以是 OSPF 或者是其他的私有的协议</p>
</li>
<li class="lvl-3">
<p>自治区之间的路由：一个自治区在这个层面上只表现为一个点或者若干个很少的点，<strong>使用外部网关协议</strong> <em>inter-As routing protocol</em></p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504152817951.png" alt="image-20220504152817951"></p>
<h3 id="BGP">BGP</h3>
<p><em>Border Gateway Protocol</em> <strong>边际网关协议</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504153644839.png" alt="image-20220504153644839"></p>
<p>不是由组织制定的，而是大家约定俗成的，因此称为<strong>事实上的标准</strong></p>
<p>内部网关协议可以任意，但边际网关协议一定的一样的，不然不同的 AS 无法通信</p>
<blockquote>
<p>对于每个AS，每台路由器要么是一台网关路由器（gateway router），要么是一台内部路由器（internal router）。网关路由器位于AS边缘，直接连接到其他AS的路由器。内部路由器仅连接自己AS中的主机和路由器。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>eBGP</strong> <em>exterior BGP</em> 网关路由器从其他相邻的网关路由器得到他们收集来的自己所在的 AS 的可达信息</p>
<p>如下的 1c 把自己子网的可达信息告诉 2a 后，2a 内都得到这个信息，那么 2c 就可以把这个信息进行 re-advertisement，将其<strong>转发</strong>给 3a【<code>但注意加增加一跳信息，即3a 要达到 AS1 需要通过 AS2</code>】，所以 3a 就可以知道 AS1 中的可达信息了，同时 2c 也会把<strong>自己</strong> AS2 的可达信息告诉 3a</p>
</li>
<li class="lvl-2">
<p><strong>iBGP</strong> <em>interior BGP</em> 网关路由器将上面得到的子网可达信息传遍 AS 内部的所有路由器。告诉内部路由器，到到某个子网通过我这个网关路由器就可以到</p>
<p>但注意下面的虚线不一定是物理链路，而是 TCP 连接，通过 TCP 传递子网可达信息，那么 TCP 怎么路由呢？自然是通过内部网关协议即可</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504154409486.png" alt="image-20220504154409486"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504155855608.png" alt="image-20220504155855608"></p>
<p><strong>基于改进的 DV 算法</strong>，不仅仅包含距离（即多少跳）还包含路径，因此可以检查出其中的环路，避免无穷计算问题，收敛速度更快</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504155255097.png" alt="image-20220504155255097"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504160748484.png" alt="image-20220504160748484"></p>
<p>每对路由器通过使用<strong>179端口的半永久TCP</strong>连接交换路由选择信息。</p>
<p><strong>使用 TCP 协议交换 BGP 报文</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504155608413.png" alt="image-20220504155608413"></p>
<p><strong>基于策略的路由</strong>，不像内部网关协议，毫无保留的通告，在不同 AS 之间的通告会基于一定的策略，<strong>有多条路径可选择时，也会基于策略进行选择一条</strong>，不一定就以跳数作为标准，还有其他的考虑因素【<code>内部网关协议注重性能，外部网关协议关注策略</code>】</p>
<p>两个重要的属性是AS-PATH和NEXT-HOP。NEXT-HOP是AS-PATH<strong>起始的路由器接口的IP地址。</strong></p>
<h4 id="BGP-路由选择">BGP 路由选择</h4>
<h5 id="1-热土豆路由选择（hot-potato-routing）">1.热土豆路由选择（hot potato routing）</h5>
<p>选择到开始该路由的多个NEXT-HOP路由器中具有最小开销的那条路径。</p>
<p>热土豆的思想：<strong>尽可能快地将分组送出其AS（最低开销）</strong>，而不担心其AS外部到目的地的余下部分的开销。热土豆路由选择是<strong>自私</strong>的算法。<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504163224165.png" alt="image-20220504163224165"></p>
<h5 id="2-路由选择算法">2.路由选择算法</h5>
<p>实践中BGP使用一种比热土豆选择更为复杂的算法，进入BGP路由选择算法的输入是到某前缀的所有路由的集合，如果只有一条这样的路由就选择该路由，<strong>否则依次按照一些消除规则直到剩下一条路由。</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504161212598.png" alt="image-20220504161212598"></p>
<p>因此去往其他 AS 内的可达信息是由内部网关协议【<code>决定通过哪些 interface 放出数据可以到达网关</code>】和外部网关协议【<code>决定怎么到外部子网</code>】一起决定的</p>
<h2 id="5-5-SDN-控制平面">5.5 SDN 控制平面</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504165114192.png" alt="image-20220504165114192"></p>
<p>SDN 控制器：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>网络控制应用界面层</code>：控制器通过**“北向”接口**与网络控制应用程序交互。</p>
</li>
<li class="lvl-2">
<p><code>网络范围状态管理层</code>：网络的主机，链路，交换机和其他SDN控制设备的<strong>最新状态信息，以及各种受控设备的流表。</strong></p>
</li>
<li class="lvl-2">
<p><code>通信层</code>：SDN控制器和受控网络设备之间的<strong>通信</strong>。现在被称为<strong>控制器的“南向”接口</strong>。<strong>OpenFlow</strong>就是一种提供这种功能的特定协议。</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504165445283.png" alt="image-20220504165445283"></p>
<p>采用 TCP 交换报文</p>
<p>3 种类型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>控制器–&gt;分组交换机</p>
</li>
<li class="lvl-2">
<p>控制器&lt;–分组交换机</p>
</li>
<li class="lvl-2">
<p>控制器&lt;–&gt;分组交换机</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504165938040.png" alt="image-20220504165938040"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504170140801.png" alt="image-20220504170140801"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504170244075.png" alt="image-20220504170244075"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504170304691.png" alt="image-20220504170304691"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504170331049.png" alt="image-20220504170331049"></p>
<p>两种控制器 <strong>Open Daylight</strong> 和 <strong>ONOS</strong>。</p>
<h2 id="5-6-ICMP">5.6 ICMP</h2>
<p><em>Internet Control Message Protocol</em> <strong>因特网控制报文协议</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504173920723.png" alt="image-20220504173920723"></p>
<h3 id="差错报告">差错报告</h3>
<p>ICMP <strong>最典型</strong>的用途是<strong>差错报告</strong></p>
<p>例如，当运行一个HTTP会话时，会遇到一些诸如“目的网络不可达”之类的错误报文。这种报文就来源于ICMP。在某个位置，IP路由器不能找到一条通往HTTP请求中所指定的主机的路径，该路由器就会向主机生成并发出一个ICMP报文以指示该错误。</p>
<p><strong>ICMP通常被认为是IP的一部分，但从体系结构上讲它位于IP之上</strong>。当一台主机收到一个指明上层协议为ICMP的IP数据报时（上层协议编码为<strong>1</strong>）,它分解出该数据报的内容给ICMP,就像分解岀一个数据报的内容给TCP或UDP 一样。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220509114924343.png" alt="image-20220509114924343"></p>
<p>ICMP报文有<strong>一个类型字段和一个编码字段</strong>，并且<strong>包含引起该ICMP报文首次生成的 IP 数据报的首部和 ICMP的前8个字节</strong>（以便发送方能确定引发该差错的数据报）。</p>
<p>如下在返回的 11 0 ICMP 报文中包含了引起该 ICMP 报文的源报文的 IP 首部和 ICMP 内容的前 8 B</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220509114508097.png" alt="image-20220509114508097"></p>
<h3 id="ping">ping</h3>
<p>ping程序发送一个ICMP<strong>类型8编码0</strong>的报文到指定主机。目的主机发回一个<strong>类型0编码0</strong>的ICMP回显回答</p>
<h3 id="Traceroute">Traceroute</h3>
<p><strong>利用返回的 ICMP 报文来判断</strong>，通过发送 ping 报文来实现</p>
<p>逐个增加 TTL 发送报文，同时为每个报文设定计时器，当 TTL 减为 0，路由器发送<strong>类型 11 编码 0</strong> 的 TTL 过期差错报告（包含这个路由器的名字和 IP 地址），因此可以得到往返时延。</p>
<p>当到达目标主机时，由于目标主机和 ping 的目标地址相同，因此目标主机会返回类型 0 编码 0 的 ICMP 报文对 ping 进行响应，因此 tracert 就知道已经到达了，无需再发送</p>
<p>（标准的 Traceroute 程序实际上<strong>用相同的TTL发送3 个一组的分组</strong>，因此 Traceroute 输出对每个TTL提供了 3个结果。）</p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220504170703171.png" alt="image-20220504170703171"></p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>需求部分期末复习</title>
    <url>/%E9%9C%80%E6%B1%82%E5%92%8C%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/%E9%9C%80%E6%B1%82%E9%83%A8%E5%88%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="需求部分期末复习">需求部分期末复习</h2>
<blockquote>
<p>参考自 zhy 的博客<a href="https://spricoder.github.io/2021/01/17/2020-Demand-and-business-model-innovation/2020-Demand-and-business-model-innovation-Exam-%E9%9C%80%E6%B1%82/">2020-需求与商业模式分析-Exam-需求 - SpriCoder的博客</a></p>
</blockquote>
<h1>1. 需求工程导论</h1>
<ol>
<li class="lvl-3">
<p>需求工程：</p>
<ol>
<li class="lvl-6"><strong>基本活动：</strong>
<ol>
<li class="lvl-9"><strong>需求获取</strong></li>
<li class="lvl-9"><strong>需求分析</strong>：目标、功能和约束映射为软件行为，建立系统模型</li>
<li class="lvl-9"><strong>需求规约</strong>：以文档的方式固化下来。</li>
<li class="lvl-9"><strong>需求验证</strong>
<ol>
<li class="lvl-12">保证需求及文档的正确性</li>
<li class="lvl-12">通过检查和修正，保持文档的完整性和一致性</li>
<li class="lvl-12">所有涉众一致同意</li>
</ol>
</li>
<li class="lvl-9"><strong>需求管理</strong>：管理建立的基线</li>
</ol>
</li>
</ol>
</li>
</ol>
<span id="more"></span>
<h1>⭐2. 需求类型</h1>
<ol>
<li class="lvl-3">
<p>需求的定义(IEEE)</p>
<ol>
<li class="lvl-6">(用户的观点)用户为了解决问题或达到某些目标所需要的条件或能力。</li>
<li class="lvl-6">(开发者的观点)系统或系统部件为了满足合同、标准、规范或者其他正式文档所规定的要求而需要具备的条件或能力。</li>
<li class="lvl-6">对1或2中的一个条件或一种能力的一种文档化表述。</li>
<li class="lvl-6">注：需求是以用户为中心的，是与问题相联系的；需求要被清晰、明确地写在文档上。</li>
</ol>
</li>
<li class="lvl-3">
<p>需求的<strong>层次性</strong></p>
<ol>
<li class="lvl-6">业务需求：解决方案与系统特性</li>
<li class="lvl-6">用户需求：问题域知识
<ol>
<li class="lvl-9">用户需求是对<strong>任务的期望</strong>，<strong>基本表达方式&quot;xx用户可以使用系统完成xx任务&quot;</strong></li>
</ol>
</li>
<li class="lvl-6">系统级需求：需求分析模型
<ol>
<li class="lvl-9">一般典型表述形式为&quot;<strong>系统可以xxx</strong>&quot;或者&quot;<strong>在xx用户提出xx请求时，系统应该xxx</strong>&quot;。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>需求的<strong>分类</strong></p>
<ol>
<li class="lvl-6">需求
<ol>
<li class="lvl-9"><strong>项目需求</strong>：项目时间、项目成本</li>
<li class="lvl-9"><strong>过程需求</strong>：过程方法、过程文件</li>
<li class="lvl-9"><strong>系统级需求</strong>：系统工程的需求
<ol>
<li class="lvl-12"><strong>软件需求</strong>
<ol>
<li class="lvl-15"><strong>功能需求</strong></li>
<li class="lvl-15"><strong>性能需求</strong>：速度、 容量、吞吐量、负载、实时性等</li>
<li class="lvl-15"><strong>质量需求</strong>：可靠性、可用性、安全性、可维护性、易用性</li>
<li class="lvl-15"><strong>对外接口</strong>：硬件、软件、数据库接口、用户界面、通信接口</li>
<li class="lvl-15"><strong>约束</strong>：限制开发人员设计和构建系统时的选择范围
<ol>
<li class="lvl-18"><strong>系统开发及运行的环境</strong></li>
<li class="lvl-18"><strong>问题域标准</strong>：法律法规等</li>
<li class="lvl-18"><strong>商业规则</strong></li>
<li class="lvl-18"><strong>社会性因素</strong></li>
</ol>
</li>
<li class="lvl-15"><strong>其他需求</strong>：安装需求、培训需求、数据需求(功能需求没有描述的补充)</li>
</ol>
</li>
<li class="lvl-12"><strong>硬件需求</strong>：服务器规格</li>
<li class="lvl-12"><strong>其他需求</strong>：人力资源(系统投入使用时，需要对用户进行1个星期的集中培训)、协同需求</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">不切实际的期望：不可行，做不到</li>
</ol>
</li>
</ol>
<h1>3. 需求工程过程</h1>
<ol>
<li class="lvl-3">
<p>常见的文档</p>
<ol>
<li class="lvl-6">项目前景和范围文档</li>
<li class="lvl-6">用户需求文档</li>
<li class="lvl-6">需求规格说明文档
<ol>
<li class="lvl-9">系统规格说明</li>
<li class="lvl-9">软件规格说明</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>过程活动</p>
<ol>
<li class="lvl-6">需求获取：从<strong>人、资料或者环境</strong>当中获取需求的过程
<ol>
<li class="lvl-9">收集背景资料</li>
<li class="lvl-9">获取问题与目标，定义项目前景和范围</li>
<li class="lvl-9">识别涉众
<ol>
<li class="lvl-12">涉众分析</li>
</ol>
</li>
<li class="lvl-9">选择获取方法、执行获取
<ol>
<li class="lvl-12">面谈</li>
<li class="lvl-12">观察</li>
<li class="lvl-12">原型</li>
</ol>
</li>
<li class="lvl-9">记录获取结果</li>
</ol>
</li>
<li class="lvl-6">需求分析：主要工作：<strong>建模来整合各种知识，以帮助人们更好地理解问题：信息的细化、为创造性活动提供支撑，完成内容的转化</strong>。最后<strong>产生需求的基线集</strong>。指定系统开发需要完成的任务。</li>
<li class="lvl-6">需求规格说明</li>
<li class="lvl-6">需求验证，标准：需求正确，反应用户的意图、完整性和一致性、可读性和可修改性。</li>
<li class="lvl-6">需求管理：保证需求作用在整个软件的<strong>产品生命周期</strong>中的<strong>持续、稳定和有效发挥</strong>
<ol>
<li class="lvl-9">维护需求基线</li>
<li class="lvl-9">实现需求跟踪：前向跟踪和后向跟踪</li>
<li class="lvl-9">进行变更控制</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>4. 需求获取：</h1>
<p><strong>总结：</strong></p>
<ol>
<li class="lvl-3">
<p>需求获取前半段</p>
<ol>
<li class="lvl-6">确定项目的前景与范围：问题分析-目标分析-业务过程分析</li>
<li class="lvl-6">涉众分析：涉众识别-涉众描述-涉众评估-涉众代表选择-参与策略</li>
</ol>
</li>
<li class="lvl-3">
<p>需求获取后半段</p>
<ol>
<li class="lvl-6">基于用例/场景展开用户需求获取</li>
<li class="lvl-6">用户需求获取手段
<ol>
<li class="lvl-9">面谈</li>
<li class="lvl-9">原型：抛弃式与演化式，控制成本，应对模糊与变更</li>
<li class="lvl-9">观察：采样观察与民族志，应对复杂协同</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>⭐5. 确定项目的前景和范围</h1>
<ol>
<li class="lvl-3">
<p>为什么要确定项目的前景和范围</p>
<ol>
<li class="lvl-6">保证项目涉众以符合项目需要的角度描述现实世界：项目的目标就是业务需求</li>
<li class="lvl-6"><strong>前景</strong>描述产品用来干什么，将所有的涉众都统一到一个方向，<strong>所有的涉众都从共同认同的项目前景出发，理解和描述问题域及需求。</strong></li>
<li class="lvl-6"><strong>范围</strong>指出了当前项目是要解决的<strong>产品长远规划中的哪一部分</strong>，限定了<strong>需求的界限</strong>，<strong>范围内的事物和事件是描述的目标</strong>。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/2.png" alt=""></p>
</li>
<li class="lvl-3">
<p>不同的业务需求之间存在冲突，则在确定项目前景和范围阶段必须予以解决。对于零售机问题中的矛盾</p>
<ol>
<li class="lvl-6">开发者重视技术</li>
<li class="lvl-6">零售商要求简单直接投入使用</li>
<li class="lvl-6">用户希望便捷和功能性</li>
</ol>
</li>
<li class="lvl-3">
<p>分析过程的深入：<strong>问题分析、目标分析、业务过程分析</strong></p>
</li>
<li class="lvl-3">
<p>还需要分析<strong>非功能需求</strong>，定义<strong>系统边界</strong>，生成<strong>前景与范围文档</strong></p>
</li>
</ol>
<h2 id="5-1-问题分析">5.1. 问题分析</h2>
<h2 id="🌟-5-2-目标分析">🌟 5.2. 目标分析</h2>
<ol>
<li class="lvl-3">
<p>目标：<strong>系统被开发的目的</strong></p>
<p>目标描述<strong>示例：</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230215205819193.png" alt="image-20230215205819193"></p>
</li>
<li class="lvl-3">
<p>时序逻辑的常用操作符：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/20.png" alt=""></p>
</li>
<li class="lvl-3">
<p>目标的描述包括</p>
<ol>
<li class="lvl-6"><strong>目标的分类</strong>
<ol>
<li class="lvl-9">功能目标：期望系统提供的服务
<ol>
<li class="lvl-12">满足型目标(<strong>Satisfaction Goal</strong>)：对行为者的满足</li>
<li class="lvl-12">信息型目标(<strong>Information Goal</strong>)：对行为者的信息告知</li>
</ol>
</li>
<li class="lvl-9">非功能目标：期望系统满足的质量，常见的是质量目标(<strong>Quality goals</strong>)和约束目标(<strong>Constraint goals</strong>)、安全目标(<strong>Safety Goal</strong>)、性能目标(<strong>Performance Goal</strong>)、可用性目标(<strong>Usability Goal</strong>)等等</li>
<li class="lvl-9">软目标：无法清晰判断是否可以满足的目标，可维护性，<strong>云朵表示</strong></li>
<li class="lvl-9">硬目标：可以清晰确认是否满足的目标，性能指标，<strong>矩形表示</strong></li>
</ol>
</li>
<li class="lvl-6"><strong>非正式定义</strong></li>
<li class="lvl-6"><strong>关注</strong></li>
<li class="lvl-6"><strong>正式定义</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>目标的主体：主体是环境中的主动部分。</p>
<ol>
<li class="lvl-6">如果主体只有软件，那么目标就是需求</li>
<li class="lvl-6">如果主题只有系统环境的一个对象，那么目标就是假设与依赖</li>
<li class="lvl-6">区分主体与拥有者：拥有者一般是涉众，拥有者不一定参与目标达成过程。</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>目标的基本模式：实现、终止、保持、避免和优化</strong></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>符号描述</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现(Achieve)</td>
<td>$P \Rightarrow \Diamond Q$</td>
<td>如果将来某一时刻Q为真(被满足)，则目标实现</td>
</tr>
<tr>
<td>终止(Cease)</td>
<td>$P \Rightarrow \Diamond \neg Q$</td>
<td>如果将来某一时刻Q为假(被终止)，则目标实现</td>
</tr>
<tr>
<td>保持(Maintain)</td>
<td>$P \Rightarrow \Box Q$</td>
<td>将来任一时刻Q都为真，则目标实现</td>
</tr>
<tr>
<td>避免(Avoid)</td>
<td>$P \Rightarrow \Box \neg Q$</td>
<td>将来任一时刻Q都为假，则目标实现</td>
</tr>
<tr>
<td>优化(Optimize)-min/max</td>
<td>-</td>
<td>最大化Max(目标功能) 或 最小化Min (目标功能)</td>
</tr>
</tbody>
</table>
</li>
<li class="lvl-3">
<p>目标模型元素之间的关系的关系</p>
<ol>
<li class="lvl-6">
<p><strong>精化</strong></p>
<ol>
<li class="lvl-9">AND精化：子目标完成保证父目标完成，<strong>合并</strong>画<strong>实心圆</strong></li>
<li class="lvl-9">OR精化：子目标之间是可以<strong>相互替代</strong>的，<strong>分开</strong>画<strong>空心圆</strong></li>
</ol>
<blockquote>
<p>一个高层次目标G可以精化为低层次目标{G1,G2,…,Gn}：目标精化是目标模型的重要任务之一</p>
<p>精化的结束条件：</p>
<p>子目标展开到<strong>单一事务</strong>时终止</p>
<ul class="lvl-5">
<li class="lvl-2">
<p>事务指的是用户与系统的一次协作活动，要求全部成功或全部失败。确认这些单一事务能够增加业务价值</p>
</li>
</ul>
</blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/21.png" alt=""></p>
</li>
<li class="lvl-6">
<p><strong>阻碍</strong>：子目标达成会导致父目标失败，允许继续被精化为低层次目标(AND/OR)</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/22.png" alt=""></p>
</li>
<li class="lvl-6">
<p><strong>支持与冲突</strong>【非父子目标之间的关系】</p>
<ol>
<li class="lvl-9">支持：某一个目标达成会支持促进其他目标(可以被处理为OR关系)</li>
<li class="lvl-9">冲突：某一个目标对于其他目标的实现有阻碍作用</li>
<li class="lvl-9">通常会通过文字+符号表示
<ol>
<li class="lvl-12"><code>++</code> 保证</li>
<li class="lvl-12"><code>+ </code> 更容易</li>
<li class="lvl-12"><code>- </code> 更困难</li>
<li class="lvl-12"><code>--</code> 导致失败</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>目标与主体：Assignment链接表示为实现目标而需要<strong>主体</strong>参与。<strong>六边形且没有箭头</strong></p>
<ol>
<li class="lvl-6">OR关系：多个主体中一个完成</li>
<li class="lvl-6">AND关系：多个关系中已通过完成</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/24.png" alt=""></p>
</li>
<li class="lvl-3">
<p>目标与操作：操作也可以OR和AND精化，<strong>圆角矩形且没有箭头</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/25.png" alt=""></p>
</li>
<li class="lvl-3">
<p>目标分析过程</p>
<ul class="lvl-2">
<li class="lvl-5">面向目标方法
<ol>
<li class="lvl-8">高层目标的获取：现状和背景的分析：<strong>画布、评估</strong></li>
<li class="lvl-8">低层目标的获取</li>
<li class="lvl-8">目标分析
<ol>
<li class="lvl-11">精化与分解（建立目标模型）</li>
</ol>
</li>
<li class="lvl-8">目标实现</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>例子</strong></p>
<blockquote>
<p>对于各个建立目标模型的事项中，都要坚持对高层目标问&quot;怎么实现(How)“，对低层目标问&quot;为什么需要(why)”，来实现层次结构。</p>
</blockquote>
<ol>
<li class="lvl-7">
<p><strong>案例</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230215213644772.png" alt="image-20230215213644772"></p>
</li>
<li class="lvl-7">
<p><strong>获取高层目标</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230215213655045.png" alt="image-20230215213655045"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230215213735885.png" alt="image-20230215213735885"></p>
</li>
<li class="lvl-7">
<p><strong>目标精化（AND 精化和 OR 精化）</strong></p>
<blockquote>
<p>建议尤其要注重对<strong>信息持有情况的获取</strong>,如存储、加工和输出数据信息,因为这很常见，意味着相应Maintain目标的存在。看到高层目标&quot;减少缺货、积压与报废&quot;的描述信息时,可以发现<strong>需要持有库存数据</strong></p>
</blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book5/36.png" alt=""></p>
</li>
<li class="lvl-7">
<p><strong>发现阻碍，支持和冲突</strong></p>
<blockquote>
<p>要注意发现冲突关系。<strong>尤其要关注不同视点( view)之间的冲突</strong>以及正式定义之间相矛盾的冲突。例如&quot;减少人员&quot;与&quot;销售更多商品&quot;两个目标就是不同视点之间的冲突</p>
</blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/1.png" alt=""></p>
</li>
</ol>
</li>
<li class="lvl-4">
<p><strong>目标实现</strong></p>
<ol>
<li class="lvl-7">
<p>将<strong>最底层目标分配给主体（人+系统）</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230215214748314.png" alt="image-20230215214748314"></p>
</li>
<li class="lvl-7">
<p>设计<strong>实现最底层目标的操作</strong></p>
<p><img src="C:%5CUsers%5Cwbl%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230215214823316.png" alt="image-20230215214823316"></p>
</li>
</ol>
</li>
</ol>
<h2 id="5-3-基于目标模型获取非功能需求">5.3. 基于目标模型获取非功能需求</h2>
<h2 id="5-4-活动图">5.4. 活动图</h2>
<h2 id="5-5-定义系统边界">5.5. 定义系统边界</h2>
<h2 id="5-6-前景和范围文档">5.6. 前景和范围文档</h2>
<h1>6. 涉众分析与硬采样</h1>
<ol>
<li class="lvl-3">
<p>涉众：所有能够影响软件系统的<strong>实现</strong>(系统决策者、开发者、利益所在者)或者会被实现后的<strong>软件系统所影响</strong>的(已有产品更新、全新产品开发)<strong>关键</strong>个人和团体(stakeholder)。</p>
</li>
<li class="lvl-3">
<p>涉众分析过程：</p>
<ol>
<li class="lvl-6">
<p><strong>涉众识别</strong>:寻找软件系统的涉众类别。</p>
</li>
<li class="lvl-6">
<p>涉众描述:</p>
<ol>
<li class="lvl-9">描述不同涉众类别的<strong>简单</strong>特征和<strong>复杂</strong>特征</li>
</ol>
</li>
<li class="lvl-6">
<p><strong>涉众评估:</strong></p>
<ol>
<li class="lvl-9">为<strong>涉众类别划分优先级</strong>。</li>
<li class="lvl-9">评估不同涉众类别的<strong>风险</strong>，化解风险。</li>
<li class="lvl-9"><strong>分析涉众冲突,实现共赢</strong>。</li>
</ol>
</li>
<li class="lvl-6">
<p>涉众代表选择:从每种涉众类别中选择代表。</p>
</li>
<li class="lvl-6">
<p>制定涉众代表参与需求开发乃至软件系统的参与策略。</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book6/1.png" alt=""></p>
</li>
</ol>
<h2 id="6-1-涉众识别">6.1. 涉众识别</h2>
<ol>
<li class="lvl-3">
<p>基本原则</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>涉众需要细分</p>
<ul class="lvl-4">
<li class="lvl-7">每一类涉众要<strong>稳定的从相同立场、视角来看待相同的系统</strong></li>
</ul>
</li>
<li class="lvl-5">
<p>发现<strong>关键涉众(影响关乎软件系统成败)</strong></p>
<ul class="lvl-4">
<li class="lvl-7">需要分析他们各自的赢利条件，以在<strong>相互妥协</strong>中尽力实现一个<strong>共赢</strong>的结局，最简单的区分特征是<strong>任务</strong>。</li>
<li class="lvl-7">如果互动及其关注点<strong>属于项目的目标与范围</strong>，并且其影响关乎软件系统成败和实现，那么涉众就属于<strong>关键涉众</strong></li>
</ul>
</li>
<li class="lvl-5">
<p>涉众群体需要持续维护和关注</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>识别方法</p>
<ol>
<li class="lvl-6">
<p><strong>简单方法</strong>：<strong>先膨胀后收缩</strong>：根据收集到的背景资料尽可能多的列举，然后尽可能的合并涉众。</p>
</li>
<li class="lvl-6">
<p><strong>经验方法：检查列表</strong></p>
<ol>
<li class="lvl-9">用户：关注软件功能</li>
<li class="lvl-9">客户：成本、效益(用户替代源)</li>
<li class="lvl-9">开发者：实现软件系统</li>
<li class="lvl-9">管理者：关注系统开发进程</li>
<li class="lvl-9">领域专家：关注软件中的知识</li>
<li class="lvl-9">政府力量：法律法规、长远规划等；约束和指导</li>
<li class="lvl-9">市场力量(用户替代源)</li>
<li class="lvl-9">维护人员：关心系统的非功能性属性</li>
</ol>
<p>优点：容易操作；缺点：有的类别太粗如用户类别</p>
</li>
<li class="lvl-6">
<p><strong>经典方法：涉众网络</strong></p>
<ol>
<li class="lvl-9">涉众：节点，互动：边</li>
<li class="lvl-9">从容易发现的涉众出发(涉众基线，如客户等)</li>
<li class="lvl-9">头脑风暴</li>
<li class="lvl-9">对得到的涉众列表分析相关性，分析时要将其与软件系统联系起来，这个网络包含了涉众与软件系统之间的交互以及涉众之间的交互，确定各个涉众类别和软件系统的相关性、关键性，最后缩减成一个涉众列表。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="🌟主体依赖模型ADM-Actor-Dependency-Model-——分析涉众互动，识别关键涉众类别">🌟主体依赖模型ADM(Actor Dependency Model)——分析涉众互动，识别关键涉众类别</h3>
<p>箭头由<strong>依赖者指向被依赖者</strong></p>
<ol>
<li class="lvl-3">
<p>目标依赖(goal dependency)：依赖者希望被依赖者满足<strong>一个条件</strong>，但不会规定<strong>怎样</strong>满足该条件。</p>
</li>
<li class="lvl-3">
<p>软目标依赖(soft goal dependency)：一种特殊类型的目标依赖，其条件是<strong>无法量化</strong>描述的。</p>
</li>
<li class="lvl-3">
<p>任务依赖(task dependency)：依赖者希望<strong>被依赖者</strong>执行特定任务。任务依赖比目标依赖<strong>更加具体</strong>，因为满足条件可以<strong>执行很多任务</strong>，被依赖者有自己的选择权。而任务依赖直接为被依赖者规定了任务。</p>
</li>
<li class="lvl-3">
<p>资源依赖(resource dependency)：依赖者希望被依赖者提供<strong>资源实体</strong>(抽象信息或者实物材料)为自己所用，但不关注提供资源需要被依赖者执行的行为和解决的问题。</p>
</li>
<li class="lvl-3">
<p><strong>完备描述涉众之间的互动，了解涉众的社会互动性</strong>。</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/5.png" alt=""></p>
<h3 id="例子：B站的涉众分析">例子：B站的涉众分析</h3>
<ol>
<li class="lvl-3">
<p>一般Up主与观众：目标是流畅、有趣的<strong>视频观看</strong>，任务是为平台带来<strong>流量和关注度</strong>，占用大量带宽和审核资源，被补贴</p>
</li>
<li class="lvl-3">
<p>&quot;二次元&quot;核心Up主与观众：目标是<strong>垂直、核心的动漫内容消费</strong>，任务是为平台带来<strong>收益和核心社区</strong>，强力的粘性消费补贴平台其他用户</p>
</li>
<li class="lvl-3">
<p>前者追求流畅视频体验(软目标)、占带宽多(资源)，产品粘性与消费能力较弱(任务)；后者则相反(高粘性游戏运营，主要收入)</p>
<ol>
<li class="lvl-6">后者在事实上补贴前者</li>
<li class="lvl-6">B站策略 <strong>两大类涉众并存</strong>：大会员+社区+电商 VS 宅向内容与营销</li>
</ol>
</li>
</ol>
<h2 id="6-2-涉众描述">6.2. 涉众描述</h2>
<p>需要描述<strong>涉众对系统的影响，对项目的期望即目标，主要关注点，对项目的态度</strong></p>
<h2 id="🌟6-3-涉众评估">🌟6.3. 涉众评估</h2>
<ol>
<li class="lvl-3">
<p>为涉众类别划分优先级：尤其是<strong>任务特征，使用功能越多、越频繁、越大规模的用户群体优先级越高。</strong></p>
</li>
<li class="lvl-3">
<p>涉众优先级评估：🌟<strong>Power-interest图</strong></p>
<ol>
<li class="lvl-6">参与者：系统的实际使用者，对系统也有较大影响力，优先级最高。</li>
<li class="lvl-6">环境设定者：很少使用系统，但是由于政治、经济等因素对系统有比较大的影响，优先级次之，最常见的是政府和管理者。</li>
<li class="lvl-6">被影响者：可能是系统直接使用者，也可能是因为系统出现被剥夺了部分利益的输家，受影响大，能影响的少，优先级一般低于环境设定者，但是特殊情况下也可能高于环境设定者。</li>
<li class="lvl-6">观众：不受影响，也不影响，优先级最低，比如环境专家和市场力量。</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/2.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>不同涉众类别的风险:Power/Attitude图</p>
<ol>
<li class="lvl-6">强反对者是需要重点分析的。</li>
<li class="lvl-6">涉众的关注点和兴趣去向也是重要内容，一般环境设定者是项目高风险因素。</li>
<li class="lvl-6">对于高风险的涉众类别，要尽可能澄清各个涉众类别的角色和职责，发现项目对他们的依赖和假设条件，分析实际情况与预期不一致时可能出现的风险，并提前化解。</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/3.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>化解涉众风险</p>
<ol>
<li class="lvl-6">一方面提高环境设定者对系统的关注，转化为参与者</li>
<li class="lvl-6">一方面消除强反对者的反对原因，变为强支持者</li>
<li class="lvl-6"><strong>给予被影响者一些发表和实现自身意见的权利。</strong></li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/4.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>分析涉众冲突，🌟<strong>共赢分析</strong></p>
<ol>
<li class="lvl-6">发现冲突：<strong>Stakeholder/Issue关系图</strong>
<ol>
<li class="lvl-9">列出所有涉众类别：描述兴趣和对系统的期望</li>
<li class="lvl-9">从兴趣和期望中发现背后的共同问题</li>
<li class="lvl-9"><strong>建立涉众类别与问题的关联</strong>，如果某个涉众类别对Issue感兴趣，则这个涉众类别和Issue存在关联关系。</li>
<li class="lvl-9">对每一个Stakeholder-Issue关系，表明关系上被寄予的期望。
<ol>
<li class="lvl-12">如果期望和项目的业务需求冲突，则调整和折中，重新评估项目可行性</li>
<li class="lvl-12">如果Issue关联的不同关系标识有互相冲突期望，则意味涉众在Issue上有需求冲突，分析同时成为项目赢家的条件，分析目标、约束等给冲突方进行权衡。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">免费与订阅模式的共赢：分拆，免费引流、IP与著作权管控</li>
</ol>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230216154058359.png" alt="image-20230216154058359"></p>
<h2 id="6-4-涉众代表选择：从每种涉众中该选择代表">6.4. 涉众代表选择：从每种涉众中该选择代表</h2>
<ol>
<li class="lvl-3">
<p>完整采样</p>
</li>
<li class="lvl-3">
<p>态度积极</p>
</li>
<li class="lvl-3">
<p>数量适中(6-10)</p>
</li>
<li class="lvl-3">
<p>比例恰当</p>
</li>
<li class="lvl-3">
<p>如果找不到涉众类别代表，可以使用用户替代源：<strong>因为业务关系而和用户频繁接触的人</strong> ，能够代替他们发表看法</p>
</li>
</ol>
<h2 id="6-5-制定涉众代表参与需求开发乃至软件系统的参与策略">6.5. 制定涉众代表参与需求开发乃至软件系统的参与策略</h2>
<ol>
<li class="lvl-3">
<p>让代表们在合适的时间参与合适的工作</p>
</li>
<li class="lvl-3">
<p>使用敏捷方法，建立起和<strong>用户的直接联系</strong>，用户参与软件系统开发的全过程</p>
<ol>
<li class="lvl-6">为其设计</li>
<li class="lvl-6">与其设计</li>
<li class="lvl-6">由其设计</li>
</ol>
</li>
</ol>
<h2 id="6-6-利用目标模型进行涉众分析">6.6. 利用目标模型进行涉众分析</h2>
<h2 id="6-9-硬采样">6.9. 硬采样</h2>
<h1>7. 基于用例/场景模型展开用户需求获取</h1>
<p><mark>用户知道所有事情，用<strong>面谈</strong>；用户有不确定的需求，用<strong>原型</strong>；某些场景用户不知道或不能主动告知，用<strong>观察</strong></mark></p>
<p><strong>场景与用例</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>场景</strong>：具有重点描述真实世界的特征，利用情景、行为者之间的交互、事件随时间的演化等方式来叙述性的描述系统的使用</p>
</li>
<li class="lvl-2">
<p><strong>用例</strong>：在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务</p>
</li>
<li class="lvl-2">
<p>商业模式中的场景一般需要多个用例来支撑</p>
</li>
<li class="lvl-2">
<p>将前景、范围以及涉众分析得到的结果不断的填入场景与用例之中</p>
</li>
</ul>
<h1>🌟8. 面谈</h1>
<ol>
<li class="lvl-3">
<p>准备面谈</p>
<ol>
<li class="lvl-6">准备工作</li>
<li class="lvl-6">面谈准备的关键：<strong>问题类型</strong>
<ol>
<li class="lvl-9"><strong>开放式问题</strong>
<ol>
<li class="lvl-12">答复的选择可以是<strong>开放和不受限制</strong>的。</li>
<li class="lvl-12">感到自在、丰富细节、让被会见者更感兴趣、启迪</li>
<li class="lvl-12">失控、看上去没有准备、细节过多</li>
</ol>
</li>
<li class="lvl-9"><strong>封闭式问题</strong>
<ol>
<li class="lvl-12">节省时间、切中要点、控制、确切</li>
<li class="lvl-12">厌烦、细节时候、不能建立友好关系</li>
</ol>
</li>
<li class="lvl-9">探究式问题</li>
<li class="lvl-9">诱导式问题</li>
<li class="lvl-9">双筒问题</li>
<li class="lvl-9">元问题：我的问题看起来相关吗等</li>
</ol>
</li>
<li class="lvl-6">问题准备
<ol>
<li class="lvl-9">分析基本的涉众特点：角色、任务、个人目标、频率、优先级</li>
<li class="lvl-9"><strong>前期开放性问题，后期封闭性问题</strong></li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>主持面谈</p>
</li>
<li class="lvl-3">
<p>处理面谈结果</p>
</li>
<li class="lvl-3">
<p>面谈类型</p>
<ol>
<li class="lvl-6">结构化面谈：安全按照事先的问题和结构来控制面谈</li>
<li class="lvl-6">半结构化面谈：事先需要根据面谈内容准备面谈的问题和面谈结构，问题在面谈过程中调整</li>
<li class="lvl-6">非结构化面谈：没有事先预定的议程安排、问题</li>
</ol>
</li>
<li class="lvl-3">
<p>面谈优点和缺点：</p>
<ol>
<li class="lvl-6">
<p>优点：</p>
<ol>
<li class="lvl-9">面谈的<strong>开展条件</strong>较为简单</li>
<li class="lvl-9">能获得广泛内容</li>
<li class="lvl-9">建立相互之间的<strong>友好关系</strong></li>
<li class="lvl-9">通过参与面谈，被会见者会产生一种主动为项目<strong>做出贡献</strong>的感觉，提高涉众的项目<strong>参与热情</strong></li>
</ol>
</li>
<li class="lvl-6">
<p>缺点：</p>
<ol>
<li class="lvl-9">面谈比较<strong>耗时</strong></li>
<li class="lvl-9">在被会见者<strong>地理分散</strong>的情况下往往难以实现面谈</li>
<li class="lvl-9">面谈参与者的<strong>记忆和交流能力</strong>对结果影响较大，尤其是面谈的成功较高的依赖于需求工程师的人际交流能力</li>
<li class="lvl-9">在会见者不了解被会见者<strong>认知结构</strong>的情况下，面谈不可能取得令人满意的效果</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>其他相关方法：</p>
<ol>
<li class="lvl-6">群体面谈</li>
<li class="lvl-6">调查问卷：<strong>依然是一种面谈方法</strong>，面谈方法以<strong>口头语言</strong>为主要的交流媒介，而调查问卷以<strong>文档</strong>为主要的交流媒介</li>
<li class="lvl-6">头脑风暴：目的不是发现需求，而是<strong>发明需求</strong>，或者说是发现<strong>潜在</strong>需求</li>
</ol>
</li>
</ol>
<h1>9. 原型</h1>
<ol>
<li class="lvl-3">
<p>为什么要使用<strong>原型</strong>：解决不确定性</p>
</li>
<li class="lvl-3">
<p><strong>定义</strong>：原型是一个系统，它<strong>内化了</strong>(capture)一个<strong>更迟系统(<strong>later system)的</strong>本质特征</strong>。原型系统通常被构造为不完整的系统，以在将来进行改进、补充或者替代。</p>
<ol>
<li class="lvl-6">如果在最终的物件(final artifact)产生之前，一个中间物件(mediate artifact)被用来在一定广度和深度范围内表现这个最终物件，那么这个中间物件就被认为是最终物件在<strong>该广度和深度上的原型</strong>。</li>
</ol>
</li>
<li class="lvl-3">
<p>软件工程中的原型：</p>
<ol>
<li class="lvl-6"><strong>演示原型</strong>：目的是让用户相信应用系统的开发是<strong>可行</strong>的</li>
<li class="lvl-6"><strong>严格意义上的原型</strong>：主要被用在<strong>分析需求</strong>阶段，探索和解决需求的不确定性。</li>
<li class="lvl-6"><strong>试验原型</strong>：主要被用在<strong>构建系统</strong>阶段，探索和解决解决方案的不确定性</li>
<li class="lvl-6"><strong>引示系统原型</strong>：用作最终系统的<strong>构建核心</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>原型方法过程</p>
<ol>
<li class="lvl-6"><strong>确定原型需求</strong></li>
<li class="lvl-6"><strong>原型开发</strong>：低成本、易修改</li>
<li class="lvl-6"><strong>原型评估</strong>：无偏见环境、是否一致、评估者反应建议、创新思想</li>
<li class="lvl-6"><strong>原型修正</strong></li>
</ol>
</li>
<li class="lvl-3">
<p><strong>抛弃式原型</strong>：</p>
<ol>
<li class="lvl-6">
<p>探索式原型</p>
<ol>
<li class="lvl-9">演示原型</li>
<li class="lvl-9">严格意义上的原型</li>
</ol>
</li>
<li class="lvl-6">
<p>实验式原型</p>
<ol>
<li class="lvl-9">试验原型</li>
</ol>
</li>
</ol>
<p><strong>演化式原型</strong>：</p>
<ol>
<li class="lvl-6">
<p>引示系统的原型</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p>使用要点</p>
<ol>
<li class="lvl-6">
<p><strong>坚决抛弃抛弃式原型</strong></p>
</li>
<li class="lvl-6">
<p><strong>控制原型成本：</strong></p>
<ol>
<li class="lvl-9">水平和垂直两个方向：<strong>用尽可能低的成本开发水平原型</strong>
<ol>
<li class="lvl-12">水平原型：它仅仅实现选定功能所有层次中的某些<strong>特定层次</strong></li>
<li class="lvl-12">垂直原型：它会触及到选定功能实现的<strong>所有层次</strong></li>
</ol>
</li>
<li class="lvl-9">使用简单介质</li>
</ol>
</li>
<li class="lvl-6">
<p><strong>善用故事板原型</strong></p>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book9/5.png" style="zoom: 25%;" />
<ol>
<li class="lvl-9">
<p>who what how</p>
</li>
<li class="lvl-9">
<p>被动式【连环画】、主动式【漫画】、交互式【网页】</p>
</li>
</ol>
</li>
<li class="lvl-6">
<p><strong>控制原型法风险</strong></p>
<ol>
<li class="lvl-9">避免成本失控</li>
<li class="lvl-9">避免给用户错误印象(已经完成)</li>
<li class="lvl-9">注意非功能需求</li>
<li class="lvl-9">注意用户假设</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>10. 观察和文档审查</h1>
<h2 id="10-1-观察">10.1. 观察</h2>
<ol>
<li class="lvl-3">
<p>应用于用户<strong>无法完成主动的信息告知</strong>的情况下</p>
<ol>
<li class="lvl-6"><strong>采样观察</strong>(Sampling Observation)：传统且简单，对特定时间段或特定事件进行观察。
<ol>
<li class="lvl-9">最简单</li>
<li class="lvl-9"><strong>时间采样</strong>：不同时间间隔来观察用户</li>
<li class="lvl-9"><strong>事件采样</strong>：不同事件维度来观察用户，获取默认知识</li>
</ol>
</li>
<li class="lvl-6"><strong>民族志</strong>(Ethnography)：<strong>观察者深入用户较长时间</strong>
<ol>
<li class="lvl-9">民族志要求人类学家花费长期的时间在被研究的社会中生活并且仔细观察该社会中的实际活动，得到第一手的观察数据。</li>
<li class="lvl-9">典型示例是复杂的协同问题，这些问题往往具有一定的社会性、突现的情景性。</li>
<li class="lvl-9">优点：可以深度理解信息，可以让真实世界的社会性因素可见化、打破人们已有的错误假设和观念</li>
<li class="lvl-9">缺点：耗时、数据量大难以传递到开发环境</li>
<li class="lvl-9">针对复杂协同问题的民族志
<ol>
<li class="lvl-12">工作的分布式协同：人们的工作协同、注意硬数据、观察如何协同、分工职责、对他人评价等等。</li>
<li class="lvl-12">工作的计划和程序：细节步骤和过程，集成满足整个工作的要求，发现实际和文档化程序的偏离。核心是<strong>计划和程序</strong></li>
<li class="lvl-12">工作的意识：指活动的某种组织方式，活动对协同的其他人可见和可以被理解，比如个人空间布局、个人对他人的监控、如何保证自己工作可见。</li>
</ol>
</li>
<li class="lvl-9">规则：
<ol>
<li class="lvl-12">定期记录发现</li>
<li class="lvl-12">尽快记录过程中面谈</li>
<li class="lvl-12">定期的复查和更新自己想法</li>
<li class="lvl-12">确定管理海量数据的策略</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6"><strong>话语分析</strong>(Discourse Analysis)：对用户交谈行为观察，观察和分析交互方式或特定话语分析</li>
<li class="lvl-6"><strong>协议分析</strong>(Protocol Analysis)：对用户任务的观察，一边观察对象一边执行任务</li>
<li class="lvl-6"><strong>任务分析</strong>(Task Analysis)：对人机交互行为进行的观察，引入相关的模型方法来观察、记录和执行用户与软件系统的交互行为。</li>
</ol>
</li>
<li class="lvl-3">
<p>情景性：</p>
<ol>
<li class="lvl-6">突现(Emergent)：事件由集体促成，在互动中突现，不要局限于个人视角</li>
<li class="lvl-6">局部(Local)：特定的上下文环境，脱离上下文可能无法形成准确的理解</li>
<li class="lvl-6">暂时(Contingent)：演进过程中的一刻，事件及其解释依赖于当前的情况</li>
<li class="lvl-6">涉身(Embodied)：需要了解参与者的认知和能力是受限的</li>
<li class="lvl-6">开放(Open)：业务不确定并开放，以后完善</li>
<li class="lvl-6">模糊(Vague)：事件的解释不会特别详细，基于潜在知识，尚未明确表达，需求工程师难以理解。</li>
</ol>
</li>
<li class="lvl-3">
<p>观察关注问题的上下文环境，也就是社会因素，包括组织的文化、组织的结构、用户的工作环境、用户的工作实践、法律与政策约束等。</p>
</li>
</ol>
<h2 id="10-2-文档审查">10.2. 文档审查</h2>
<table>
<thead>
<tr>
<th style="text-align:left">文档类型</th>
<th style="text-align:left">文档审查方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">相关产品的需求规格说明</td>
<td style="text-align:left">需求重用</td>
<td style="text-align:left">分析相关产品的规格说明，<strong>发现可以移植到到新产品中的需求信息，进行需求的重用</strong> 1. 问题域信息  2. 用户界面特征  3. 业务需求、组织策略、政策法规</td>
</tr>
<tr>
<td style="text-align:left">硬数据</td>
<td style="text-align:left">文档分析</td>
<td style="text-align:left">阅读、研究得到的硬数据，从中发现需求信息  1.问题域信息  2.工作流程  3.业务细节</td>
</tr>
<tr>
<td style="text-align:left">客户的需求文档</td>
<td style="text-align:left">需求剥离</td>
<td style="text-align:left">抽取客户的需求文档中的需求描述 ，粗粒度需求</td>
</tr>
</tbody>
</table>
<p>硬数据：</p>
<ol>
<li class="lvl-3">
<p>定量硬数据：数据收集表格、统计报表</p>
</li>
<li class="lvl-3">
<p>定性硬数据：组织描述文档，业务指导文档如工作指南和规章手册</p>
</li>
</ol>
<h1>11. 需求分析概述</h1>
<p>包括面向过程建模、数据建模和面向对象建模</p>
<h2 id="11-1-根本任务">11.1. 根本任务</h2>
<ol>
<li class="lvl-3">
<p><strong>建立分析模型</strong>，达成开发者和用户对需求信息的<strong>共同理解</strong>：确定本质特征，获取某个可以转换为知识的事物信息，即<strong>建模——建立需求分析模型</strong>。</p>
</li>
<li class="lvl-3">
<p><strong>建立解决方案</strong>：依据共同理解，发挥<strong>创造性</strong>，创建软件系统解决方案</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230216213720288.png" alt="image-20230216213720288"></p>
<h2 id="11-2-建模">11.2. 建模</h2>
<ol>
<li class="lvl-3">
<p>抽象</p>
</li>
<li class="lvl-3">
<p>分解</p>
</li>
<li class="lvl-3">
<p>投影</p>
</li>
</ol>
<h2 id="11-3-两个世界与三种模型">11.3. 两个世界与三种模型</h2>
<ol>
<li class="lvl-3">
<p>计算世界与计算模型</p>
<ol>
<li class="lvl-6">使用<strong>软件的构成单位</strong>作为模型的组元</li>
<li class="lvl-6"><strong>软件构建单位之间的关系</strong>作为模型组元之间的关系</li>
<li class="lvl-6">计算模型：使用的组元和组元间关系都是软件的元素，是来自软件(计算世界)的模型。</li>
<li class="lvl-6">计算世界基于计算科学建立的，具有<strong>形式化</strong>的特征，信息的描述具有明确化、准确化和确定化的特征</li>
<li class="lvl-6">需求阶段不适合建立</li>
</ol>
</li>
<li class="lvl-3">
<p>问题世界与业务模型</p>
<ol>
<li class="lvl-6">使用<strong>问题域中的重要概念</strong>作为模型的组元</li>
<li class="lvl-6">使用<strong>概念之间的业务联系</strong>作为组元之间的关系</li>
<li class="lvl-6">使用了<strong>业务描述</strong>的方式，具有<strong>非形式化</strong>特征</li>
</ol>
</li>
<li class="lvl-3">
<p>软件分析模型(分析视图)</p>
<ol>
<li class="lvl-6">介于<strong>计算模型和业务模型</strong>二者之间的模型形式</li>
<li class="lvl-6">分析模型使用了计算模型的<strong>组元形式</strong>，描述解决方案时具有比业务模型更加严谨和适用的描述方式。</li>
<li class="lvl-6">分析模型在<strong>组元的表现</strong>上使用了业务模型的<strong>表现方式</strong></li>
<li class="lvl-6">分析模型是<strong>半形式化</strong>的</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/9.png" alt=""></p>
<h2 id="11-4-需求建模">11.4. 需求建模</h2>
<ol>
<li class="lvl-3">
<p>需求分析的关键就是为真实世界的问题建模，即问题域模建模。</p>
</li>
<li class="lvl-3">
<p>通常的做法是：</p>
<ol>
<li class="lvl-6">先依据获取的问题域信息建立初步的模型。</li>
<li class="lvl-6">然后分析用户需求，对模型进行调整，得到一个中间形式的模型形式。</li>
<li class="lvl-6">最后，对调整后的模型进行逻辑推理和验证，如果符合预期的期望，那么它就是最终的解决方案模型。</li>
</ol>
</li>
</ol>
<h2 id="11-5-需求细化">11.5. 需求细化</h2>
<h2 id="11-6-需求的记录">11.6. 需求的记录</h2>
<h2 id="11-7-需求协商">11.7. 需求协商</h2>
<h1>12. 过程建模</h1>
<h1>13. 数据建模</h1>
<h1>14. 面向对象建模</h1>
<h2 id="14-1-类">14.1. 类</h2>
<h2 id="🌟14-2-领域模型-概念类图">🌟14.2. 领域模型(概念类图)</h2>
<ol>
<li class="lvl-3">
<p>不包含行为的类图</p>
</li>
<li class="lvl-3">
<p>如果候选对象既<strong>维持一定的状态</strong>，又依据状态<strong>表现一定的行为</strong>，那么它就应该是一个独立存在的对象。从代码角度即<strong>有属性又有对应的方法</strong></p>
</li>
<li class="lvl-3">
<p>过程</p>
<ol>
<li class="lvl-6">识别候选对象与类
<ol>
<li class="lvl-9">概念类分类列表</li>
<li class="lvl-9">名词分析</li>
<li class="lvl-9">行为分析</li>
</ol>
</li>
<li class="lvl-6">确定概念类：状态与行为
<ol>
<li class="lvl-9">属性的复杂度问题：二维限制不应该出现在面向对象建模中，比如图书中的作者是一个复杂属性，我们也不应该将其抽象为一个对象，因为他没有自己的行为。</li>
<li class="lvl-9">人们易于武断的将单值状态类抽象为其他类的属性：比如价格之于商品，价格本身可能会有一定的行为。</li>
</ol>
</li>
<li class="lvl-6">建立类之间的关联</li>
<li class="lvl-6">添加类的重要属性</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/9.png" alt=""></p>
<h2 id="🌟14-3-顺序图">🌟14.3. 顺序图</h2>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/10.png" alt=""></p>
<ol>
<li class="lvl-3">
<p>组合片段</p>
<ol>
<li class="lvl-6"><strong>opt</strong>:可选</li>
<li class="lvl-6"><strong>alt</strong>:多选一</li>
<li class="lvl-6"><strong>loop</strong>：循环</li>
<li class="lvl-6"><strong>break</strong>：满足条件执行其中语句后退出顺序图</li>
<li class="lvl-6"><strong>par</strong>:交织并行，随时可以切换执行【类似并发，比如收银员可以随时从正在收银切换到结束收银】</li>
<li class="lvl-6">critical:关键原子操作，不可以被破坏</li>
<li class="lvl-6">strict:必须顺序执行</li>
<li class="lvl-6">seq:不同时间线上可以按照任意序</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/13.png" alt=""></th>
<th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/14.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/15.png" alt=""></td>
<td><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/16.png" alt=""></td>
</tr>
<tr>
<td><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/17.png" alt=""></td>
<td><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/18.png" alt=""></td>
</tr>
<tr>
<td><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/19.png" alt=""></td>
<td><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book14/20.png" alt=""></td>
</tr>
</tbody>
</table>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/12.png" alt=""></p>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/23.png" style="zoom: 67%;" /> 
<h2 id="14-4-通信图">14.4. 通信图</h2>
<h2 id="🌟14-6-状态图">🌟14.6. 状态图</h2>
<table>
<thead>
<tr>
<th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/13.png" alt=""></th>
<th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/img/exam/14.png" alt=""></th>
</tr>
</thead>
</table>
<ol>
<li class="lvl-3">
<p>确定上下文环境</p>
</li>
<li class="lvl-3">
<p>识别状态，标记初始状态和结束状态</p>
</li>
<li class="lvl-3">
<p>建立状态转换</p>
</li>
<li class="lvl-3">
<p>补充详细信息，完善状态图</p>
</li>
</ol>
<h2 id="14-7-OCL">14.7. OCL</h2>
<h2 id="14-8-CRC">14.8. CRC</h2>
<h1>15. 需求规格说明</h1>
<h1>16. 需求验证</h1>
<ol>
<li class="lvl-3">
<p>验证(validation)与确认(vertification)</p>
<ol>
<li class="lvl-6"><strong>需求验证</strong>
<ol>
<li class="lvl-9">需求集是正确的、完备的和一致的</li>
<li class="lvl-9">技术上是可解决的</li>
<li class="lvl-9">它们在现实世界中的满足是可行的和可验证的</li>
</ol>
</li>
<li class="lvl-6"><strong>需求确认</strong>
<ol>
<li class="lvl-9">每一条需求都是符合用户原意的</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>需求验证是专指在需求规格说明完成之后，对需求规格说明文档进行的验证活动</strong></p>
</li>
<li class="lvl-3">
<p>软件工程中的系统验证的主要手段</p>
<ol>
<li class="lvl-6">软件测试</li>
<li class="lvl-6">静态分析</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>需求验证方法</strong></p>
<ol>
<li class="lvl-6"><strong>评审(同级评审)</strong>：由作者之外的其他人来检查产品问题的方法，是主要的<strong>静态分析</strong>手段</li>
<li class="lvl-6"><strong>原型与模拟</strong>：复杂的动态行为</li>
<li class="lvl-6"><strong>开发测试用例</strong>：如果不能配备测试用例则可能存在问题</li>
<li class="lvl-6"><strong>用户手册编制</strong>：验证功能需求、项目范围、异常流程、环境与约束</li>
<li class="lvl-6"><strong>利用跟踪关系</strong>：层次化的需求关系：上层需求是否得到下层的支持</li>
<li class="lvl-6"><strong>自动化分析</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>需求验证不仅要发现问题，而且要监督问题的解决</p>
</li>
</ol>
<h1>17. 需求管理</h1>
<ol>
<li class="lvl-3">
<p>需求基线应该成为后续软件系统开发的工作基础和粘合剂</p>
</li>
<li class="lvl-3">
<p>需求管理<strong>作用</strong></p>
<ol>
<li class="lvl-6">增强了项目涉众对<strong>需求</strong>(尤其是复杂需求)的掌握。</li>
<li class="lvl-6">增进了项目涉众之间的<strong>交流</strong></li>
<li class="lvl-6"><strong>减少</strong>了工作量的<strong>浪费</strong>，提高了生产力：需求管理能够更加有效的处理需求的变更</li>
<li class="lvl-6">准确<strong>反映</strong>项目的<strong>状态</strong></li>
<li class="lvl-6">使得项目涉众认识到需求在项目工作中的重要性</li>
</ol>
</li>
<li class="lvl-3">
<p>简述需求管理的三种方法和流程</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230218225349779.png" alt="image-20230218225349779"></p>
<ol>
<li class="lvl-6">
<p><strong>维护需求基线</strong></p>
<ol>
<li class="lvl-9">基线：<strong>已经通过正式评审和批准的规格说明或产品</strong>，它可以作为进一步开发的基础，并且<strong>只有通过正式的变更控制过程才能修改它</strong></li>
<li class="lvl-9">需求基线维护活动——<strong>配置管理</strong>
<ol>
<li class="lvl-12">标识配置项</li>
<li class="lvl-12">版本控制</li>
<li class="lvl-12">变更控制</li>
<li class="lvl-12">访问审计</li>
<li class="lvl-12">状态报告</li>
</ol>
</li>
<li class="lvl-9">需求基线维护活动——<strong>状态维护</strong></li>
</ol>
</li>
<li class="lvl-6">
<p><strong>实现需求跟踪</strong></p>
<ol>
<li class="lvl-9">
<p>避免在开发过程或者演化过程中与需求基线不一致或者偏离的风险</p>
</li>
<li class="lvl-9">
<p>需求跟踪是以<strong>软件需求规格说明文档作为基线</strong>，在<strong>向前和向后</strong>两个方向上，描述需求以及跟踪需求变化的能力。</p>
</li>
<li class="lvl-9">
<p><strong>前向跟踪</strong>：前向跟踪是指被定义到软件需求规格说明文档之前的需求演化过程</p>
<ol>
<li class="lvl-12">跟踪：<strong>说明涉众的需要和目标产生了哪些软件需求</strong></li>
<li class="lvl-12">回溯：<strong>说明软件需求来源于哪些涉众的需要和目标</strong></li>
</ol>
</li>
<li class="lvl-9">
<p><strong>后向跟踪</strong>：后向跟踪是指被定义到软件需求规格说明文档之后的需求演化过程</p>
<ol>
<li class="lvl-12">跟踪：说明软件需求是如何被<strong>后续的开发物件支持和实现</strong>的</li>
<li class="lvl-12">回溯：说明各种系统开发的物件是<strong>因为什么原因(软件需求)而被开发出来的</strong></li>
</ol>
</li>
<li class="lvl-9">
<p>实现方式</p>
<ol>
<li class="lvl-12">
<p><strong>需求跟踪矩阵</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230217153125326.png" alt="image-20230217153125326"></p>
</li>
<li class="lvl-12">
<p><strong>实体关系模型</strong></p>
</li>
<li class="lvl-12">
<p><strong>交叉引用</strong>：文档之间</p>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">
<p><strong>控制变更</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/%E9%9C%80%E6%B1%82/img/book17/8.png" alt=""></p>
<ol>
<li class="lvl-9">
<p>变更控制<strong>注意事项</strong></p>
<ol>
<li class="lvl-12"><strong>认识到变更的必要性，并为之制定计划</strong></li>
<li class="lvl-12"><strong>维护需求基线，审计变更记录</strong></li>
<li class="lvl-12"><strong>管理范围蔓延</strong></li>
<li class="lvl-12"><strong>灵活应对变更请求</strong></li>
<li class="lvl-12"><strong>使用辅助工具</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>需求和商业模式创新</category>
      </categories>
      <tags>
        <tag>需求和商业模式创新</tag>
      </tags>
  </entry>
  <entry>
    <title>6 链路层和局域网</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/6%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h1>6 链路层和局域网</h1>
<p><strong>一般网卡实现了链路层和物理层的功能</strong>，它们是紧密捆绑的</p>
<p>标题并不是说广域网没有链路层，而是因为广域网的链路层相比于局域网很简单</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505164505842.png" alt="image-20220505164505842"></p>
<span id="more"></span>
<h2 id="6-1-引论和服务">6.1 引论和服务</h2>
<h3 id="网络连接形式">网络连接形式</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505193511923.png" alt="image-20220505193511923"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>点到点</strong>的链路是指两个路由器之间<strong>有链路相连</strong>，A 通过这条链路<strong>就是发给 B</strong>，不可能到其他地方去，就是封装和解封装的过程，因此比较简单，同理 B 就是发给 A。<strong>一般用于广域网</strong>，如海底电缆、拨号接入【家里面的 ADSL 连接到运营商的 modem 池也是点到点的，因为这条线路被一个人占用，其他人不能用】</p>
<ul class="lvl-2">
<li class="lvl-4">广域网带宽大，延迟大，因此信道容量大，因此容易碰撞冲突，不适合用多点连接</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>多点连接</strong>指多个设备连到交换机上，经过交换机到达其他点。存在<strong>寻址和媒介访问控制问题[在 WAN 中没有]</strong>，要区分不同的网卡( MAC )，处理多个设备发出的报文。<strong>一般用于局域网</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>共享型介质</strong>：用同轴电缆将多个设备连接在一起，报文发送到电缆上，其他设备都能收到<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505193231365.png" alt="image-20220505193231365"></p>
</li>
<li class="lvl-4">
<p><strong>网络交换机</strong>：所有设备与网络交换机连接，通过网络交换机来转发</p>
<p>如教室中的 <strong>AP</strong> 无线访问接入点 <em>WirelessAccessPoint</em></p>
<blockquote>
<p>AP 就相当于有线网络的集线器，它能够把各个无线客户端连接起来，<strong>该单元内的所有无线信号都要通过它才能进行交换</strong>。AP 是无线局域网基本模式中必不可少的设备</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="导论">导论</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505194239517.png" alt="image-20220505194239517"></p>
<p><strong>链路层的功能：一个节点把帧通过链路传到另一个相邻的节点</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505195052877.png" alt="image-20220505195052877"></p>
<h3 id="服务">服务</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505195836892.png" alt="image-20220505195836892"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505200634302.png" alt="image-20220505200634302"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>成帧</p>
</li>
<li class="lvl-2">
<p>链路接入【发送帧之前要获得信道的使用权】</p>
</li>
<li class="lvl-2">
<p>相邻两点之间完成可靠数据传输</p>
<ul class="lvl-2">
<li class="lvl-4">出错率低的链路很少使用，避免了为了保证可靠所做的代价以太网直接有线链路连接，本身很可靠，因此不提供 RDT</li>
<li class="lvl-4">无线链路出错率高，RDT 是有必要的。<strong>如果</strong>在链路层<strong>这里不重传</strong>，那么<strong>只能靠源主机重传，这样的代价太大</strong>【这就是为什么在实现了传输层 RDT 时还要实现链路层的 RDT，即<strong>减少代价</strong>】</li>
</ul>
</li>
<li class="lvl-2">
<p>流量控制</p>
</li>
<li class="lvl-2">
<p>错误检测</p>
</li>
<li class="lvl-2">
<p>差错纠正</p>
</li>
<li class="lvl-2">
<p>半双工和全双工：像对讲机就是半双工，一次只能一个人讲话</p>
</li>
</ul>
<p>注意这些服务的链路层<strong>各种协议服务的总和</strong>，<strong>具体到某个协议</strong>时，这个协议提供的服务可能<strong>只是上面服务的一个子集</strong>【如以太网就不提供 RDT】</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505201034992.png" alt="image-20220505201034992"></p>
<p>网卡；网络适配器；NIC <em>network interface card</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505201201045.png" alt="image-20220505201201045"></p>
<h2 id="6-2-差错检测和纠正">6.2 差错检测和纠正</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505201458890.png" alt="image-20220505201458890"></p>
<p><strong>EDC</strong> <em>error-detection-and-correction</em></p>
<h3 id="奇偶校验">奇偶校验</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505201728300.png" alt="image-20220505201728300"></p>
<h3 id="CheckSum">CheckSum</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505201853632.png" alt="image-20220505201853632"></p>
<h3 id="CRC">CRC</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505202015191.png" alt="image-20220505202015191"></p>
<p><em>Cyclic Redundancy Check</em></p>
<ol>
<li class="lvl-3">
<p><strong>模二运算</strong>，位的加法不进位，减法不借位，<strong>就是异或运算</strong></p>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505202606426.png" alt="image-20220505202606426">两种表示方式等价</p>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220505202732087.png" alt="image-20220505202732087">r 次方生成多项式，共 r+1 位</p>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220506094959577.png" alt="image-20220506094959577">D 左移 R 位模二除 G 得到 R 位余数</p>
</li>
<li class="lvl-3">
<p>接收方使用 G 去除以 D+R 如果除尽，则说明没有出错，否则出错</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220506095814138.png" alt="image-20220506095814138"></p>
<h2 id="6-3-多点访问协议">6.3 多点访问协议</h2>
<p><strong>MAP</strong> <em>multiple access protocol</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220506200041149.png" alt="image-20220506200041149"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220506200152514.png" alt="image-20220506200152514"></p>
<p><strong>多个站点，一个信道</strong>，在信道上发送数据信息、控制信息</p>
<h3 id="MAC">MAC</h3>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507104848735.png" alt="image-20220507104848735"></p>
<p>从算法角度是 <strong>MAC</strong>，从协议角度是 <strong>MAP</strong></p>
<p>可以分成三大类</p>
<p>在理想情况下，对于速率为 R bps 的广播信 道，<strong>多路访问协议应该具有以下所希望的特点</strong></p>
<ol>
<li class="lvl-3">
<p>当仅有一个节点发送数据时，该节点具有R bps 的吞吐量；</p>
</li>
<li class="lvl-3">
<p>当有 M 个节点发送数据时，每个节点吞吐量为 R/M bps 这<strong>不必要求 M 个节点中 的每一个节点总是有 R/M 的瞬间速率</strong>，而是每个节点在一些适当定义的时间间隔内应该有 R/M 的平均传输速率。</p>
</li>
<li class="lvl-3">
<p>协议是分散的；这就是说<strong>不会因某主节点故障而使整个系统崩溃</strong>。</p>
</li>
<li class="lvl-3">
<p>协议是<strong>简单的</strong>，使实现不昂贵。</p>
</li>
</ol>
<h4 id="1-信道划分协议">1.信道划分协议</h4>
<p><em>channel partitioning protocol</em></p>
<p><strong>低负载的时候，只有部分几个划分被利用了，利用率低；高负载大多数划分都被利用了，因此利用率高</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507105107496.png" alt="image-20220507105107496"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507105144286.png" alt="image-20220507105144286"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507105556900.png" alt="image-20220507105556900"></p>
<p>CDMA 采用编码来区分，不同的站点的编码之间是正交的，可以区分开，是第三代移动通信技术即 3G</p>
<p>4G 5G 是频分时分等多种复杂技术综合使用</p>
<h4 id="2-随机存取协议">2.随机存取协议</h4>
<p><em>random access protocol</em></p>
<p><strong>低负载时利用率高，高负载时冲突增加，利用率下降</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507105722306.png" alt="image-20220507105722306"></p>
<p>协议规定：【有上百种此类型协议】</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如何检测冲突</p>
</li>
<li class="lvl-2">
<p>如何从冲突中恢复</p>
</li>
</ul>
<p><strong>以太网采用 CSMA/CD</strong></p>
<p><strong>无线局域网 802.11 采用 CSMA/CA</strong></p>
<blockquote>
<p><strong>载波监听多路访问</strong> <strong>CSMA</strong> <em>Carrier Sense Multiple Access</em>：设备监听其它设备是否忙碌，只有在线路空闲时才发送。</p>
<p><strong>冲突检测 CD</strong> <em>collision detect</em></p>
<p><strong>冲突避免 CA</strong> <em>collision avoid</em></p>
</blockquote>
<h5 id="时隙-ALOHA">时隙 ALOHA</h5>
<blockquote>
<p>之所以是 ALOHA 是因为是在夏威夷发明的，ALOHA 在夏威夷语中是你好的意思</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507110447603.png" alt="image-20220507110447603"></p>
<p>检测到碰撞时，大家都停止在这个时隙发送【会导致该时隙<strong>浪费</strong>】，而在随后的时隙<strong>以概率 p 重发</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507111032296.png" alt=""></p>
<p><strong>需要节点对时隙时钟同步</strong>，后面介绍的协议均不需要同步</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507111241924.png" alt="image-20220507111241924"></p>
<h5 id="纯-ALOHA">纯 ALOHA</h5>
<p>事实上先于时隙 ALOHA 提出</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507111452838.png" alt="image-20220507111452838"></p>
<p>这里的所有帧的长度也是一样的，因此每个帧的传输时间是一样的。<strong>因此称为帧时</strong></p>
<p>因此要求在 t<sub>0</sub>-1~t<sub>0</sub>+1的范围内都没有其他节点发送的概率</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507111816241.png" alt="image-20220507111816241"></p>
<h5 id="CSMA">CSMA</h5>
<p><strong>CS：在传输前监听有没有冲突，发送后不监听</strong></p>
<p>只能<strong>尽可能减少</strong>，但<strong>不能避免冲突</strong></p>
<p><strong>节点通过局部的 sense 来判断 channel 的全局使用情况</strong>，即通过听到了其他节点发送的信号，才能知道当前信道被使用，但如果其他节点的信号在路上还没有到达该节点，那么将监听不到，因此该节点也会发送信号【<em>因此如果节点间的距离越远，就越有可能发送冲突，因为不能及时检测到</em>】，发送冲突。如下</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507112739174.png" alt="image-20220507112739174"></p>
<h5 id="CSMA-CD">CSMA/CD</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507112909094.png" alt="image-20220507112909094"></p>
<p><strong>CD：边发送边监听</strong></p>
<p>检测到冲突就停止传输，减少了对信道的浪费</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507113244422.png" alt="image-20220507113244422"></p>
<p><strong>以太网</strong>使用</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507113350871.png" alt="image-20220507113350871"></p>
<p><strong>位时：发送一个 bit 位的时间</strong></p>
<p><strong>强化冲突</strong>：检测到的站点要发 Jam，其他收到Jam 的也要发，从而强化信号，让所有站点都能知道</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508142649572.png" alt="image-20220508142649572"></p>
<p><strong>二进制指数退避算法</strong> <em>exponential backoff</em>：发送冲突时，进入退避状态，<strong>分布式</strong>在一个范围内选择值，如果两个冲突的适配器<strong>选择了不同的值，那么就可以避免冲突</strong>。如果持续失败，那么每次范围<strong>扩大两倍</strong>，两个适配器<strong>选择同一个值的概率指数下降，因此冲突概率指数下降</strong>，但因为范围大，<strong>等待时间也会变大</strong>。其中的 <strong>K 最大为 10</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507114842201.png" alt="image-20220507114842201"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当传播时延接近0时，效率接近1。碰撞的节点将立即中止而不会浪费信道。</p>
</li>
<li class="lvl-2">
<p>传输帧时间变成无穷大时效率为 1 是因为这个帧的传输一直占用信道，其他节点一直等待，也就不存在冲突了</p>
</li>
</ul>
<h5 id="CSMA-CA">CSMA/CA</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507115348328.png" alt="image-20220507115348328"></p>
<p>不像有线介质，无线网络中信号衰减严重，设备间干扰严重，因此<strong>自身信号远远大于其他节点的信号</strong>，不能进行冲突检测</p>
<p>即使冲突检测，如下面的 A C 之间阻隔了，因为检测时 A C 不能相互检测到，因此不会冲突，但如果它们同时发送给 B，那么就导致了冲突；此外如果检测到冲突，但信号非常弱，对当前的传输影响几乎没有，那么即使冲突也可以成功。<strong>因此 WLAN 中是否检测到冲突和成功没有直接关系</strong>，检测了也没有用【<em>在 <strong>LAN</strong> 中没有检测到冲突和成功几乎是对应的关系，因此也<strong>不需要 ACK</strong></em>】</p>
<blockquote>
<p>注意这里的情况有个限制，不碰撞=成功，要求帧的长度要 ≥ 2 τ，τ是两个最远的节点之间数据传输的时间，2 τ 就是一个来回。考虑一个极端情况，在 A 发送后，信号传递到 B，但还差一点才传到 B 时，B 可以发送，那么立即会引起冲突，B 的冲突信号传递到 A 需要 τ 的时间，如果 A 的帧比 2 τ 短，那么冲突信号还没到那么就发送结束了，A 会认为没有碰撞，那么成功了，而事实上是失败的，因为有 B 的信息干扰了。因此在以太网中如果帧的长度比较短，那么会有填充码字段，用来保证长度是 ≥ 2 τ 的</p>
<p>信号在以太网传播1km大约需要5us，即信号传播速率实际约为2x10 A 8m/s。以太网最大端到端长度约为5km，单程传播时延为25us，争用期的一半(即25.6us) 必须大于该值。</p>
<p>对于10M以太网，发送速率为10Mb/s，在争用期(端到端往返传播时延)可发送</p>
<p>512bit，即64字节，因此以太网规定了最短，帧长64字节，若发送数据非常少，那么必须加入- -些填充字节，使得帧长不小于64字节。</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507120118538.png" alt="image-20220507120118538"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507121655784.png" alt="image-20220507121655784"></p>
<p>检测到忙碌，<strong>事前就随机选择一个回退值</strong>，并在<strong>检测到信道空闲时递减值</strong>[信道忙时不减值]，<strong>从而避免后面有可能避免的冲突</strong></p>
<p>因为不能做 CD，因此<strong>需要有 ACK</strong> 来保证传输的成功</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507122230068.png" alt="image-20220507122230068"></p>
<p>使用了 CA 也<strong>无法完全避免冲突</strong>，如下</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507122532616.png" alt="image-20220507122532616"></p>
<p><strong>协议可选项：预约帧</strong>：可以完全避免冲突，一般用于长数据帧的传输，避免被冲突打断</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507123042018.png" alt="image-20220507123042018"></p>
<h5 id="线缆接入网络">线缆接入网络</h5>
<p><strong>有线电缆数据服务接口规范</strong> <strong>DOCSIS</strong> <em>Data Over Cable Service Interface Specifications</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507141127462.png" alt="image-20220507141127462"></p>
<p><strong>电缆数据机终端系统 CMTS</strong> <em>Cable Modem Temination System</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220507142431441.png" alt="image-20220507142431441"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用 FDM 将上行和下行划分成多个频率信道，上行和下行在不同的频率上发送</p>
</li>
<li class="lvl-2">
<p>下行不存在竞争，只有一个 CMTS，它发送的信息所有节点都能收到，节点通过比较地址来接收数据</p>
</li>
<li class="lvl-2">
<p>上行信道通过 TDM 划分时隙：</p>
<ul class="lvl-2">
<li class="lvl-4">有一组<strong>专门用于发送时隙请求帧的时隙</strong>，节点需要向 CMTS 发送时隙请求，<strong>请求是独立随机的，这里是会产生碰撞的</strong>。【但不检测碰撞】</li>
<li class="lvl-4">CMTS 在下行信道上发送 MAP 报文指定哪个节点可以在哪个指定的时间间隔内发送。如果请求的节点<strong>没有</strong>收到下行报文种对请求分配的<strong>响应</strong>，那么节点就知道<strong>发送碰撞</strong>了。<strong>使用二进制指数退避算法</strong></li>
<li class="lvl-4">对于其他用于分配的时隙，因为节点是在<strong>各自时隙上发送信息的，因此不会产生冲突</strong>。</li>
</ul>
</li>
</ul>
<p>因此这种 MAP 分类在信道划分/随机存取中都可以，<strong>可以认为是几种 MAP 的综合</strong></p>
<h4 id="3-轮流-MAC-协议">3.轮流 MAC 协议</h4>
<p><em>taking-turns protocol</em></p>
<p><strong>高负载和低负载的利用率都很高</strong>【<em>但高负载和低负载的利用率没有对应的前面两种方式高，因为有一定的消耗</em>】，但过于复杂，使用得很少。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508093809110.png" alt="image-20220508093809110"></p>
<h5 id="轮询-集中式">轮询-集中式</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508093900481.png" alt="image-20220508093900481"></p>
<p>由主节点一个个询问节点要不要传输数据</p>
<p>主节点首先向节点1发送一个报文，告诉它（节点1） 能够传输的帧的最多数量。在节点1传输了某些帧后，主节点告诉节点2它（节点2）能够传输的帧的最多数量。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>等待问题</p>
</li>
<li class="lvl-2">
<p>主节点故障问题</p>
</li>
</ul>
<h5 id="令牌传递-分布式">令牌传递-分布式</h5>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508094106210.png" alt="image-20220508094106210"></p>
<p>令牌：特殊的帧</p>
<p>当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌，发送完最大数目的帧数后，又将令牌转交给下一个节点；否则，它立即向下一个节点转发该令牌。</p>
<p>谁发的，最终要由其接收</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>节点忘记释放令牌问题</p>
</li>
<li class="lvl-2">
<p>令牌丢失问题</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508094533196.png" alt="image-20220508094533196"></p>
<h2 id="6-4-LANS-局域网技术">6.4 LANS 局域网技术</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508112252694.png" alt="image-20220508112252694"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>IP 地址是分层的，便于路由聚集、计算，减少路由表数量；</strong></p>
</li>
<li class="lvl-2">
<p><strong>MAC 地址是平面的</strong><br>
<strong>48 位</strong> MAC 地址/链路层地址/局域网地址：<strong>用于区分一个物理网络内部的不同网卡/节点，从而将数据封装成帧发送</strong></p>
<p>前3个字节代表网络硬件制造商的编号，后3个字节代表该制造商所制造的某个网络产品(如网卡)的系列号</p>
</li>
<li class="lvl-2">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508112953182.png" alt="image-20220508112953182"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508113255757.png" alt="image-20220508113255757"></p>
</li>
</ul>
<p>根据 IP 找到下一跳，再修改目标 MAC 地址为下一跳的 MAC 地址。才能使用链路层的网卡去发送到对应的节点</p>
<p>从网络层的角度看，最后一跳就是一跳，从一个 IP 到下一个 IP，但从链路层来看，最后一跳可能还要经过多个交换机才能到达</p>
<p><strong>全 1 的 MAC 地址是广播地址，交换机应该将其转发给局域网内的所有节点</strong></p>
<h3 id="ARP">ARP</h3>
<p><strong>地址解析协议</strong> <em>Address Resolution Protocol</em></p>
<p><strong>网络层的服务，只涉及网络层和数据链路层</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508113448792.png" alt="image-20220508113448792"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508113745090.png" alt="image-20220508113745090"></p>
<p><strong>原理</strong>：ARP <strong>即查即用</strong>，A 需要查询目标 B 的 MAC 地址时就广播一个包含 B 的 IP 地址的 ARP 查询包，其中源 MAC 地址是 A 的，目标 MAC 地址是全 1 的广播地址，B 收到对比 IP 后就将自己的 MAC 地址作为源 MAC 地址发送应答帧给 A，并记录发送方 MAC 地址，如果对比后发现不是自己的 IP，那么<strong>会丢弃</strong>，且会<strong>记录</strong>下对应的发送方 IP 的MAC地址。。</p>
<p>A 保存这个 IP : MAC 映射时间为 <strong>20 min</strong>，超时就删除</p>
<h4 id="例子">例子</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508114342550.png" alt="image-20220508114342550"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508114502765.png" alt="image-20220508114502765"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508114813292.png" alt="image-20220508114813292"></p>
<p>源 IP 和目标 IP 都不发生改变</p>
<p>但 源 MAC 和目标 MAC 在每一段中都是改变的</p>
<h3 id="以太网">以太网</h3>
<p>最主流的 LAN 技术</p>
<blockquote>
<p>以太网对本地区域联网的重要性就像因特网对全球联网所具有的地位那样。</p>
</blockquote>
<blockquote>
<p>鲍勃·麦卡夫 Bob Metcalfe 以太网之父</p>
</blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508114936272.png" alt="image-20220508114936272"></p>
<p>节点都连接到同轴电缆上，两端有终结器用于吸引信号，防止信号反射回去，影响 CSMA/CD</p>
<h4 id="拓扑结构">拓扑结构</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508121936688.png" alt="image-20220508121936688"></p>
<p><strong>发展：总线→星形</strong></p>
<ol>
<li class="lvl-3">
<p><strong>同轴电缆</strong>，2 Mbps。但如果电缆损坏一部分，那么所有节点都不能使用，会有反射影响 CSMA/CD</p>
</li>
<li class="lvl-3">
<p><strong>使用集线器 HUB</strong></p>
</li>
<li class="lvl-3">
<p><strong>交换机 switch</strong></p>
</li>
</ol>
<h4 id="以太网帧结构">以太网帧结构</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508122149754.png" alt="image-20220508122149754"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>前导码/前同步码 Preamble</strong>【<strong>8 B</strong>】：前 7 个字节是 10101010，后 1 个字节是 10101011</p>
<blockquote>
<p>前同步码字段的前 7 字节用于“唤醒”接收适配器，并且将<strong>它们的时钟和发送方的时钟同步。</strong></p>
<p>为什么这些时钟会不同步呢？</p>
<p>记住适配器的目的是根据以太局域网类型的不同，分别以 10 Mbps、100 Mbps或者 1 Gbps 的速率传输帧。然而网卡不会以精确的额定速率传输帧；相对于额定速率总有一些<strong>漂移</strong>，局域网上的其他适配器不会预先知道这种漂移的。<strong>接收适配器只需通过锁定前同步码的前7字节的比特的速率，就能够锁定适配器A的时钟。<strong>前同步码的第 8 个字节的最后两个比特（第一个出现的</strong>两个连续的 1</strong>）警告接收适配器数据要到来了。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>目标 MAC 地址</strong>【<strong>6 B</strong>】：网卡接收：</p>
<ol>
<li class="lvl-5">目标 MAC 地址是自己地址的，<strong>非混杂模式</strong>，此时网卡只接受来自网络端口的目的地址指向自己的数据。<strong>其他丢弃</strong></li>
<li class="lvl-5">目标 MAC 地址是全 1 的广播地址</li>
<li class="lvl-5">其他的不是上面两种情况的 MAC，把网卡设置成<strong>混杂模式</strong>，能够接收所有经过它的数据流，而不论其目的地址是否是它。因此抓包软件就是使用的混杂模式</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>源 MAC 地址【6 B】</strong></p>
</li>
<li class="lvl-2">
<p><strong>类型 TYPE【2 B】</strong>：标识上层的网络协议是什么，如 type = 0x0806 时会将帧交给 ARP 协议</p>
</li>
<li class="lvl-2">
<p><strong>数据/载荷</strong>【<strong>46 ~ 1500 B</strong>】：这个字段承载了 IP数据报。以太网的<strong>最大传输单元 （MTU）是1500字节</strong>。这意味着如果<strong>IP数据报超过了 1500字节【包括头部】</strong>，则主机必须将该数据报分片。数据字段的<strong>最小长度是46字节</strong>。这意味着如 果IP数据报小于46字节，数据报必须被<strong>填充到46字节</strong>。</p>
</li>
<li class="lvl-2">
<p><strong>CRC【4 B】</strong>：放在最后，因此可以边发边生成，发完数据直接发送 CRC 即可</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508141755780.png" alt="image-20220508141755780"></p>
<p>因为有形介质本身比较可靠了，如果上层是 UDP，那么就不会重传了，对方的应用层会看到 gap，有内容丢失了</p>
<p>而如果是 TCP 则会引起重传，但以太网并不知道它在传输一个之前的数据，因为它并不关注</p>
<blockquote>
<p>缺乏可靠的传输有助于使得以太网简单和便宜</p>
</blockquote>
<h4 id="802-3-以太网标准">802.3 以太网标准</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508142223948.png" alt="image-20220508142223948"></p>
<p>很多的以太网标准：<em>是链路层也是物理层的规范</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>相同</strong>的 MAC 协议和帧结构</p>
</li>
<li class="lvl-2">
<p><strong>不同</strong>的速率、不同的物理层标准、不同的物理层媒介</p>
</li>
</ul>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508142924466.png" alt="image-20220508142924466"></p>
<p>100 Mbps 为 fast Ethernet</p>
<p>T 指双绞线</p>
<p>节点与 HUB 的最大距离是 100 m</p>
<h4 id="曼彻斯特编码">曼彻斯特编码</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508143329585.png" alt="image-20220508143329585"></p>
<p>曼彻斯特编码是一种<strong>自同步</strong>的编码方式，即<strong>时钟同步信号就隐藏在数据波形中</strong>。该跳变既可作为时钟信号，又可作为数据信号</p>
<blockquote>
<p>如果不是这样，比如传输全为 1 的数据，那么波形电位永远是 1，接收方如果不知道时钟频率，将不知道这里面有多少个 1</p>
</blockquote>
<p>跳变是为了能够将时钟信号抽取出来，跳变的方向代表传输的数据。<strong>因此一段信号可以将时钟信号和数据信号同时传输</strong></p>
<p>接收方只要按照这个时钟来接收数据即可</p>
<blockquote>
<p>每位中间的电平转换既表示了数据代码，也作为定时信号使用</p>
<p>由于曼彻斯特码在每个时钟位都必须有一次变化，因此，其编码的效率仅可达到50%左右</p>
</blockquote>
<h4 id="4b5b-编码">4b5b 编码</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508144507843.png" alt="image-20220508144507843"></p>
<p><strong>用 5 个bit 去代表 4 个 bit</strong>，使得波形不会一直不变，一定是错落有致的，因此可以从中提取时钟信号，而又不像上面的编码方式那样，每个  bit 都包含时钟信号，提高效率到 80%</p>
<h4 id="8b10b-编码">8b10b 编码</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508144541326.png" alt="image-20220508144541326"></p>
<p>千兆以太网中使用 8b10b 编码</p>
<h3 id="网络交换设备">网络交换设备</h3>
<h4 id="集线器-HUB">集线器 HUB</h4>
<p>所有节点接到 HUB 的端口上，HUB 将信号往所有端口转发。<strong>HUB 还可以级联</strong>。所有通过 HUB 连接在一起的都在<strong>一个碰撞域</strong>【<em><strong>也称作网段 LAN segment</strong></em>】内，一次只能一个节点发送数据物理上是星形，但逻辑上是总线形的，在盒子里面是总线不能将不同速率的 HUB 连接在一起，将无法工作，如 10 Mbps 和 100 Mbps 不能连接在一起<br>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508145523925.png" alt="image-20220508145523925"></p>
<h4 id="交换机">交换机</h4>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508151801903.png" alt="image-20220508151801903"></p>
<p>实现一个端口到其他端口的转发【而不是所有端口】。一个主机连接交换机的一个端口，消除了 CSMA/CD 在高负载下的冲突问题，<strong>因为一个主机就一个端口【独享】，不同主机发到不同端口，不存在碰撞</strong>。<strong>解决了 CSMA/CD 高负载利用率低的问题</strong>。<em>这也是为什么以太网获得统治地位的原因，其他原因：带宽不断升级、价格低廉</em></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508152313976.png" alt="image-20220508152313976"></p>
<p>是一个<strong>存储转发</strong>设备，把帧存下来，根据帧头的目标 MAC 地址决定往哪个端口发，<strong>在发送之前要根据 CSMA/CD 的机制接入到这个目标网段</strong>。【可以认为交换机<strong>每个端口都是一个网段</strong>【<em>隔离冲突域</em>】，因此某两个端口在发送接收的同时，其他端口也可以同时并发使用】</p>
<p>任何输岀接口之一的速率可能暂时会超过该接口的链路容量。为了解决这个问题，交换机<strong>输出接口设有缓存</strong></p>
<p>交换机将链路<strong>彼此隔离</strong>，因此不同带宽的链路可以同时接在交换机上</p>
<p>因此如果主机与交换机<strong>直连</strong>，那么在发送前的监听就<strong>只是一个形式</strong>，交换机会协调转发，决不会向相同的接口转发多个帧，<strong>因此 CD 没有意义</strong>。即在基于交换机的以太局域网中，不会有碰撞，<strong>因此没有必要使用MAC协议了!</strong></p>
<p>交换机同样可以级联</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508152405189.png" alt="image-20220508152405189"></p>
<p><strong>即插即用，自学习交换表，无需人工配置</strong></p>
<p>MAC 和端口地址不是一直捆绑，经过一定时间就删除（时戳），这种状态维护机制称为<strong>软状态维护机制</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508152822632.png" alt="image-20220508152822632"></p>
<p>在有帧通过端口<strong>发送进来</strong>时，才根据<strong>源 MAC 学习 MAC : 端口</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508152915407.png" alt="image-20220508152915407"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果<strong>进来的端口</strong>和匹配目标 MAC 后要发<strong>出去的端口一致</strong>，那么就<strong>过滤</strong>掉，不转发【<em>原因是下层主机要发送到下层某个主机，经过下层级联的交换机泛洪，或者是下层的 HUB 向所有节点转发</em>】</p>
</li>
<li class="lvl-2">
<p>如果<strong>不知道</strong>目标 MAC 从哪个端口转发，表中还没有，那么就<strong>泛洪</strong>，向所有端口转发</p>
</li>
</ul>
<h5 id="交换机和路由器">交换机和路由器</h5>
<p>通常，由<strong>几百台主机组成的小网络通常有几个局域网网段</strong>。对于这些<strong>小网络</strong>，<strong>交换机</strong>就足够了，因为它们不要求IP地址的任何配置就能使流量局部化并增加总计吞吐量。但是在由几千台主机组成的更大网络中，通常在网络中（除了交换机之外）还包括路由器。路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用更“智能的”路由。</p>
<p>如下可见一般是<strong>大量的交换机级联</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508153629425.png" alt="image-20220508153629425"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508154001654.png" alt="image-20220508154001654"></p>
<p>交换机级联</p>
<p>运行生成树算法，不能出现环</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508153813514.png" alt="image-20220508153813514"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508154315076.png" alt="image-20220508154315076"></p>
<h3 id="VLANS-虚拟局域网">VLANS 虚拟局域网</h3>
<p>局域网存在：问题</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>缺乏流量隔离</p>
</li>
<li class="lvl-2">
<p>用户在不同局域网内移动需要改变物理布线</p>
</li>
</ul>
<p>能够通过支持虚拟局域网（Virtula Local Network, VLAN）的交换机来处理。</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508195502445.png" alt="image-20220508195502445"></p>
<p>原理：<strong>将交换机的端口划分成不同的组</strong>，来自一个端口的广播流量仅能到达这个组中的其他端口，而不会扩散到其他组，<strong>实现隔离</strong></p>
<p>此时出现新的问题：两个系的之间不能发送信息了。</p>
<p>解决办法：**将 VLAN 的一个端口和一个外部路由器相连。**从电子工程系发往计算机科学系的数据报将首先跨越 EE VLAN 到达路由器，然后由该路由器转发跨越 CS VLAN 到达 CS 主机</p>
<h2 id="6-5-链路虚拟化-MPLS">6.5 链路虚拟化 MPLS</h2>
<p>本科不涉及</p>
<h2 id="6-6-数据中心网络">6.6 数据中心网络</h2>
<p>DC Data Center</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508154744551.png" alt="image-20220508154744551"><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508201210796.png" alt="image-20220508201210796"></p>
<p>在数据中心内部, 外部请求首先被定向到一个<strong>负载均衡器（load balancer）</strong> 。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间<strong>均衡负载</strong>。</p>
<p>由于负载均衡器<strong>基于分组的目的端口号</strong> （第四层）以及<strong>目的IP地址做决策</strong>，因此它们常被称为“<strong>第四层交换机</strong>”</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508205529567.png" alt="image-20220508205529567"></p>
<p>用全连接拓扑可以改善等级拓扑中的主机间通讯带宽收到限制的问题，这里二层交换机之间通讯有多条路径可选</p>
<h2 id="6-7-web-网页的请求历程">6.7 web 网页的请求历程</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508155333308.png" alt="image-20220508155333308"></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508205857338.png" alt="image-20220508205857338"></p>
<p>见书本</p>
<h2 id="总结">总结</h2>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20220508160602559.png" alt="image-20220508160602559"></p>
]]></content>
      <categories>
        <category>计算机网络-自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统设计复习往年题</title>
    <url>/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E5%BE%80%E5%B9%B4%E9%A2%98/</url>
    <content><![CDATA[<h2 id="软件系统设计复习往年题-2023回忆">软件系统设计复习往年题+2023回忆</h2>
<blockquote>
<p>参考自 zhy 的博客 <a href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Exam0-%E5%BE%80%E5%B9%B4%E8%80%83%E8%AF%95/">2021-软件系统设计-Exam0-往年考试 - SpriCoder的博客</a></p>
<p>feat: 新增2023回忆，修改原来的部分回忆题</p>
</blockquote>
<h1>1. 简答题</h1>
<h2 id="1-1-软件系统架构">1.1. 软件系统架构</h2>
<ol>
<li class="lvl-4">
<p>✅ 【必考】如何进行质量属性方案建模？请使用&quot;刺激-相应&quot;图的格式进行建模 How to model quality attribute scenarios? Graphically model one quality attributes in “stimulus-response” format:</p>
</li>
<li class="lvl-6">
<p>【2015】availiability and Performance</p>
</li>
<li class="lvl-6">
<p>【2017】【2018】availiability and modifiability</p>
</li>
<li class="lvl-6">
<p>【2019】interoperability and modifiability</p>
</li>
<li class="lvl-6">
<p>如何进行质量属性方案建模</p>
<ol>
<li class="lvl-9">刺激（Stimulus）：当其到达系统时需要考虑的状况。</li>
<li class="lvl-9">刺激源（Source of Stimulus）：产生刺激的实体（人，系统或任何其他触发），可能是输入、信息等，对当前的状态的一个变化。</li>
<li class="lvl-9">响应（Response）：刺激到来后工件开展的行为。</li>
<li class="lvl-9">响应度量（Response Measure）：对刺激的响应以某种方法进行测量，以便可以<strong>测试需求</strong>（比如多长时间系统有反馈）</li>
<li class="lvl-9">环境（Environment）：发生刺激时系统的状况，例如系统正常运行、系统过载、系统受到攻击、系统网络出现故障等。</li>
<li class="lvl-9">工件（Artifact）：完成需求的整个系统或者系统的一部分（软件制品）。</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/3.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>✅ 【高频 2015 2017 2019 2022】为什么软件系统架构需要使用不同视图来文档化？给出 4 种示例视图的名称和目的。Why should a software architecture be documented using different differenet views? Give the name and purposes of 4 example views.</p>
<ol>
<li class="lvl-6"><strong>原因</strong>
<ol>
<li class="lvl-9">不同视图支持不同的目标和用户，突出不同的系统元素和关系</li>
<li class="lvl-9">不同视图将不同质量属性暴露出不同的程度</li>
</ol>
</li>
<li class="lvl-6">4 种视图 ( 了解 )：
<ol>
<li class="lvl-9">模块视图 Module View：提供一组连贯职责的实现单元</li>
<li class="lvl-9">组件和连接器视图 C &amp; C View：显示运行时行为和交互的元素</li>
<li class="lvl-9">分配视图 Allocation View：描述了软件单元到环境元素的映射</li>
<li class="lvl-9">质量视图 Quality Views，安全视图、性能视图、可靠性视图、通信视图、异常（错误处理）视图</li>
<li class="lvl-9">组合视图：将上述视图进行组合</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 如何选择视图：</p>
<ol>
<li class="lvl-6">构建涉众/视图表</li>
<li class="lvl-6">合并视图</li>
<li class="lvl-6">确定优先级和完成阶段</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 【2017】【2019】描述 4+1 视图 Describe 4+1 view( 掌握绘图 )：答案如上</p>
<ol>
<li class="lvl-6">逻辑视图：描述了对架构而言重要的元素和他们之间的关系（功能需求）</li>
<li class="lvl-6">过程视图：描述了元素之间的交互。</li>
<li class="lvl-6">物理视图（部署视图）：描述了主要过程和组件是如何被映射到硬件上的。</li>
<li class="lvl-6">开发视图（实现视图）：描述实现系统功能的各个组件和模块是如何实现的</li>
<li class="lvl-6">用例场景（Use Case）：描述系统的参与者（用户）与系统功能用例的关系，与一个或多个特定视图相关。</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/4.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>✅【高频 2015 2017 2018】什么区分了软件产品线架构和单个软件产品架构？What distinguishes an architecture for a software product line from an architecture for a single product?</p>
<ol>
<li class="lvl-6">产品线的目的：实现高可重用性、高修改性。而单个软件产品不需要很高的重用性和可拓展性</li>
<li class="lvl-6">产品线之所以有效是因为通过重用可以充分利用产品的共性。</li>
<li class="lvl-6">软件产品线架构倾向于采用更多的模块化和标准化设计，单一产品架构专注于<strong>满足单一产品的特定需求</strong>，因此模块化和标准化程度较低。</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 【高频 2015 2017 2023】将以下每个问题（左侧）与解决该问题的架构风格/视图（右侧）对应起来。列出每个样式类别的四个视图。Map each of the following questions (on the left) with the architectural style/view (on the right) that addresses the question. List four views of each category of style.</p>
<ol>
<li class="lvl-7">连线题
<ol>
<li class="lvl-10">它是如何构建为一组实现单元的？How it is structed as a set of implementation of units(Module Styles)</li>
<li class="lvl-10">它是如何构建为一组具有运行时行为和交互的元素的？How it is structed as a set of elements that have runtime behavior and interactions?(Component-Connector Styles)</li>
<li class="lvl-10">它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment?(Allocation Styles)</li>
</ol>
</li>
<li class="lvl-7">Module Styles：分解视图、使用视图、泛化视图、分层视图、领域视图、数据模型视图</li>
<li class="lvl-7">Component-Connector Styles：管道-过滤器视图、客户端-服务器视图、点对点视图、面向服务视图、发布-订阅视图</li>
<li class="lvl-7">Allocation Styles：部署视图、安装视图、工作分配视图、其他分配视图。</li>
</ol>
</li>
<li class="lvl-3">
<p>✅【2015】【2017】简要描述软件架构过程中的一般活动，以及每个活动的主要输入和输出。Briefly describe the general activities in a software architecture process, and the major inputs and outputs at each activity.</p>
<ol>
<li class="lvl-6">短答案 ( 背 )
<ol>
<li class="lvl-9">识别 ASRs
<ol>
<li class="lvl-12">输入：无</li>
<li class="lvl-12">输出：优先的质量属性场景</li>
</ol>
</li>
<li class="lvl-9">架构设计
<ol>
<li class="lvl-12">输入：优先的质量属性场景、需求和约束、模式和决策</li>
<li class="lvl-12">输出：一组由模式决定的候选视图的草图</li>
</ol>
</li>
<li class="lvl-9">架构文档化
<ol>
<li class="lvl-12">输入：一组由模式决定的候选视图的草图</li>
<li class="lvl-12">输出：View &amp; Beyond</li>
</ol>
</li>
<li class="lvl-9">架构评估
<ol>
<li class="lvl-12">输入：View &amp; Beyond、优先的质量属性场景</li>
<li class="lvl-12">输出：View &amp; Beyond</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/5.png" alt=""></p>
<ol start="7">
<li class="lvl-3">
<p>✅ 【2015】【2017】【2021】【2023】描述架构权衡分析方法 (ATAM) 过程的每个阶段生成的输出。Describe the outputs generated from each phase of Architecture Tradeoff Analysis Method(ATAM) process.</p>
<ol>
<li class="lvl-6">阶段-0：准备和建立团队 ( 输入是架构设计文档 )
<ol>
<li class="lvl-9">评估计划</li>
</ol>
</li>
<li class="lvl-6">阶段-1：评估-1
<ol>
<li class="lvl-9">架构的简明介绍</li>
<li class="lvl-9">业务目标（驱动因素）的阐释</li>
<li class="lvl-9">作为场景实现的特定质量属性要求的优先级列表</li>
<li class="lvl-9">Utility Tree 质量属性效用树</li>
<li class="lvl-9">风险点和无风险点</li>
<li class="lvl-9">敏感点和权衡点</li>
</ol>
</li>
<li class="lvl-6">阶段-2：评估-2
<ol>
<li class="lvl-9">涉众们的优先级场景列表</li>
<li class="lvl-9">风险主题和业务驱动因素各自受到的威胁</li>
</ol>
</li>
<li class="lvl-6">阶段-3：后续
<ol>
<li class="lvl-9">最终的评估报告</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】描述在 ATAM 的每一个过程中 有哪些 Stack holder 和他们的职责</p>
<ol>
<li class="lvl-6">阶段-0：准备和建立团队
<ol>
<li class="lvl-9">参与者：评估团队领导和关键项目决策者</li>
<li class="lvl-9">职责：根据架构设计文档生成评估计划，包括谁参加评估、如何何时何地开展评估、最后评估报告会被呈递给谁。</li>
</ol>
</li>
<li class="lvl-6">阶段-1：评估-1
<ol>
<li class="lvl-9">参与者：评估团队和项目决策者</li>
<li class="lvl-9">职责：
<ol>
<li class="lvl-12">第一步，评估负责人介绍 ATAM 方法</li>
<li class="lvl-12">第二步，项目经理或客户从业务角度介绍业务驱动因素</li>
<li class="lvl-12">第三步，首席架构师介绍体系结构</li>
<li class="lvl-12">第四步，评估团队确定架构方法</li>
<li class="lvl-12">第五步，评估团队和项目决策者生成质量属性效用树 (Utiltiy Tree)</li>
<li class="lvl-12">第六步，评估团队分析架构方法</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">阶段-2：评估-2
<ol>
<li class="lvl-9">参与者：评估团队、项目决策者和项目涉众</li>
<li class="lvl-9">职责：
<ol>
<li class="lvl-12">第一步，评估负责人介绍 ATAM 方法和之前已经取得的成果</li>
<li class="lvl-12">第七步，涉众头脑风暴并确定场景优先级</li>
<li class="lvl-12">第八步，评估团队分析架构方法，类似第六步</li>
<li class="lvl-12">第九步，评估团队展示评估结果，并呈递给涉众</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">阶段-3：后续
<ol>
<li class="lvl-9">参与者：评估团队、主要涉众</li>
<li class="lvl-9">职责：评估团队制作最终评估报告，发给主要涉众审核通过后，将报告呈递给委托评估的人。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 【2015】【2019】软件架构来自哪里？列举五种可能的软件架构的来源 Where do software architecture come from? List five possible sources of software architecture.</p>
<ol>
<li class="lvl-9">NFRs - 非功能性需求</li>
<li class="lvl-9">ASRs</li>
<li class="lvl-9">涉众</li>
<li class="lvl-9">技术环境</li>
<li class="lvl-9">业务目标</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2015】【2019】解释代理架构模式的上下文、好处和局限性。Explain the context, benefits and limitations of Broker Architecture Pattern.</p>
<ol>
<li class="lvl-7">上下文：多个<strong>同步或异步交互</strong>的<strong>远程对象组成的系统</strong>，broker协调多个客户机和服务器之间的通讯。</li>
<li class="lvl-7">好处：提高了 Client 和 Server 之间的交互性、提高可伸缩性和可扩展性、解决了单体应用的性能瓶颈、大规模集群的性能提高，但是单点性能会下降。</li>
<li class="lvl-7">局限性：代理增加了前期复杂度、可能成为通信的屏障、可能成为攻击的目标、难以测试。</li>
<li class="lvl-7">SOA 延续了 broker 的思想，查找服务和使用服务都要通过 broker，而 SOA 只在查找时通过 register，分散了 broker 的职责，降低了单点风险。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】【2023】Layered pattern 和 Multi-tier pattern 的区别</p>
<ol>
<li class="lvl-7">Layered Pattern 是 Module Style，而 Multi-tier Pattern 是 Allocation Style</li>
<li class="lvl-7">Layered Pattern 是将任务拆解成一个个处于特定抽象级别的子层次，每层为上一层提供服务，核心是关注点分离。</li>
<li class="lvl-7">Multi-tier Patten 中的层是逻辑的组合，没有层次模式的强依赖关系，在不同部署环境中分层不同但是软件完成的内容一致。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2017】【2019】【2022】【2023】在设计软件时应用了哪些<strong>通用设计策略</strong>？为每个策略提供一个带有软件架构的简明工作示例。What are generic design strategies applied in designing software? Give a concise working example with software architecture for each strategy.</p>
<ol>
<li class="lvl-7">抽象：关注本身结构而不关心实现，比如将系统抽象为组件和连接件或抽象为模块。</li>
<li class="lvl-7">分解：比如将整个系统分解或将某个模块分解。</li>
<li class="lvl-7">分而治之：将每个模块分别处理</li>
<li class="lvl-7">生成与测试：将一个特定的设计看作是一个假设；根据测试路径生成测试用例。</li>
<li class="lvl-7">迭代与细化：如 ADD 方法多次迭代直到满足所有 ASR</li>
<li class="lvl-7">复用元素：重用在设计过程中出现了可以复用的元素，重用现有架构</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2017】【2019】什么是 ASR？列出提取和识别 ASR 的四种来源和方法。What are ASR? List four sources and methods for extracting and identifying ASRs.</p>
<ol>
<li class="lvl-7">ASRs 架构攸关需求是对架构产生深远影响的需求</li>
<li class="lvl-7">四种来源和方法：
<ol>
<li class="lvl-10">从需求文档中收集 ASR：MoScoW 方法和用户故事</li>
<li class="lvl-10">通过采访涉众来收集 ASR：质量属性工作坊 (QAW)Quality Attribute Workshop</li>
<li class="lvl-10">通过了解业务目标来收集 ASR：</li>
<li class="lvl-10">通过质量属性效用树 (Utility Tree) 来收集 ASR*：逐渐对质量属性进行分解细化，直到包含量化指标为止。*</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2017】【2019】典型的软件架构文档包中应该包含哪些内容？简要描述每个组件及其用途。What should be included in a typical software architecture documentation package? Briefly describe each component and its purpose.</p>
<ol>
<li class="lvl-7"><strong>包含 View 和 Beyond</strong></li>
<li class="lvl-7">Beyond 部分：
<ol>
<li class="lvl-10">文档路线图：包含了范围和总结、简单摘要等。</li>
<li class="lvl-10">视图的文档组织方式：描述了本文档中视图是如何组织的。</li>
<li class="lvl-10">系统概述：从整体上描述了当前架构的简要说明、业务目标 ( 驱动因素 ) 等等。</li>
<li class="lvl-10">视图之间的映射关系：描述了不同视图之间的映射关系。</li>
<li class="lvl-10">系统原理：从整体上描述了当前架构的设计原理。</li>
<li class="lvl-10">目录-索引、词汇表、首字母缩略词表。</li>
</ol>
</li>
<li class="lvl-7">View 部分
<ol>
<li class="lvl-10">styles and views( 体系结构风格和视图 )</li>
<li class="lvl-10">Structural views
<ol>
<li class="lvl-13">module viwes</li>
<li class="lvl-13">C &amp; C views</li>
<li class="lvl-13">Allocation views</li>
</ol>
</li>
<li class="lvl-10">Quality Views</li>
</ol>
</li>
<li class="lvl-7">每一个 View 的内容
<ol>
<li class="lvl-10">主要介绍：显示视图的元素和关系，以及图例</li>
<li class="lvl-10">元素介绍，详细介绍第一部分中描述的元素、元素属性、关系属性和元素接口和行为。</li>
<li class="lvl-10">上下文图：描述系统如何与环境相关</li>
<li class="lvl-10">可变性指导：告知视图中可能出现的变化</li>
<li class="lvl-10">基本原理：解释设计如何映射在视图中，以及其合理性。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2015】描述架构设计中架构模式和tactics 之间的关系。给出可以在架构设计过程中使用的任何四种决策的名称，并描述每种决策的目的。Describe the relationships between architectual patterns and tactics in architecture design. Give name of any four tactics that can be used during architecture design and describe the purpose of each of them.</p>
<ol>
<li class="lvl-7">架构模式与tactics 之间的关系
<ol>
<li class="lvl-10">tactics 比模式更简单，使有单一的结构或机制来应对单一的架构驱动</li>
<li class="lvl-10">tactics 是构成架构模式的重要组成部分</li>
<li class="lvl-10">架构模式通常将许多个tactics 组合在一起。</li>
<li class="lvl-10">大多数架构模式都包含不同的tactics ，这些tactics 可能有共同的目的或者常被用于实现不同的质量属性。</li>
<li class="lvl-10">tactics 和架构模式共同构成了软件设计时的工具。</li>
</ol>
</li>
<li class="lvl-7">四种决策的名称</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2015】简要描述面向服务架构 (SOA) 的基本原则，并讨论 SOA 对互操作性、可伸缩性和安全性等质量属性的影响 Briefly describe the fundamental principles of Service Oriented Architecture(SOA) and discuss the impact of SOA on quality attributes like interoperability, scalability and security</p>
<ol>
<li class="lvl-7">SOA 的基本原则
<ol>
<li class="lvl-10">服务解耦：服务之间的关系最小化，只是相互知道接口</li>
<li class="lvl-10">服务契约:服务按照描述文档所定义的服务契约行事</li>
<li class="lvl-10">服务封装:除了服务契约所描述内容，服务将对外部隐藏实现逻辑</li>
<li class="lvl-10">服务重用:将逻辑分布在不同的服务中，以提高服务的重用性</li>
<li class="lvl-10">服务组合:一组服务可以协调工作，组合起来形成定制组合业务</li>
<li class="lvl-10">服务自治:服务对所封装的逻辑具有控制权</li>
<li class="lvl-10">服务无状态:服务将一个活动所需保存的资讯最小化</li>
</ol>
</li>
<li class="lvl-7">SOA 对互操作性的影响
<ol>
<li class="lvl-10">SOA 具有更高的互操作性：符合开放标准，可以更好的重用服务</li>
<li class="lvl-10">支持服务的自动识别、发现、注册和调用等等</li>
</ol>
</li>
<li class="lvl-7">SOA 对可伸缩性的影响
<ol>
<li class="lvl-10">SOA 具有更高的可伸缩性：服务自身高内聚、服务间松耦合，最小化维护的影响</li>
<li class="lvl-10">但是 SOA 也会带来系统复杂度较高的问题</li>
</ol>
</li>
<li class="lvl-7">SOA 对安全性的影响：
<ol>
<li class="lvl-10">中间件可能会成为性能的瓶颈</li>
<li class="lvl-10">ESB 等中间件都可以成为被攻击的目标</li>
<li class="lvl-10">多服务导致攻击的跟踪、溯源和防御成为困难。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2019】【2023】微服务和 SOA 的区别，相同点</p>
<ol>
<li class="lvl-7">相同点：微服务和 SOA 都是分布式架构，微服务架构可以看作是SOA的一种实现方式，适用于更小规模和更灵活的应用系统。都包含了服务契约、服务封装、服务重用、服务组合、服务自治和服务无状态等基本特点。</li>
<li class="lvl-7">微服务去掉了 SOA 架构中的 ESB(Enterprise Service Bus) 企业服务总线，采用轻量级通信机制 (HTTP、REST) 进行服务之间的通信。</li>
<li class="lvl-7">微服务引入了熔断器：避免出现服务失效或网络问题等导致的级联故障。</li>
<li class="lvl-7">部署和扩展：在SOA中，整个应用程序通常作为一个单元进行部署和扩展。而在微服务架构中，每个微服务可以独立部署和扩展，使得系统具有更好的弹性和可伸缩性。</li>
<li class="lvl-7">服务粒度：在SOA中，服务的粒度可以比较大，一个服务可能涵盖多个相关的业务功能。而在微服务架构中，服务的粒度更小，每个服务通常专注于一个特定的业务功能。</li>
<li class="lvl-7">组织和治理：SOA通常需要涉及企业范围内的中央治理和管理，**不能控制独立服务的演变。**而微服务架构强调团队的自治性，<strong>每个微服务可以由一个独立的团队进行开发和管理，更加注重服务的自治性和快速迭代</strong>。</li>
</ol>
</li>
<li class="lvl-4">
<p>【2017】<strong>软件设计的三个变化维度，每个维度的变化点。不同的绑定时间如何影响可修改性和可测试性</strong>。</p>
<ol>
<li class="lvl-7">三个变化维度：
<ol>
<li class="lvl-10">面向对象 OOP，强调重用性、灵活性和扩展性。</li>
<li class="lvl-10">面向方面 AOP，满足扩展的需求，可以在程序中自由的扩展功能</li>
<li class="lvl-10">面向服务 SOA，是系统发布功能的一种方式，且基于这种方式下不同的系统之间可以有效的沟通、协作。</li>
</ol>
</li>
<li class="lvl-7">设计时，开发时，测试时，发布时，运行时：可修改性降低，可测试性升高</li>
</ol>
</li>
<li class="lvl-4">
<p>✅【2018】<strong>软件架构的关注点有哪些</strong>？利益相关方有哪些？</p>
<ol>
<li class="lvl-7">软件架构的关注点
<ol>
<li class="lvl-10">利益相关者 Stakeholders addressed</li>
<li class="lvl-10">解决的问题 Concerns addressed</li>
<li class="lvl-10">语言，建模技巧 Language, modeling techniques</li>
<li class="lvl-10">策略，模式 Tactics, Pattern</li>
</ol>
</li>
<li class="lvl-7">利益相关方有哪些？
<ol>
<li class="lvl-10">顾客 Customer</li>
<li class="lvl-10">用户 User</li>
<li class="lvl-10">架构师 Architect</li>
<li class="lvl-10">需求工程师 Requirements engineer</li>
<li class="lvl-10">设计师 Designer</li>
<li class="lvl-10">实施者 Implementer</li>
<li class="lvl-10">测试师，集成师 Tester, integrator</li>
<li class="lvl-10">维护者 Maintainer</li>
<li class="lvl-10">产品经理 Product manager</li>
<li class="lvl-11">质量保证人 Quality assurance people</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】【2022】Software requirements, Quality attributes, ASRs 的区别和联系</p>
<ol>
<li class="lvl-7">软件需求包括功能性需求和非功能性需求（又称质量需求）</li>
<li class="lvl-7">质量属性是由软件的业务目标所决定，在功能性需求的基础上提供的整个系统的合乎需求的特性，是非功能需求的一种体现。</li>
<li class="lvl-7">ASRs 架构攸关需求是对于体系结构有着深远影响的需求，肯定是软件需求的一部分。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】描述 ADD 过程</p>
<p><strong>输入</strong>：需求，<strong>输出</strong>：软件元素 - 角色 - 职责 - 属性 - 关系</p>
<ol>
<li class="lvl-7">
<p>确定有足够的需求信息</p>
</li>
<li class="lvl-7">
<p>选择要分解的系统要素</p>
</li>
<li class="lvl-7">
<p>确定所选的元素的 ASR</p>
</li>
<li class="lvl-7">
<p>选择符合 ASR 的设计</p>
<ol>
<li class="lvl-10">找出设计问题</li>
<li class="lvl-10">列出子关注点替代模式/策略</li>
<li class="lvl-10">从清单中选择模式/策略</li>
<li class="lvl-10">确定模式/策略与 ASR 之间的关系</li>
<li class="lvl-10">记录初步的架构视图</li>
<li class="lvl-10">评估并解决不一致的问题</li>
</ol>
</li>
<li class="lvl-7">
<p>实例化架构元素并分配职责</p>
</li>
<li class="lvl-7">
<p>实例化元素定义接口</p>
</li>
<li class="lvl-7">
<p>验证和完善需求</p>
</li>
<li class="lvl-7">
<p>重复进行 2-7 步直到满足所有的 ASR</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2019】Architecture，structure 和 Design 的区别？</p>
<ol>
<li class="lvl-7">Design 包含 Architecture，Architecture 包含 Structure</li>
<li class="lvl-7">结构是静态的、逻辑的，是关于系统如何构成的</li>
<li class="lvl-7">Architecture除包含structure ，还会包含组件之间的相关的关系结构，并定义一些动态的行为。</li>
<li class="lvl-7">所有体系结构都是设计，但是不是所有的设计都是体系结构，体系结构是软件设计的一个部分</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】【2019】【2022】Risks，Senstivity Points，Trade-Off Points 分别是什么？各举一个例子。</p>
<ol>
<li class="lvl-7">识别风险：发现可能对所需质量属性产生负面影响的架构决策，例如使用分层模式可能带来性能损耗。</li>
<li class="lvl-7">发现权衡：影响多个质量属性的架构决策，例如使用分层模式可能会带来性能损耗，但是增加系统的可修改性。</li>
<li class="lvl-7">发现敏感点：特定质量属性对其敏感的架构决策，比如在对性能敏感的系统中，决定使用缓存中间件。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 软件架构风格</p>
<ol>
<li class="lvl-7">module Styles：认为体系结构是由模块组成。模块是实现单元的集合，它提供了一组一致的职责。</li>
<li class="lvl-7">C &amp; C Styles 认为体系结构是由组件 ( 主要的处理单元和数据存储 )、连接件 ( 组件之间的交互路径 ) 组成的。</li>
<li class="lvl-7">Allocation Styles 认为体系结构是由软件元素 ( 软件元素具有环境所需的属性 ) 和环境元素 ( 环境元素有提供给软件的属性 ) 组成的，展示了软件如何与环境关联。</li>
</ol>
</li>
<li class="lvl-4">
<p>架构模式是：⼀个架构模式是⼀组架构设计决定，这些决定适用于重复出现的设计问题，并被参数化以考虑出现该问题的不同软件开发上下文。</p>
</li>
<li class="lvl-4">
<p>软件架构是程序或计算系统的结构，由软件元素、这些元素外部可⻅的属性、这些元素的关系组成</p>
</li>
<li class="lvl-5">
<p>架构模式：{问题，上下文} → 架构方法。架构风格具体到常见的问题和上下文，就叫做架构模式</p>
</li>
</ol>
<h2 id="1-2-设计模式">1.2. 设计模式</h2>
<ol>
<li class="lvl-3">
<p>【2017】请至少说出三个面向对象的原则，并解释它们如何应用于策略模式？ Please name at least three Object-Oriented principles, and explain how they are applied in Strategy pattern?</p>
<ol>
<li class="lvl-6">单一职责原则</li>
<li class="lvl-6">开闭原则</li>
<li class="lvl-6">里氏代换原则</li>
<li class="lvl-6">合成复用原则</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】设计模式是什么？举例说明类模式和对象模式的区别？</p>
<ol>
<li class="lvl-6">什么是设计模式：
<ol>
<li class="lvl-9">(PPT)<strong>设计模式 (Design Pattern)<strong>是</strong>一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</li>
</ol>
</li>
<li class="lvl-6">设计模式分类
<ol>
<li class="lvl-9">根据其目的 ( 模式是用来做什么的 ) 可分为创建型 (Creational)，结构型 (Structural) 和行为型 (Behavioral) 三种：
<ol>
<li class="lvl-12">创建型模式主要用于创建对象。</li>
<li class="lvl-12">结构型模式主要用于处理类或对象的组合。</li>
<li class="lvl-12">行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。</li>
</ol>
</li>
<li class="lvl-9">根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：
<ol>
<li class="lvl-12">类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。</li>
<li class="lvl-12">对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】防御式编程是什么？断言和错误处理的区别？</p>
<ol>
<li class="lvl-6">可以预见到（至少预先推测到）问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施，来防止类似的意外的发生。</li>
<li class="lvl-6">断言和错误处理的区别
<ol>
<li class="lvl-9">断言是在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏。断言不可以有副作用。</li>
<li class="lvl-9">错误处理是对预先已经考虑到的错误 ( 如用户错误、程序错误、意外情况等等 ) 按照流程进行处理。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】设计模式对 MVC 的影响？</p>
<ol>
<li class="lvl-6">MVC 模式使用了运行时、动态和相互之间的关系集成到开发框架中，是分层模式的变种。
<ol>
<li class="lvl-9">分为 model（业务逻辑）、view（处理用户展示，接收用户操作）、controller（对用户操作进行处理，将信息通知给 model）（强调模块间约束关系，model 不可以直接返回到 controller）</li>
<li class="lvl-9">优点：耦合性低，重用性高，生命周期成本低，部署快，可维护性高，方便管理</li>
<li class="lvl-9">缺点：没有明确定义，不适于中小型应用程序，增加实现复杂度，视图和控制器过于紧密，视图对模型访问低效。</li>
</ol>
</li>
<li class="lvl-6">四人书中，MVC 模式是观察者模式、策略模式和组合模式的演化，可能涉及到工厂模式和装饰器模式
<ol>
<li class="lvl-9">基于推送-订阅模式</li>
<li class="lvl-9">观察者：model 发生变化通知 controller，然后更新 view</li>
<li class="lvl-9">策略模式：controllers 帮助 views 对不同用户的输入做不同的响应。</li>
<li class="lvl-9">组合模式：一组 views</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】【2023】策略模式和状态模式的区别？</p>
<ol>
<li class="lvl-6">在状态模式中，具体状态类的方法参数中包含上下文对象，需要在状态处理完成后完成状态切换。</li>
<li class="lvl-6">在策略模式中，直接对上下文类调用 set 方法设置策略即可，不涉及到策略的切换。</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】最小知识原则在设计模式中的应用？</p>
<ol>
<li class="lvl-6">中介者模式</li>
<li class="lvl-6">外观模式</li>
</ol>
</li>
<li class="lvl-3">
<p>【2022】Please explain the Liskov Substitution Principle and how it contributes to the Open- Closed Principle</p>
<ol>
<li class="lvl-6">LSP要求子类能够完全替代父类，而不会破坏原有系统的行为</li>
<li class="lvl-6">LSP对于开闭原则（Open-Closed Principle，OCP）的贡献在于，它确保了代码的可扩展性。OCP要求软件实体应该对扩展开放，对修改关闭。当我们遵循LSP时，可以通过添加新的子类来扩展系统的功能，而无需修改已有的代码。因为子类完全替代父类，所以可以将新的子类对象传递给原有代码，而不会影响原有代码的正确性。这样，我们可以通过增加新的子类来实现系统的扩展，同时保持原有代码的稳定性和一致性</li>
</ol>
</li>
<li class="lvl-3">
<p>【2022】【2023】观察者设计模式中有两种方法用于向观察者传播数据：推模型（Push Model）和拉模型（Pull Model）。为什么有些情况下一个模型会比另一个模型更可取？每个模型的权衡是什么？</p>
<p>推模型和拉模型的选择取决于应用程序的需求和设计考虑。下面是每个模型的优势和权衡：</p>
<p>推模型：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>优势：</p>
<ol>
<li class="lvl-8">简单直接：数据由主题（被观察者）直接推送给观察者，观察者不需要主动请求数据。</li>
<li class="lvl-8">即时性：数据推送是实时的，观察者可以立即收到最新的数据更新。</li>
</ol>
</li>
<li class="lvl-5">
<p>权衡：</p>
<ol>
<li class="lvl-8"><strong>无法控制数据量</strong>：在推模型中，主题通常将所有数据推送给所有观察者，无论观察者是否需要这些数据。这可能会导致数据传输过程中的浪费。</li>
<li class="lvl-8">安全性和隐私问题：如果数据包含敏感信息，推模型可能会引发安全和隐私问题，因为数据在推送过程中可能会被截获或访问到。</li>
</ol>
</li>
</ul>
<p>拉模型：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>优势：</p>
<ol>
<li class="lvl-8">灵活性：观察者可以根据需要主动拉取所需的数据，可以减少不必要的数据传输。</li>
<li class="lvl-8">数据控制：观察者可以根据具体情况控制拉取数据的频率和量，从而减少网络带宽和资源消耗。</li>
</ol>
</li>
<li class="lvl-5">
<p>权衡：</p>
<ol>
<li class="lvl-8"><strong>延迟性</strong>：拉模型需要观察者主动发起请求才能获取数据，可能会引入一定的延迟。</li>
<li class="lvl-8">实时性限制：观察者只能获取其主动请求的数据更新，无法立即获知所有最新的数据。</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-3">
<p>【2022】What is the difference between the categories of Creational Patterns and Structural<br>
Patterns</p>
<ol>
<li class="lvl-6">
<p>创建型模式（Creational Patterns）和结构型模式（Structural Patterns）是面向对象设计中的两个主要模式分类。</p>
<p>创建型模式关注<strong>对象的创建机制和实例化过程</strong>，主要用于解决对象的创建和初始化的问题。这些模式将对象的创建与使用代码解耦，使得系统更加灵活和可扩展。创建型模式的例子包括工厂模式、抽象工厂模式、单例模式、建造者模式和原型模式等。</p>
<p>结构型模式关注<strong>对象之间的组合和关联关系</strong>，主要用于描述对象和类之间的静态结构和组织方式。这些模式通过定义类和对象之间的关系，提供了一种实现系统组件之间协作的方式。结构型模式的例子包括适配器模式、装饰器模式、代理模式、组合模式、外观模式、桥接模式和享元模式等。</p>
<p>行为型模式关注<strong>对象之间的交互和职责分配</strong>，可以减少对象间的耦合度，提高系统的灵活性和可扩展性。行为型模式的例子包括观察者模式、策略模式、模板方法模式、命令模式、迭代器模式、状态模式、访问者模式和解释器模式等。</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>类模式和对象模式</p>
<ol>
<li class="lvl-7">
<p>类模式是指应用于类层次结构的设计模式。它们关注的是类之间的关系、继承和接口的使用。类模式描述了类之间的静态关系和结构，以及如何通过类的继承、组合和接口实现来达到设计目标。类模式通常通过继承、抽象类、接口等来实现类之间的关系，以及类的行为和功能。</p>
<p>对象模式是指应用于对象层次结构的设计模式。它们关注的是对象之间的交互、通信和协作。对象模式描述了对象之间的动态行为和相互作用方式，以实现特定的功能和行为。对象模式通常通过对象之间的关联、委托、组合、观察者等方式来实现对象的交互和通信。</p>
</li>
<li class="lvl-7">
<p>工厂方法模式注重对象的创建和实例化过程，它通过子类化来延迟具体对象的创建，被归类为类模式。而抽象工厂模式注重对象之间的关联关系和组合，它的目标是提供一种统一的方式来创建<strong>一系列相关的对象</strong>，被归类为对象模式</p>
</li>
<li class="lvl-7">
<p>由于模板方法模式主要通过基类和子类之间的继承关系来定义算法的框架结构，强调了类之间的静态关系和结构，所以被归类为类模式。</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>【2021】软件模式是什么？能提供架构吗？</p>
<ol>
<li class="lvl-7">虽然软件模式提供了一些通用的设计思路和原则，但具体的架构设计需要结合具体的问题和需求进行选择和应用。架构设计涉及系统的整体结构、组件之间的关系、数据流和交互方式等方面，需要<strong>综合考虑系统的功能需求、性能要求、可扩展性、安全性等因素</strong>。因此，软件模式可以作为设计架构的参考和指导，但最终的架构设计需要根据具体情况进行灵活调整和优化。</li>
</ol>
</li>
<li class="lvl-4">
<p>【2023】装饰者模式为什么比用子类扩展功能有更好的灵活性？</p>
</li>
<li class="lvl-4">
<p>【2023】为什么最小知识原则可以帮助构建高内聚、低耦合的系统？用代码举一个违背的例子</p>
</li>
<li class="lvl-4">
<p>【2022】【2023】What is the benefit of decoupling the Receiver from the Invoker in the Command Pattern?</p>
</li>
</ol>
<h1>2. 设计题</h1>
<ol>
<li class="lvl-3">
<p>【2019】一个游戏，有几种人类角色：骑士、骑兵、步兵，持有不同的武器 ( 矛、剑、斧 )，拥有 fight 方法；有一个非人类角色巨魔，可以持有武器，但攻击方法不同 (beat)。现在希望让巨魔和其他人类角色一起进行游戏，并且要求有角色死亡时其他活着的角色要收到通知。运用设计模式进行设计，并画出类图。</p>
</li>
<li class="lvl-3">
<p>【2019】表驱动，参考 PPT 即可。</p>
</li>
<li class="lvl-3">
<p>【2019】架构设计，没太看懂……大概是分析程序结构生成报告？</p>
</li>
<li class="lvl-3">
<p>【2018】设计一个飞行模拟软件，要求能模拟多种飞机的特性。为了在将来支持更多飞机种类，要求使用策略模式。画出架构图和类图</p>
</li>
<li class="lvl-3">
<p>【2019】一个买票系统的设计题，不同的角色有不同的打折方案，用策略模式设计， 最后画图，还要说明策略模式的使用场景。</p>
</li>
<li class="lvl-3">
<p>【2021】【2023】设计⼀个基于管道-过滤器模式的、输⼊⽂本⽂件、输出排序后的⽆重复的单词列表的程序。 1. ⽤组件部分和连接器画出程序图。 2. 画出组件的类图。 3. ⽤ Java 实现每个类。 4. 指出你的代码和 1、2 中图的映射</p>
</li>
<li class="lvl-3">
<p>【2023】设计一个系统，有很多的机器人，他们有不同的功能，在未来会拓展这些功能或功能的复杂性，同时有一批保留了旧接口的老机器人，也希望能加入到这个系统中。系统还能将所有的机器人看作一个 unit 来统一的控制。1. 列出使用的设计模式和类图 2.说明你的设计如何有利于未来拓展功能</p>
</li>
</ol>
<p>【2015】【2019】【2022】</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/2.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/1.png" alt=""></p>
<h1>3. 其他知识点</h1>
<ol>
<li class="lvl-3">
<p>什么是软件系统架构：是结构和系统结构，包含了软件元素，这些组件的外部可视化属性和他们之间的关系（包含组件的行为）</p>
</li>
<li class="lvl-3">
<p>几个概念</p>
<ol>
<li class="lvl-6">功能性需求：定义系统必须做什么，并且强调系统如何提供价值给涉众。</li>
<li class="lvl-6">质量需求：系统应在功能性需求之上提供的整个系统的合乎需求的特性。</li>
<li class="lvl-6">策略：是影响质量属性相应控制的设计决策，比如冗余。</li>
</ol>
</li>
<li class="lvl-3">
<p>架构模式</p>
<ol>
<li class="lvl-6">背景、上下文（Context）：世界上经常发生问题的场景。</li>
<li class="lvl-8">问题（Problem）：在给定上下文中出现经过适当概括的问题。</li>
<li class="lvl-8">解决方案（Element + Relations + Constraints）：针对问题的成功的经过适当抽象的解决方案。</li>
</ol>
</li>
<li class="lvl-3">
<p>ADD 的输出</p>
<ol>
<li class="lvl-6">软件元素：完成各种决策和职责、定义属性并与其他软件元素相关以组成系统架构的计算或开发工件。</li>
<li class="lvl-6">角色：一组相关的职责。</li>
<li class="lvl-6">职责：软件提供的功能、数据或信息。</li>
<li class="lvl-6">属性：有关软件元素的附加信息。</li>
<li class="lvl-6">关系：两个软件元素之间如何相互关联和交互的定义。</li>
</ol>
</li>
<li class="lvl-3">
<p>如何选择视图</p>
<ol>
<li class="lvl-6">构建涉众/视图表</li>
<li class="lvl-6">合并视图</li>
<li class="lvl-6">确定优先级和完成阶段</li>
</ol>
</li>
<li class="lvl-3">
<p>什么是微服务：是分布式架构，SOA 的一种扩展</p>
<ol>
<li class="lvl-6">微服务架构风格是一种将一个单一应用开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制，这些服务围绕业务能力构建并可以通过自动部署机制独立部署。</li>
<li class="lvl-6">微服务特点
<ol>
<li class="lvl-9">服务颗粒化:服务粒度由业务功能决定，服务间尽可能解耦</li>
<li class="lvl-9">责任单一化:单一职责原则，服务内尽可能内聚</li>
<li class="lvl-9">运行隔离化:服务运行在各自进程中，互不影响</li>
<li class="lvl-9">管理自动化:对服务提供自动化部署与监控预警能力，高效管理</li>
</ol>
</li>
<li class="lvl-6">微服务核心模式：针对采用微服务系统在特定问题所使用的程序的架构解决方案的集合
<ol>
<li class="lvl-9">服务注册与发现</li>
<li class="lvl-9">API 网关</li>
<li class="lvl-9">熔断器</li>
</ol>
</li>
<li class="lvl-6">微服务的挑战
<ol>
<li class="lvl-9">运维要求高:微服务数量多，部署与监控要求高</li>
<li class="lvl-9">发布复杂度:部署环境多样化，网络性能系统容错、分布式事务等挑战</li>
<li class="lvl-9">部署依赖强:服务间相互调用关系复杂，存在部署顺序依赖</li>
<li class="lvl-9">通信成本高:跨进程调用比进程内调用消耗更多的资源</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>面向对象设计原则</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/6.png" alt=""></p>
<ol start="8">
<li class="lvl-3">
<p>设计原则</p>
<ol>
<li class="lvl-7">目标：开闭原则</li>
<li class="lvl-7">指导：最小知识原则</li>
<li class="lvl-7">基础：单一职责原则、可变性封装原则</li>
<li class="lvl-7">实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li>
</ol>
</li>
<li class="lvl-3">
<p>模式一般都有的缺点</p>
<ol>
<li class="lvl-7">增加设计的复杂性和增加类的个数 ( 增加辅助类 )</li>
<li class="lvl-7">增加隔阂、方法调用，降低软件运行的效率，但是已经不是目前主要的问题</li>
</ol>
</li>
<li class="lvl-4">
<p>引入设计模式的作用</p>
<ol>
<li class="lvl-10">设计模式提供了与其他开发人员共享的词汇表。</li>
<li class="lvl-10">通过在模式级别（而不是实质性对象级别）进行思考，提高对体系结构的思考（但不要迷失在细节中）</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/7.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/8.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/9.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/10.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/11.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/12.png" alt=""></p>
<ol>
<li class="lvl-4">
<p>防御式编程</p>
<ol>
<li class="lvl-7">防御式编程：可以预见到（或至少预先推测到）问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施，来防止类似意外的发生。</li>
<li class="lvl-7">断言：在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏。断言不可以有副作用。</li>
<li class="lvl-7">异常：是将代码中的错误或异常事件传递给调用方代码的一种特殊手段，谨慎使用可以降低复杂度。</li>
<li class="lvl-7">错误处理：根据软件类别平衡正确性和健壮性（哪个优先级更高）</li>
<li class="lvl-7">隔离程序：隔离程序是以防御式编程为目的而进行隔离的一种方法，将某些接口选定为“安全”区域的边界，对穿越安全区域边界的数据进行合法性检验（集中工作在特定的模块中降成本）</li>
<li class="lvl-7">辅助调试代码：辅助进行代码调试的代码，帮助快速检查错误，应该尽早地引入辅助调试代码。</li>
<li class="lvl-7">攻击式编程：主动暴露出可能出现的错误，在开发阶段将其暴露显现出来，而在产品代码运行时让他能够自我恢复。</li>
</ol>
</li>
<li class="lvl-4">
<p>表驱动法：一种编程模式</p>
<ol>
<li class="lvl-7">目的：表驱动法适用于复杂逻辑，将复杂逻辑从代码中独立出来方便单独维护</li>
<li class="lvl-7">原理：从表里面查找信息而不使用逻辑语句 (if 和 else)</li>
<li class="lvl-7">具体实现
<ol>
<li class="lvl-10">直接访问表：直接通过索引值可以从表中找到对应的条目</li>
<li class="lvl-10">索引访问表：首先从索引表中找到数据表的地址，然后再从数据表中找到对应的条目 ( 节省空间、管理廉价、容易维护 )</li>
<li class="lvl-10">阶梯访问表：根据每项命中的阶梯层次来确定其归属</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>装饰者的两个缺点：很多小类、难以排查错误</p>
</li>
<li class="lvl-4">
<p>增加新的鸭叫统计次数 ( 不允许修改原本代码 )：装饰器模式</p>
</li>
</ol>
<h1>4. 选择模式</h1>
<ol>
<li class="lvl-3">
<p>一个温度系统有 3 个恒温器，一个恒温器可以调整和显示温度，2 个恒温器只能手动调节，1 个恒温器可以手动、计时器调节：中介者、策略</p>
<ol>
<li class="lvl-6">模板方法：先调整、再显示 ( 用户直接复用模板方法，而本例中复用的是实现 )</li>
</ol>
</li>
<li class="lvl-3">
<p>一个队伍有 1 个管理者和 25 个队员，每一个队员可以有一个位置，有的特别强的队员可以有多个位置：策略、原型</p>
<ol>
<li class="lvl-6">策略独立于 Player，所以 Player 是一样的</li>
<li class="lvl-6">模板方法模式是解决步骤的问题</li>
</ol>
</li>
<li class="lvl-3">
<p>积分会员制，积分比较高则为高级会员，积分比较低则为低级会员</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件系统设计</category>
      </categories>
      <tags>
        <tag>软件系统设计</tag>
        <tag>课程</tag>
      </tags>
  </entry>
</search>
