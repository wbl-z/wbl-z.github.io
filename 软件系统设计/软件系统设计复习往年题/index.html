<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="技术，编程，代码，教程，Java" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>软件系统设计复习往年题 |  wbl-z&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/logo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?edcb9d2dbc760f6eeab5900f9b363881";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-软件系统设计复习往年题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  软件系统设计复习往年题
</h1>
 

      
    <div class="article-author"  style="text-align: center ;font-size:20px" >
        作者： zzb
    </div>


    </header>
     
    <div class="article-meta">
      <a href="/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E5%BE%80%E5%B9%B4%E9%A2%98/" class="article-date">
  <time datetime="2023-06-17T14:02:10.000Z" itemprop="datePublished">2023-06-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">软件系统设计</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">34 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="软件系统设计复习往年题-2023回忆">软件系统设计复习往年题+2023回忆</h2>
<blockquote>
<p>参考自 zhy 的博客 <a target="_blank" rel="noopener" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Exam0-%E5%BE%80%E5%B9%B4%E8%80%83%E8%AF%95/">2021-软件系统设计-Exam0-往年考试 - SpriCoder的博客</a></p>
<p>feat: 新增2023回忆，修改原来的部分回忆题</p>
</blockquote>
<h1>1. 简答题</h1>
<h2 id="1-1-软件系统架构">1.1. 软件系统架构</h2>
<ol>
<li class="lvl-4">
<p>✅ 【必考】如何进行质量属性方案建模？请使用&quot;刺激-相应&quot;图的格式进行建模 How to model quality attribute scenarios? Graphically model one quality attributes in “stimulus-response” format:</p>
</li>
<li class="lvl-6">
<p>【2015】availiability and Performance</p>
</li>
<li class="lvl-6">
<p>【2017】【2018】availiability and modifiability</p>
</li>
<li class="lvl-6">
<p>【2019】interoperability and modifiability</p>
</li>
<li class="lvl-6">
<p>如何进行质量属性方案建模</p>
<ol>
<li class="lvl-9">刺激（Stimulus）：当其到达系统时需要考虑的状况。</li>
<li class="lvl-9">刺激源（Source of Stimulus）：产生刺激的实体（人，系统或任何其他触发），可能是输入、信息等，对当前的状态的一个变化。</li>
<li class="lvl-9">响应（Response）：刺激到来后工件开展的行为。</li>
<li class="lvl-9">响应度量（Response Measure）：对刺激的响应以某种方法进行测量，以便可以<strong>测试需求</strong>（比如多长时间系统有反馈）</li>
<li class="lvl-9">环境（Environment）：发生刺激时系统的状况，例如系统正常运行、系统过载、系统受到攻击、系统网络出现故障等。</li>
<li class="lvl-9">工件（Artifact）：完成需求的整个系统或者系统的一部分（软件制品）。</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/3.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>✅ 【高频 2015 2017 2019 2022】为什么软件系统架构需要使用不同视图来文档化？给出 4 种示例视图的名称和目的。Why should a software architecture be documented using different differenet views? Give the name and purposes of 4 example views.</p>
<ol>
<li class="lvl-6"><strong>原因</strong>
<ol>
<li class="lvl-9">不同视图支持不同的目标和用户，突出不同的系统元素和关系</li>
<li class="lvl-9">不同视图将不同质量属性暴露出不同的程度</li>
</ol>
</li>
<li class="lvl-6">4 种视图 ( 了解 )：
<ol>
<li class="lvl-9">模块视图 Module View：提供一组连贯职责的实现单元</li>
<li class="lvl-9">组件和连接器视图 C &amp; C View：显示运行时行为和交互的元素</li>
<li class="lvl-9">分配视图 Allocation View：描述了软件单元到环境元素的映射</li>
<li class="lvl-9">质量视图 Quality Views，安全视图、性能视图、可靠性视图、通信视图、异常（错误处理）视图</li>
<li class="lvl-9">组合视图：将上述视图进行组合</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 如何选择视图：</p>
<ol>
<li class="lvl-6">构建涉众/视图表</li>
<li class="lvl-6">合并视图</li>
<li class="lvl-6">确定优先级和完成阶段</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 【2017】【2019】描述 4+1 视图 Describe 4+1 view( 掌握绘图 )：答案如上</p>
<ol>
<li class="lvl-6">逻辑视图：描述了对架构而言重要的元素和他们之间的关系（功能需求）</li>
<li class="lvl-6">过程视图：描述了元素之间的交互。</li>
<li class="lvl-6">物理视图（部署视图）：描述了主要过程和组件是如何被映射到硬件上的。</li>
<li class="lvl-6">开发视图（实现视图）：描述实现系统功能的各个组件和模块是如何实现的</li>
<li class="lvl-6">用例场景（Use Case）：描述系统的参与者（用户）与系统功能用例的关系，与一个或多个特定视图相关。</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/4.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>✅【高频 2015 2017 2018】什么区分了软件产品线架构和单个软件产品架构？What distinguishes an architecture for a software product line from an architecture for a single product?</p>
<ol>
<li class="lvl-6">产品线的目的：实现高可重用性、高修改性。而单个软件产品不需要很高的重用性和可拓展性</li>
<li class="lvl-6">产品线之所以有效是因为通过重用可以充分利用产品的共性。</li>
<li class="lvl-6">软件产品线架构倾向于采用更多的模块化和标准化设计，单一产品架构专注于<strong>满足单一产品的特定需求</strong>，因此模块化和标准化程度较低。</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 【高频 2015 2017 2023】将以下每个问题（左侧）与解决该问题的架构风格/视图（右侧）对应起来。列出每个样式类别的四个视图。Map each of the following questions (on the left) with the architectural style/view (on the right) that addresses the question. List four views of each category of style.</p>
<ol>
<li class="lvl-7">连线题
<ol>
<li class="lvl-10">它是如何构建为一组实现单元的？How it is structed as a set of implementation of units(Module Styles)</li>
<li class="lvl-10">它是如何构建为一组具有运行时行为和交互的元素的？How it is structed as a set of elements that have runtime behavior and interactions?(Component-Connector Styles)</li>
<li class="lvl-10">它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment?(Allocation Styles)</li>
</ol>
</li>
<li class="lvl-7">Module Styles：分解视图、使用视图、泛化视图、分层视图、领域视图、数据模型视图</li>
<li class="lvl-7">Component-Connector Styles：管道-过滤器视图、客户端-服务器视图、点对点视图、面向服务视图、发布-订阅视图</li>
<li class="lvl-7">Allocation Styles：部署视图、安装视图、工作分配视图、其他分配视图。</li>
</ol>
</li>
<li class="lvl-3">
<p>✅【2015】【2017】简要描述软件架构过程中的一般活动，以及每个活动的主要输入和输出。Briefly describe the general activities in a software architecture process, and the major inputs and outputs at each activity.</p>
<ol>
<li class="lvl-6">短答案 ( 背 )
<ol>
<li class="lvl-9">识别 ASRs
<ol>
<li class="lvl-12">输入：无</li>
<li class="lvl-12">输出：优先的质量属性场景</li>
</ol>
</li>
<li class="lvl-9">架构设计
<ol>
<li class="lvl-12">输入：优先的质量属性场景、需求和约束、模式和决策</li>
<li class="lvl-12">输出：一组由模式决定的候选视图的草图</li>
</ol>
</li>
<li class="lvl-9">架构文档化
<ol>
<li class="lvl-12">输入：一组由模式决定的候选视图的草图</li>
<li class="lvl-12">输出：View &amp; Beyond</li>
</ol>
</li>
<li class="lvl-9">架构评估
<ol>
<li class="lvl-12">输入：View &amp; Beyond、优先的质量属性场景</li>
<li class="lvl-12">输出：View &amp; Beyond</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/5.png" alt=""></p>
<ol start="7">
<li class="lvl-3">
<p>✅ 【2015】【2017】【2021】【2023】描述架构权衡分析方法 (ATAM) 过程的每个阶段生成的输出。Describe the outputs generated from each phase of Architecture Tradeoff Analysis Method(ATAM) process.</p>
<ol>
<li class="lvl-6">阶段-0：准备和建立团队 ( 输入是架构设计文档 )
<ol>
<li class="lvl-9">评估计划</li>
</ol>
</li>
<li class="lvl-6">阶段-1：评估-1
<ol>
<li class="lvl-9">架构的简明介绍</li>
<li class="lvl-9">业务目标（驱动因素）的阐释</li>
<li class="lvl-9">作为场景实现的特定质量属性要求的优先级列表</li>
<li class="lvl-9">Utility Tree 质量属性效用树</li>
<li class="lvl-9">风险点和无风险点</li>
<li class="lvl-9">敏感点和权衡点</li>
</ol>
</li>
<li class="lvl-6">阶段-2：评估-2
<ol>
<li class="lvl-9">涉众们的优先级场景列表</li>
<li class="lvl-9">风险主题和业务驱动因素各自受到的威胁</li>
</ol>
</li>
<li class="lvl-6">阶段-3：后续
<ol>
<li class="lvl-9">最终的评估报告</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】描述在 ATAM 的每一个过程中 有哪些 Stack holder 和他们的职责</p>
<ol>
<li class="lvl-6">阶段-0：准备和建立团队
<ol>
<li class="lvl-9">参与者：评估团队领导和关键项目决策者</li>
<li class="lvl-9">职责：根据架构设计文档生成评估计划，包括谁参加评估、如何何时何地开展评估、最后评估报告会被呈递给谁。</li>
</ol>
</li>
<li class="lvl-6">阶段-1：评估-1
<ol>
<li class="lvl-9">参与者：评估团队和项目决策者</li>
<li class="lvl-9">职责：
<ol>
<li class="lvl-12">第一步，评估负责人介绍 ATAM 方法</li>
<li class="lvl-12">第二步，项目经理或客户从业务角度介绍业务驱动因素</li>
<li class="lvl-12">第三步，首席架构师介绍体系结构</li>
<li class="lvl-12">第四步，评估团队确定架构方法</li>
<li class="lvl-12">第五步，评估团队和项目决策者生成质量属性效用树 (Utiltiy Tree)</li>
<li class="lvl-12">第六步，评估团队分析架构方法</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">阶段-2：评估-2
<ol>
<li class="lvl-9">参与者：评估团队、项目决策者和项目涉众</li>
<li class="lvl-9">职责：
<ol>
<li class="lvl-12">第一步，评估负责人介绍 ATAM 方法和之前已经取得的成果</li>
<li class="lvl-12">第七步，涉众头脑风暴并确定场景优先级</li>
<li class="lvl-12">第八步，评估团队分析架构方法，类似第六步</li>
<li class="lvl-12">第九步，评估团队展示评估结果，并呈递给涉众</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-6">阶段-3：后续
<ol>
<li class="lvl-9">参与者：评估团队、主要涉众</li>
<li class="lvl-9">职责：评估团队制作最终评估报告，发给主要涉众审核通过后，将报告呈递给委托评估的人。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>✅ 【2015】【2019】软件架构来自哪里？列举五种可能的软件架构的来源 Where do software architecture come from? List five possible sources of software architecture.</p>
<ol>
<li class="lvl-9">NFRs - 非功能性需求</li>
<li class="lvl-9">ASRs</li>
<li class="lvl-9">涉众</li>
<li class="lvl-9">技术环境</li>
<li class="lvl-9">业务目标</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2015】【2019】解释代理架构模式的上下文、好处和局限性。Explain the context, benefits and limitations of Broker Architecture Pattern.</p>
<ol>
<li class="lvl-7">上下文：多个<strong>同步或异步交互</strong>的<strong>远程对象组成的系统</strong>，broker协调多个客户机和服务器之间的通讯。</li>
<li class="lvl-7">好处：提高了 Client 和 Server 之间的交互性、提高可伸缩性和可扩展性、解决了单体应用的性能瓶颈、大规模集群的性能提高，但是单点性能会下降。</li>
<li class="lvl-7">局限性：代理增加了前期复杂度、可能成为通信的屏障、可能成为攻击的目标、难以测试。</li>
<li class="lvl-7">SOA 延续了 broker 的思想，查找服务和使用服务都要通过 broker，而 SOA 只在查找时通过 register，分散了 broker 的职责，降低了单点风险。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】【2023】Layered pattern 和 Multi-tier pattern 的区别</p>
<ol>
<li class="lvl-7">Layered Pattern 是 Module Style，而 Multi-tier Pattern 是 Allocation Style</li>
<li class="lvl-7">Layered Pattern 是将任务拆解成一个个处于特定抽象级别的子层次，每层为上一层提供服务，核心是关注点分离。</li>
<li class="lvl-7">Multi-tier Patten 中的层是逻辑的组合，没有层次模式的强依赖关系，在不同部署环境中分层不同但是软件完成的内容一致。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2017】【2019】【2022】【2023】在设计软件时应用了哪些<strong>通用设计策略</strong>？为每个策略提供一个带有软件架构的简明工作示例。What are generic design strategies applied in designing software? Give a concise working example with software architecture for each strategy.</p>
<ol>
<li class="lvl-7">抽象：关注本身结构而不关心实现，比如将系统抽象为组件和连接件或抽象为模块。</li>
<li class="lvl-7">分解：比如将整个系统分解或将某个模块分解。</li>
<li class="lvl-7">分而治之：将每个模块分别处理</li>
<li class="lvl-7">生成与测试：将一个特定的设计看作是一个假设；根据测试路径生成测试用例。</li>
<li class="lvl-7">迭代与细化：如 ADD 方法多次迭代直到满足所有 ASR</li>
<li class="lvl-7">复用元素：重用在设计过程中出现了可以复用的元素，重用现有架构</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2017】【2019】什么是 ASR？列出提取和识别 ASR 的四种来源和方法。What are ASR? List four sources and methods for extracting and identifying ASRs.</p>
<ol>
<li class="lvl-7">ASRs 架构攸关需求是对架构产生深远影响的需求</li>
<li class="lvl-7">四种来源和方法：
<ol>
<li class="lvl-10">从需求文档中收集 ASR：MoScoW 方法和用户故事</li>
<li class="lvl-10">通过采访涉众来收集 ASR：质量属性工作坊 (QAW)Quality Attribute Workshop</li>
<li class="lvl-10">通过了解业务目标来收集 ASR：</li>
<li class="lvl-10">通过质量属性效用树 (Utility Tree) 来收集 ASR*：逐渐对质量属性进行分解细化，直到包含量化指标为止。*</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2017】【2019】典型的软件架构文档包中应该包含哪些内容？简要描述每个组件及其用途。What should be included in a typical software architecture documentation package? Briefly describe each component and its purpose.</p>
<ol>
<li class="lvl-7"><strong>包含 View 和 Beyond</strong></li>
<li class="lvl-7">Beyond 部分：
<ol>
<li class="lvl-10">文档路线图：包含了范围和总结、简单摘要等。</li>
<li class="lvl-10">视图的文档组织方式：描述了本文档中视图是如何组织的。</li>
<li class="lvl-10">系统概述：从整体上描述了当前架构的简要说明、业务目标 ( 驱动因素 ) 等等。</li>
<li class="lvl-10">视图之间的映射关系：描述了不同视图之间的映射关系。</li>
<li class="lvl-10">系统原理：从整体上描述了当前架构的设计原理。</li>
<li class="lvl-10">目录-索引、词汇表、首字母缩略词表。</li>
</ol>
</li>
<li class="lvl-7">View 部分
<ol>
<li class="lvl-10">styles and views( 体系结构风格和视图 )</li>
<li class="lvl-10">Structural views
<ol>
<li class="lvl-13">module viwes</li>
<li class="lvl-13">C &amp; C views</li>
<li class="lvl-13">Allocation views</li>
</ol>
</li>
<li class="lvl-10">Quality Views</li>
</ol>
</li>
<li class="lvl-7">每一个 View 的内容
<ol>
<li class="lvl-10">主要介绍：显示视图的元素和关系，以及图例</li>
<li class="lvl-10">元素介绍，详细介绍第一部分中描述的元素、元素属性、关系属性和元素接口和行为。</li>
<li class="lvl-10">上下文图：描述系统如何与环境相关</li>
<li class="lvl-10">可变性指导：告知视图中可能出现的变化</li>
<li class="lvl-10">基本原理：解释设计如何映射在视图中，以及其合理性。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2015】描述架构设计中架构模式和tactics 之间的关系。给出可以在架构设计过程中使用的任何四种决策的名称，并描述每种决策的目的。Describe the relationships between architectual patterns and tactics in architecture design. Give name of any four tactics that can be used during architecture design and describe the purpose of each of them.</p>
<ol>
<li class="lvl-7">架构模式与tactics 之间的关系
<ol>
<li class="lvl-10">tactics 比模式更简单，使有单一的结构或机制来应对单一的架构驱动</li>
<li class="lvl-10">tactics 是构成架构模式的重要组成部分</li>
<li class="lvl-10">架构模式通常将许多个tactics 组合在一起。</li>
<li class="lvl-10">大多数架构模式都包含不同的tactics ，这些tactics 可能有共同的目的或者常被用于实现不同的质量属性。</li>
<li class="lvl-10">tactics 和架构模式共同构成了软件设计时的工具。</li>
</ol>
</li>
<li class="lvl-7">四种决策的名称</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2015】简要描述面向服务架构 (SOA) 的基本原则，并讨论 SOA 对互操作性、可伸缩性和安全性等质量属性的影响 Briefly describe the fundamental principles of Service Oriented Architecture(SOA) and discuss the impact of SOA on quality attributes like interoperability, scalability and security</p>
<ol>
<li class="lvl-7">SOA 的基本原则
<ol>
<li class="lvl-10">服务解耦：服务之间的关系最小化，只是相互知道接口</li>
<li class="lvl-10">服务契约:服务按照描述文档所定义的服务契约行事</li>
<li class="lvl-10">服务封装:除了服务契约所描述内容，服务将对外部隐藏实现逻辑</li>
<li class="lvl-10">服务重用:将逻辑分布在不同的服务中，以提高服务的重用性</li>
<li class="lvl-10">服务组合:一组服务可以协调工作，组合起来形成定制组合业务</li>
<li class="lvl-10">服务自治:服务对所封装的逻辑具有控制权</li>
<li class="lvl-10">服务无状态:服务将一个活动所需保存的资讯最小化</li>
</ol>
</li>
<li class="lvl-7">SOA 对互操作性的影响
<ol>
<li class="lvl-10">SOA 具有更高的互操作性：符合开放标准，可以更好的重用服务</li>
<li class="lvl-10">支持服务的自动识别、发现、注册和调用等等</li>
</ol>
</li>
<li class="lvl-7">SOA 对可伸缩性的影响
<ol>
<li class="lvl-10">SOA 具有更高的可伸缩性：服务自身高内聚、服务间松耦合，最小化维护的影响</li>
<li class="lvl-10">但是 SOA 也会带来系统复杂度较高的问题</li>
</ol>
</li>
<li class="lvl-7">SOA 对安全性的影响：
<ol>
<li class="lvl-10">中间件可能会成为性能的瓶颈</li>
<li class="lvl-10">ESB 等中间件都可以成为被攻击的目标</li>
<li class="lvl-10">多服务导致攻击的跟踪、溯源和防御成为困难。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2019】【2023】微服务和 SOA 的区别，相同点</p>
<ol>
<li class="lvl-7">相同点：微服务和 SOA 都是分布式架构，微服务架构可以看作是SOA的一种实现方式，适用于更小规模和更灵活的应用系统。都包含了服务契约、服务封装、服务重用、服务组合、服务自治和服务无状态等基本特点。</li>
<li class="lvl-7">微服务去掉了 SOA 架构中的 ESB(Enterprise Service Bus) 企业服务总线，采用轻量级通信机制 (HTTP、REST) 进行服务之间的通信。</li>
<li class="lvl-7">微服务引入了熔断器：避免出现服务失效或网络问题等导致的级联故障。</li>
<li class="lvl-7">部署和扩展：在SOA中，整个应用程序通常作为一个单元进行部署和扩展。而在微服务架构中，每个微服务可以独立部署和扩展，使得系统具有更好的弹性和可伸缩性。</li>
<li class="lvl-7">服务粒度：在SOA中，服务的粒度可以比较大，一个服务可能涵盖多个相关的业务功能。而在微服务架构中，服务的粒度更小，每个服务通常专注于一个特定的业务功能。</li>
<li class="lvl-7">组织和治理：SOA通常需要涉及企业范围内的中央治理和管理，**不能控制独立服务的演变。**而微服务架构强调团队的自治性，<strong>每个微服务可以由一个独立的团队进行开发和管理，更加注重服务的自治性和快速迭代</strong>。</li>
</ol>
</li>
<li class="lvl-4">
<p>【2017】<strong>软件设计的三个变化维度，每个维度的变化点。不同的绑定时间如何影响可修改性和可测试性</strong>。</p>
<ol>
<li class="lvl-7">三个变化维度：
<ol>
<li class="lvl-10">面向对象 OOP，强调重用性、灵活性和扩展性。</li>
<li class="lvl-10">面向方面 AOP，满足扩展的需求，可以在程序中自由的扩展功能</li>
<li class="lvl-10">面向服务 SOA，是系统发布功能的一种方式，且基于这种方式下不同的系统之间可以有效的沟通、协作。</li>
</ol>
</li>
<li class="lvl-7">设计时，开发时，测试时，发布时，运行时：可修改性降低，可测试性升高</li>
</ol>
</li>
<li class="lvl-4">
<p>✅【2018】<strong>软件架构的关注点有哪些</strong>？利益相关方有哪些？</p>
<ol>
<li class="lvl-7">软件架构的关注点
<ol>
<li class="lvl-10">利益相关者 Stakeholders addressed</li>
<li class="lvl-10">解决的问题 Concerns addressed</li>
<li class="lvl-10">语言，建模技巧 Language, modeling techniques</li>
<li class="lvl-10">策略，模式 Tactics, Pattern</li>
</ol>
</li>
<li class="lvl-7">利益相关方有哪些？
<ol>
<li class="lvl-10">顾客 Customer</li>
<li class="lvl-10">用户 User</li>
<li class="lvl-10">架构师 Architect</li>
<li class="lvl-10">需求工程师 Requirements engineer</li>
<li class="lvl-10">设计师 Designer</li>
<li class="lvl-10">实施者 Implementer</li>
<li class="lvl-10">测试师，集成师 Tester, integrator</li>
<li class="lvl-10">维护者 Maintainer</li>
<li class="lvl-10">产品经理 Product manager</li>
<li class="lvl-11">质量保证人 Quality assurance people</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】【2022】Software requirements, Quality attributes, ASRs 的区别和联系</p>
<ol>
<li class="lvl-7">软件需求包括功能性需求和非功能性需求（又称质量需求）</li>
<li class="lvl-7">质量属性是由软件的业务目标所决定，在功能性需求的基础上提供的整个系统的合乎需求的特性，是非功能需求的一种体现。</li>
<li class="lvl-7">ASRs 架构攸关需求是对于体系结构有着深远影响的需求，肯定是软件需求的一部分。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】描述 ADD 过程</p>
<p><strong>输入</strong>：需求，<strong>输出</strong>：软件元素 - 角色 - 职责 - 属性 - 关系</p>
<ol>
<li class="lvl-7">
<p>确定有足够的需求信息</p>
</li>
<li class="lvl-7">
<p>选择要分解的系统要素</p>
</li>
<li class="lvl-7">
<p>确定所选的元素的 ASR</p>
</li>
<li class="lvl-7">
<p>选择符合 ASR 的设计</p>
<ol>
<li class="lvl-10">找出设计问题</li>
<li class="lvl-10">列出子关注点替代模式/策略</li>
<li class="lvl-10">从清单中选择模式/策略</li>
<li class="lvl-10">确定模式/策略与 ASR 之间的关系</li>
<li class="lvl-10">记录初步的架构视图</li>
<li class="lvl-10">评估并解决不一致的问题</li>
</ol>
</li>
<li class="lvl-7">
<p>实例化架构元素并分配职责</p>
</li>
<li class="lvl-7">
<p>实例化元素定义接口</p>
</li>
<li class="lvl-7">
<p>验证和完善需求</p>
</li>
<li class="lvl-7">
<p>重复进行 2-7 步直到满足所有的 ASR</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2019】Architecture，structure 和 Design 的区别？</p>
<ol>
<li class="lvl-7">Design 包含 Architecture，Architecture 包含 Structure</li>
<li class="lvl-7">结构是静态的、逻辑的，是关于系统如何构成的</li>
<li class="lvl-7">Architecture除包含structure ，还会包含组件之间的相关的关系结构，并定义一些动态的行为。</li>
<li class="lvl-7">所有体系结构都是设计，但是不是所有的设计都是体系结构，体系结构是软件设计的一个部分</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 【2018】【2019】【2022】Risks，Senstivity Points，Trade-Off Points 分别是什么？各举一个例子。</p>
<ol>
<li class="lvl-7">识别风险：发现可能对所需质量属性产生负面影响的架构决策，例如使用分层模式可能带来性能损耗。</li>
<li class="lvl-7">发现权衡：影响多个质量属性的架构决策，例如使用分层模式可能会带来性能损耗，但是增加系统的可修改性。</li>
<li class="lvl-7">发现敏感点：特定质量属性对其敏感的架构决策，比如在对性能敏感的系统中，决定使用缓存中间件。</li>
</ol>
</li>
<li class="lvl-4">
<p>✅ 软件架构风格</p>
<ol>
<li class="lvl-7">module Styles：认为体系结构是由模块组成。模块是实现单元的集合，它提供了一组一致的职责。</li>
<li class="lvl-7">C &amp; C Styles 认为体系结构是由组件 ( 主要的处理单元和数据存储 )、连接件 ( 组件之间的交互路径 ) 组成的。</li>
<li class="lvl-7">Allocation Styles 认为体系结构是由软件元素 ( 软件元素具有环境所需的属性 ) 和环境元素 ( 环境元素有提供给软件的属性 ) 组成的，展示了软件如何与环境关联。</li>
</ol>
</li>
<li class="lvl-4">
<p>架构模式是：⼀个架构模式是⼀组架构设计决定，这些决定适用于重复出现的设计问题，并被参数化以考虑出现该问题的不同软件开发上下文。</p>
</li>
<li class="lvl-4">
<p>软件架构是程序或计算系统的结构，由软件元素、这些元素外部可⻅的属性、这些元素的关系组成</p>
</li>
<li class="lvl-5">
<p>架构模式：{问题，上下文} → 架构方法。架构风格具体到常见的问题和上下文，就叫做架构模式</p>
</li>
</ol>
<h2 id="1-2-设计模式">1.2. 设计模式</h2>
<ol>
<li class="lvl-3">
<p>【2017】请至少说出三个面向对象的原则，并解释它们如何应用于策略模式？ Please name at least three Object-Oriented principles, and explain how they are applied in Strategy pattern?</p>
<ol>
<li class="lvl-6">单一职责原则</li>
<li class="lvl-6">开闭原则</li>
<li class="lvl-6">里氏代换原则</li>
<li class="lvl-6">合成复用原则</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】设计模式是什么？举例说明类模式和对象模式的区别？</p>
<ol>
<li class="lvl-6">什么是设计模式：
<ol>
<li class="lvl-9">(PPT)<strong>设计模式 (Design Pattern)<strong>是</strong>一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</li>
</ol>
</li>
<li class="lvl-6">设计模式分类
<ol>
<li class="lvl-9">根据其目的 ( 模式是用来做什么的 ) 可分为创建型 (Creational)，结构型 (Structural) 和行为型 (Behavioral) 三种：
<ol>
<li class="lvl-12">创建型模式主要用于创建对象。</li>
<li class="lvl-12">结构型模式主要用于处理类或对象的组合。</li>
<li class="lvl-12">行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。</li>
</ol>
</li>
<li class="lvl-9">根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：
<ol>
<li class="lvl-12">类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。</li>
<li class="lvl-12">对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】防御式编程是什么？断言和错误处理的区别？</p>
<ol>
<li class="lvl-6">可以预见到（至少预先推测到）问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施，来防止类似的意外的发生。</li>
<li class="lvl-6">断言和错误处理的区别
<ol>
<li class="lvl-9">断言是在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏。断言不可以有副作用。</li>
<li class="lvl-9">错误处理是对预先已经考虑到的错误 ( 如用户错误、程序错误、意外情况等等 ) 按照流程进行处理。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】设计模式对 MVC 的影响？</p>
<ol>
<li class="lvl-6">MVC 模式使用了运行时、动态和相互之间的关系集成到开发框架中，是分层模式的变种。
<ol>
<li class="lvl-9">分为 model（业务逻辑）、view（处理用户展示，接收用户操作）、controller（对用户操作进行处理，将信息通知给 model）（强调模块间约束关系，model 不可以直接返回到 controller）</li>
<li class="lvl-9">优点：耦合性低，重用性高，生命周期成本低，部署快，可维护性高，方便管理</li>
<li class="lvl-9">缺点：没有明确定义，不适于中小型应用程序，增加实现复杂度，视图和控制器过于紧密，视图对模型访问低效。</li>
</ol>
</li>
<li class="lvl-6">四人书中，MVC 模式是观察者模式、策略模式和组合模式的演化，可能涉及到工厂模式和装饰器模式
<ol>
<li class="lvl-9">基于推送-订阅模式</li>
<li class="lvl-9">观察者：model 发生变化通知 controller，然后更新 view</li>
<li class="lvl-9">策略模式：controllers 帮助 views 对不同用户的输入做不同的响应。</li>
<li class="lvl-9">组合模式：一组 views</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】【2023】策略模式和状态模式的区别？</p>
<ol>
<li class="lvl-6">在状态模式中，具体状态类的方法参数中包含上下文对象，需要在状态处理完成后完成状态切换。</li>
<li class="lvl-6">在策略模式中，直接对上下文类调用 set 方法设置策略即可，不涉及到策略的切换。</li>
</ol>
</li>
<li class="lvl-3">
<p>【2019】最小知识原则在设计模式中的应用？</p>
<ol>
<li class="lvl-6">中介者模式</li>
<li class="lvl-6">外观模式</li>
</ol>
</li>
<li class="lvl-3">
<p>【2022】Please explain the Liskov Substitution Principle and how it contributes to the Open- Closed Principle</p>
<ol>
<li class="lvl-6">LSP要求子类能够完全替代父类，而不会破坏原有系统的行为</li>
<li class="lvl-6">LSP对于开闭原则（Open-Closed Principle，OCP）的贡献在于，它确保了代码的可扩展性。OCP要求软件实体应该对扩展开放，对修改关闭。当我们遵循LSP时，可以通过添加新的子类来扩展系统的功能，而无需修改已有的代码。因为子类完全替代父类，所以可以将新的子类对象传递给原有代码，而不会影响原有代码的正确性。这样，我们可以通过增加新的子类来实现系统的扩展，同时保持原有代码的稳定性和一致性</li>
</ol>
</li>
<li class="lvl-3">
<p>【2022】【2023】观察者设计模式中有两种方法用于向观察者传播数据：推模型（Push Model）和拉模型（Pull Model）。为什么有些情况下一个模型会比另一个模型更可取？每个模型的权衡是什么？</p>
<p>推模型和拉模型的选择取决于应用程序的需求和设计考虑。下面是每个模型的优势和权衡：</p>
<p>推模型：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>优势：</p>
<ol>
<li class="lvl-8">简单直接：数据由主题（被观察者）直接推送给观察者，观察者不需要主动请求数据。</li>
<li class="lvl-8">即时性：数据推送是实时的，观察者可以立即收到最新的数据更新。</li>
</ol>
</li>
<li class="lvl-5">
<p>权衡：</p>
<ol>
<li class="lvl-8"><strong>无法控制数据量</strong>：在推模型中，主题通常将所有数据推送给所有观察者，无论观察者是否需要这些数据。这可能会导致数据传输过程中的浪费。</li>
<li class="lvl-8">安全性和隐私问题：如果数据包含敏感信息，推模型可能会引发安全和隐私问题，因为数据在推送过程中可能会被截获或访问到。</li>
</ol>
</li>
</ul>
<p>拉模型：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>优势：</p>
<ol>
<li class="lvl-8">灵活性：观察者可以根据需要主动拉取所需的数据，可以减少不必要的数据传输。</li>
<li class="lvl-8">数据控制：观察者可以根据具体情况控制拉取数据的频率和量，从而减少网络带宽和资源消耗。</li>
</ol>
</li>
<li class="lvl-5">
<p>权衡：</p>
<ol>
<li class="lvl-8"><strong>延迟性</strong>：拉模型需要观察者主动发起请求才能获取数据，可能会引入一定的延迟。</li>
<li class="lvl-8">实时性限制：观察者只能获取其主动请求的数据更新，无法立即获知所有最新的数据。</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-3">
<p>【2022】What is the difference between the categories of Creational Patterns and Structural<br>
Patterns</p>
<ol>
<li class="lvl-6">
<p>创建型模式（Creational Patterns）和结构型模式（Structural Patterns）是面向对象设计中的两个主要模式分类。</p>
<p>创建型模式关注<strong>对象的创建机制和实例化过程</strong>，主要用于解决对象的创建和初始化的问题。这些模式将对象的创建与使用代码解耦，使得系统更加灵活和可扩展。创建型模式的例子包括工厂模式、抽象工厂模式、单例模式、建造者模式和原型模式等。</p>
<p>结构型模式关注<strong>对象之间的组合和关联关系</strong>，主要用于描述对象和类之间的静态结构和组织方式。这些模式通过定义类和对象之间的关系，提供了一种实现系统组件之间协作的方式。结构型模式的例子包括适配器模式、装饰器模式、代理模式、组合模式、外观模式、桥接模式和享元模式等。</p>
<p>行为型模式关注<strong>对象之间的交互和职责分配</strong>，可以减少对象间的耦合度，提高系统的灵活性和可扩展性。行为型模式的例子包括观察者模式、策略模式、模板方法模式、命令模式、迭代器模式、状态模式、访问者模式和解释器模式等。</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>类模式和对象模式</p>
<ol>
<li class="lvl-7">
<p>类模式是指应用于类层次结构的设计模式。它们关注的是类之间的关系、继承和接口的使用。类模式描述了类之间的静态关系和结构，以及如何通过类的继承、组合和接口实现来达到设计目标。类模式通常通过继承、抽象类、接口等来实现类之间的关系，以及类的行为和功能。</p>
<p>对象模式是指应用于对象层次结构的设计模式。它们关注的是对象之间的交互、通信和协作。对象模式描述了对象之间的动态行为和相互作用方式，以实现特定的功能和行为。对象模式通常通过对象之间的关联、委托、组合、观察者等方式来实现对象的交互和通信。</p>
</li>
<li class="lvl-7">
<p>工厂方法模式注重对象的创建和实例化过程，它通过子类化来延迟具体对象的创建，被归类为类模式。而抽象工厂模式注重对象之间的关联关系和组合，它的目标是提供一种统一的方式来创建<strong>一系列相关的对象</strong>，被归类为对象模式</p>
</li>
<li class="lvl-7">
<p>由于模板方法模式主要通过基类和子类之间的继承关系来定义算法的框架结构，强调了类之间的静态关系和结构，所以被归类为类模式。</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>【2021】软件模式是什么？能提供架构吗？</p>
<ol>
<li class="lvl-7">虽然软件模式提供了一些通用的设计思路和原则，但具体的架构设计需要结合具体的问题和需求进行选择和应用。架构设计涉及系统的整体结构、组件之间的关系、数据流和交互方式等方面，需要<strong>综合考虑系统的功能需求、性能要求、可扩展性、安全性等因素</strong>。因此，软件模式可以作为设计架构的参考和指导，但最终的架构设计需要根据具体情况进行灵活调整和优化。</li>
</ol>
</li>
<li class="lvl-4">
<p>【2023】装饰者模式为什么比用子类扩展功能有更好的灵活性？</p>
</li>
<li class="lvl-4">
<p>【2023】为什么最小知识原则可以帮助构建高内聚、低耦合的系统？用代码举一个违背的例子</p>
</li>
<li class="lvl-4">
<p>【2022】【2023】What is the benefit of decoupling the Receiver from the Invoker in the Command Pattern?</p>
</li>
</ol>
<h1>2. 设计题</h1>
<ol>
<li class="lvl-3">
<p>【2019】一个游戏，有几种人类角色：骑士、骑兵、步兵，持有不同的武器 ( 矛、剑、斧 )，拥有 fight 方法；有一个非人类角色巨魔，可以持有武器，但攻击方法不同 (beat)。现在希望让巨魔和其他人类角色一起进行游戏，并且要求有角色死亡时其他活着的角色要收到通知。运用设计模式进行设计，并画出类图。</p>
</li>
<li class="lvl-3">
<p>【2019】表驱动，参考 PPT 即可。</p>
</li>
<li class="lvl-3">
<p>【2019】架构设计，没太看懂……大概是分析程序结构生成报告？</p>
</li>
<li class="lvl-3">
<p>【2018】设计一个飞行模拟软件，要求能模拟多种飞机的特性。为了在将来支持更多飞机种类，要求使用策略模式。画出架构图和类图</p>
</li>
<li class="lvl-3">
<p>【2019】一个买票系统的设计题，不同的角色有不同的打折方案，用策略模式设计， 最后画图，还要说明策略模式的使用场景。</p>
</li>
<li class="lvl-3">
<p>【2021】【2023】设计⼀个基于管道-过滤器模式的、输⼊⽂本⽂件、输出排序后的⽆重复的单词列表的程序。 1. ⽤组件部分和连接器画出程序图。 2. 画出组件的类图。 3. ⽤ Java 实现每个类。 4. 指出你的代码和 1、2 中图的映射</p>
</li>
<li class="lvl-3">
<p>【2023】设计一个系统，有很多的机器人，他们有不同的功能，在未来会拓展这些功能或功能的复杂性，同时有一批保留了旧接口的老机器人，也希望能加入到这个系统中。系统还能将所有的机器人看作一个 unit 来统一的控制。1. 列出使用的设计模式和类图 2.说明你的设计如何有利于未来拓展功能</p>
</li>
</ol>
<p>【2015】【2019】【2022】</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/2.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/1.png" alt=""></p>
<h1>3. 其他知识点</h1>
<ol>
<li class="lvl-3">
<p>什么是软件系统架构：是结构和系统结构，包含了软件元素，这些组件的外部可视化属性和他们之间的关系（包含组件的行为）</p>
</li>
<li class="lvl-3">
<p>几个概念</p>
<ol>
<li class="lvl-6">功能性需求：定义系统必须做什么，并且强调系统如何提供价值给涉众。</li>
<li class="lvl-6">质量需求：系统应在功能性需求之上提供的整个系统的合乎需求的特性。</li>
<li class="lvl-6">策略：是影响质量属性相应控制的设计决策，比如冗余。</li>
</ol>
</li>
<li class="lvl-3">
<p>架构模式</p>
<ol>
<li class="lvl-6">背景、上下文（Context）：世界上经常发生问题的场景。</li>
<li class="lvl-8">问题（Problem）：在给定上下文中出现经过适当概括的问题。</li>
<li class="lvl-8">解决方案（Element + Relations + Constraints）：针对问题的成功的经过适当抽象的解决方案。</li>
</ol>
</li>
<li class="lvl-3">
<p>ADD 的输出</p>
<ol>
<li class="lvl-6">软件元素：完成各种决策和职责、定义属性并与其他软件元素相关以组成系统架构的计算或开发工件。</li>
<li class="lvl-6">角色：一组相关的职责。</li>
<li class="lvl-6">职责：软件提供的功能、数据或信息。</li>
<li class="lvl-6">属性：有关软件元素的附加信息。</li>
<li class="lvl-6">关系：两个软件元素之间如何相互关联和交互的定义。</li>
</ol>
</li>
<li class="lvl-3">
<p>如何选择视图</p>
<ol>
<li class="lvl-6">构建涉众/视图表</li>
<li class="lvl-6">合并视图</li>
<li class="lvl-6">确定优先级和完成阶段</li>
</ol>
</li>
<li class="lvl-3">
<p>什么是微服务：是分布式架构，SOA 的一种扩展</p>
<ol>
<li class="lvl-6">微服务架构风格是一种将一个单一应用开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制，这些服务围绕业务能力构建并可以通过自动部署机制独立部署。</li>
<li class="lvl-6">微服务特点
<ol>
<li class="lvl-9">服务颗粒化:服务粒度由业务功能决定，服务间尽可能解耦</li>
<li class="lvl-9">责任单一化:单一职责原则，服务内尽可能内聚</li>
<li class="lvl-9">运行隔离化:服务运行在各自进程中，互不影响</li>
<li class="lvl-9">管理自动化:对服务提供自动化部署与监控预警能力，高效管理</li>
</ol>
</li>
<li class="lvl-6">微服务核心模式：针对采用微服务系统在特定问题所使用的程序的架构解决方案的集合
<ol>
<li class="lvl-9">服务注册与发现</li>
<li class="lvl-9">API 网关</li>
<li class="lvl-9">熔断器</li>
</ol>
</li>
<li class="lvl-6">微服务的挑战
<ol>
<li class="lvl-9">运维要求高:微服务数量多，部署与监控要求高</li>
<li class="lvl-9">发布复杂度:部署环境多样化，网络性能系统容错、分布式事务等挑战</li>
<li class="lvl-9">部署依赖强:服务间相互调用关系复杂，存在部署顺序依赖</li>
<li class="lvl-9">通信成本高:跨进程调用比进程内调用消耗更多的资源</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>面向对象设计原则</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/6.png" alt=""></p>
<ol start="8">
<li class="lvl-3">
<p>设计原则</p>
<ol>
<li class="lvl-7">目标：开闭原则</li>
<li class="lvl-7">指导：最小知识原则</li>
<li class="lvl-7">基础：单一职责原则、可变性封装原则</li>
<li class="lvl-7">实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li>
</ol>
</li>
<li class="lvl-3">
<p>模式一般都有的缺点</p>
<ol>
<li class="lvl-7">增加设计的复杂性和增加类的个数 ( 增加辅助类 )</li>
<li class="lvl-7">增加隔阂、方法调用，降低软件运行的效率，但是已经不是目前主要的问题</li>
</ol>
</li>
<li class="lvl-4">
<p>引入设计模式的作用</p>
<ol>
<li class="lvl-10">设计模式提供了与其他开发人员共享的词汇表。</li>
<li class="lvl-10">通过在模式级别（而不是实质性对象级别）进行思考，提高对体系结构的思考（但不要迷失在细节中）</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/7.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/8.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/9.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/10.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/11.png" alt=""><br>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/exam0/12.png" alt=""></p>
<ol>
<li class="lvl-4">
<p>防御式编程</p>
<ol>
<li class="lvl-7">防御式编程：可以预见到（或至少预先推测到）问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施，来防止类似意外的发生。</li>
<li class="lvl-7">断言：在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏。断言不可以有副作用。</li>
<li class="lvl-7">异常：是将代码中的错误或异常事件传递给调用方代码的一种特殊手段，谨慎使用可以降低复杂度。</li>
<li class="lvl-7">错误处理：根据软件类别平衡正确性和健壮性（哪个优先级更高）</li>
<li class="lvl-7">隔离程序：隔离程序是以防御式编程为目的而进行隔离的一种方法，将某些接口选定为“安全”区域的边界，对穿越安全区域边界的数据进行合法性检验（集中工作在特定的模块中降成本）</li>
<li class="lvl-7">辅助调试代码：辅助进行代码调试的代码，帮助快速检查错误，应该尽早地引入辅助调试代码。</li>
<li class="lvl-7">攻击式编程：主动暴露出可能出现的错误，在开发阶段将其暴露显现出来，而在产品代码运行时让他能够自我恢复。</li>
</ol>
</li>
<li class="lvl-4">
<p>表驱动法：一种编程模式</p>
<ol>
<li class="lvl-7">目的：表驱动法适用于复杂逻辑，将复杂逻辑从代码中独立出来方便单独维护</li>
<li class="lvl-7">原理：从表里面查找信息而不使用逻辑语句 (if 和 else)</li>
<li class="lvl-7">具体实现
<ol>
<li class="lvl-10">直接访问表：直接通过索引值可以从表中找到对应的条目</li>
<li class="lvl-10">索引访问表：首先从索引表中找到数据表的地址，然后再从数据表中找到对应的条目 ( 节省空间、管理廉价、容易维护 )</li>
<li class="lvl-10">阶梯访问表：根据每项命中的阶梯层次来确定其归属</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-4">
<p>装饰者的两个缺点：很多小类、难以排查错误</p>
</li>
<li class="lvl-4">
<p>增加新的鸭叫统计次数 ( 不允许修改原本代码 )：装饰器模式</p>
</li>
</ol>
<h1>4. 选择模式</h1>
<ol>
<li class="lvl-3">
<p>一个温度系统有 3 个恒温器，一个恒温器可以调整和显示温度，2 个恒温器只能手动调节，1 个恒温器可以手动、计时器调节：中介者、策略</p>
<ol>
<li class="lvl-6">模板方法：先调整、再显示 ( 用户直接复用模板方法，而本例中复用的是实现 )</li>
</ol>
</li>
<li class="lvl-3">
<p>一个队伍有 1 个管理者和 25 个队员，每一个队员可以有一个位置，有的特别强的队员可以有多个位置：策略、原型</p>
<ol>
<li class="lvl-6">策略独立于 Player，所以 Player 是一样的</li>
<li class="lvl-6">模板方法模式是解决步骤的问题</li>
</ol>
</li>
<li class="lvl-3">
<p>积分会员制，积分比较高则为高级会员，积分比较低则为低级会员</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处。
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://wbl-z.github.io/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E5%BE%80%E5%B9%B4%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B/" rel="tag">课程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" rel="tag">软件系统设计</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/web%E5%89%8D%E7%AB%AF/web%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2+2023%E5%9B%9E%E5%BF%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">web前端复习提纲</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i>  zzb
      </li>
    </ul>
    <ul>
      <li>
        R<i class="ri-heart-fill heart_icon"></i>Z
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="wbl-z&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    
      <li class="nav-item">
          <a href="https://github.com/wbl-z" target="_blank" class="my_link_li">
              <img src="/images/github.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://blog.csdn.net/m0_51691879" target="_blank" class="my_link_li">
              <img src="/images/csdn.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://juejin.cn/user/13645532637448" target="_blank" class="my_link_li">
              <img src="/images/%E6%8E%98%E9%87%91.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="mailto:1214345406@qq.com" target="_blank" class="my_link_li">
              <img src="/images/envelope.png">
          </a>
      </li>
      
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>