<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="技术，编程，代码，教程，Java" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>3 传输层 |  wbl-z&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/logo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?edcb9d2dbc760f6eeab5900f9b363881";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-计算机网络自顶向下方法/3 传输层"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  3 传输层
</h1>
 

      
    <div class="article-author"  style="text-align: center ;font-size:20px" >
        作者： zzb
    </div>


    </header>
     
    <div class="article-meta">
      <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/3%20%E4%BC%A0%E8%BE%93%E5%B1%82/" class="article-date">
  <time datetime="2022-06-26T14:02:10.000Z" itemprop="datePublished">2022-06-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/">计算机网络-自顶向下方法</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">25 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1>3 传输层</h1>
<h2 id="3-1-概述和传输层服务">3.1 概述和传输层服务</h2>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414110728006.png" alt="image-20220414110728006"></p>
<p>传输层加强了网络层的服务，但有些服务是可以加强的，有些服务是不能加强的，如<strong>延时和带宽</strong>是不能加强的，取决于网络层</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414111155619.png" alt="image-20220414111155619"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414111518603.png" alt="image-20220414111518603"></p>
<h2 id="3-2-多路复用和解复用">3.2 多路复用和解复用</h2>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414111650739.png" alt="image-20220414111650739"></p>
<p>复用/解复用技术:</p>
<p><strong>将多条运输连接上的数据汇集到一条网络连接上传输</strong>。本来逻辑上是有多个进程之间的通讯线路的，但通过复用（标识两者之间）只需要一条线路即可，在目标端对所有的信息解复用，分发给不同的应用进程</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414112948542.png" alt="image-20220414112948542"></p>
<ul>
<li>因此套接字仅为本主机的IP和端口，因此即使源IP和端口不同，目标相同，那么都将定位到相同的socket</li>
<li>但TCP捆绑4元组，只要有一个不一样，就是不同的socket</li>
</ul>
<h2 id="3-3-无连接传输：UDP">3.3 无连接传输：UDP</h2>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414113438493.png" alt="image-20220414113438493"></p>
<p>仅仅在IP上增加了复用和解复用功能</p>
<p>事务性：一次往返就结束</p>
<p>要在UDP上提供可靠传输，既利用UDP的高效，又要可靠，那么<strong>只能在应用层增加可靠性</strong><br>
<em>(没有第三种协议，因为TCP、UDP能够支持85%以上的应用，再增加会出现协调等问题)</em></p>
<h3 id="UDP-报文格式">UDP 报文格式</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414114016128.png" alt="image-20220414114016128"></p>
<p><img src="https://img-blog.csdnimg.cn/20200420235146636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE0Mjc5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>数据报</strong>：无连接的，<strong>每个数据单元都是独立发送的</strong></p>
<p><strong>校验和</strong>是验证报文传输过程中有没有出错，如果发现校验不对，那么这个<strong>UDP报文会被丢弃</strong></p>
<blockquote>
<p>在计算校验和的时候，<strong>需要在UDP数据报之前增加12字节的伪首部</strong>，伪首部并不是UDP真正的首部。<strong>只是在计算校验和，临时添加</strong>在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。这样的校验和，既检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。</p>
</blockquote>
<p><strong>UDP报文的头部小，固定的8个字节的头部，如上，64 bit</strong>。<strong>载荷即有效传输的数据部分占比大</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414115052105.png" alt="image-20220414115052105"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220414115737846.png" alt="image-20220414115737846"></p>
<p>将报文段（<strong>包含数据和头部，甚至有一些IP的伪头部</strong>）切分成<strong>若干个16 bit</strong>，将所有的16 bit数字<strong>加起来</strong>，注意求和时高位有进位需要<strong>进位回滚</strong>（<em>将进到更高位的1加到最低位上去</em>）。最后和再取反码，得到校验和。</p>
<p>收到数据报校验时，计算出所有的和，<strong>然后再加上校验和，得到全1，0xFFFF</strong>，那么说明没有出错（可能有残存错误）</p>
<h2 id="3-4-RDT-可靠数据传输原理">3.4 RDT 可靠数据传输原理</h2>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415114523805.png" alt="image-20220415114523805"></p>
<p>RDT在有些网络中在网络层实现，通常是由TCP在传输层实现</p>
<p>要向上层应用提供可靠的服务，但是所依赖的下层服务却是不可靠的 (best effort)。</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415114859805.png" alt="image-20220415114859805"></p>
<p><strong>渐进地开发RDT</strong>：先假设下层是完全可靠的，再逐个去掉假设，变成不可靠的，从而处理这个不可靠，再将其变成可靠，逐个进行，直到所有假设都去掉</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415115209087.png" alt="image-20220415115209087"></p>
<h3 id="RDT-1-0">RDT 1.0</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415115526494.png" alt="image-20220415115526494"></p>
<p>仅仅是封装和解封装即可</p>
<h3 id="RDT-2-0">RDT 2.0</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415115721842.png" alt="image-20220415115721842"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415120013739.png" alt="image-20220415120013739"></p>
<p>使用<strong>校验和</strong> <em>checksum</em>来检验错误</p>
<ul>
<li>发送方要编码检错，接收方要解码校验</li>
<li>接收方要告诉发送方，是<strong>正确的ACK <em>Acknowledgment</em></strong>，还是<strong>错误的NAK  <em>Negative Acknowledgment</em></strong></li>
<li>发送方要保存副本，ACK则无需处理，等待上层有没有新的调用，NAK则重新发送副本（<strong>检错重传</strong>）</li>
</ul>
<h3 id="RDT-2-1">RDT 2.1</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415121524024.png" alt="image-20220415121524024"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415121855666.png" alt="image-20220415121855666"></p>
<p>但是<strong>显然ACK/NAK也是可能出错的</strong>【<em>这个信息同样是需要校验的，校验和</em>】，因此发送方可能无法判断接收方返回的信息是什么</p>
<ul>
<li>因此对发送的packet<strong>编号0和1</strong>【在01之间切换即可】，发送方先发送p<sub>0</sub></li>
<li>接收方返回的信息ACK出错了，<strong>发送方无法识别，则发送方认为是NAK，再发一次p<sub>0</sub></strong></li>
<li>接收方本来在等待编号1，但收到<strong>相同编号的内容</strong>，因此知道是ACK发送失败，因此将收到的<strong>重复信息丢弃</strong>，但仍然<strong>再返回ACK确认</strong></li>
</ul>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415122203332.png" alt="image-20220415122203332"></p>
<p><strong>停止等待协议 <em>stop-and-wait protocol</em></strong> ：每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<h3 id="RDT-2-2">RDT 2.2</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415170654967.png" alt="image-20220415170654967"></p>
<p><strong>取消NAK</strong>，而是对<strong>ACK编号</strong>，使用<strong>前一个分组</strong>（即最后一个正确接收的分组）的<strong>ACK作为该分组的NAK</strong></p>
<p>这样可以为后续一次发送多个分组做好准备</p>
<p>同理ACK传输错误和上面RDT 2.1一样处理即可</p>
<h3 id="RDT-3-0">RDT 3.0</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415172035771.png" alt="image-20220415172035771"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415173250336.png" alt="image-20220415173250336"></p>
<p>增加了分组可能丢失的情况</p>
<p><strong>超时重传机制</strong>：重传时间一般设置为<strong>比正常一个往返稍长一点的时间</strong>，一旦超过这个时间，一般就能确定分组丢失，然后重传即可</p>
<ul>
<li><strong>数据链路层的timeout一般是确定的</strong>，因为就是在两个节点之间传输</li>
<li><strong>而传输层的timeout是自适应的</strong>，即需要根据情况调整，因为中间可能跨越的节点数目会变化</li>
</ul>
<p>如果是ACK丢失了，那么重传会导致数据重复问题，但接收方可以根据分组序号知道重复，从而丢弃即可</p>
<blockquote>
<p>在上面的有限状态机图中，右上角可以看到如果收到的ACK乱码/与发出的编码不匹配，说明需要重发，但这样是空，即不做处理，原因是想通过超时来处理，因为没有收到正确的，最终会导致超时，从而重发</p>
</blockquote>
<p><strong>设置一个合律的timeout很重要</strong>，如果设置时间太短了，也<strong>能正常工作</strong>，但会导致分组的发送和应答<strong>重复</strong>，<strong>效率低</strong>，如下</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415173911741.png" alt="image-20220415173911741"></p>
<p>RDT 3.0对于停止等待协议是<strong>完备的</strong>，可以处理所有的情况</p>
<h3 id="停止等待协议的问题">停止等待协议的问题</h3>
<p><strong>但停止等待协议的效率很低</strong>，特别是在<strong>信道容量（同时能容纳的“车“的数量，等于TR，<em>R是带宽，T是信道从头到尾传输的时间</em>）很大时</strong>，就像告诉公路很长，其中同一时间可以容纳很多车辆前后排列，但如果一次仅仅一辆车在行驶，行驶出高速公路后再让下一辆车上高速，显然效率太低了</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415174936461.png" alt="image-20220415174936461"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415175324810.png" alt="image-20220415175324810"></p>
<p><strong>传输时间=分组长度/链路带宽</strong></p>
<p>可见，传输时间远小于往返延迟RTT，因此时间利用率很低<strong>0.027%</strong>，只有传输时间是在忙的，其他时间都是空闲的，等待信息的返回</p>
<p><strong>有效吞吐=带宽*时间利用率=270kbps</strong>，相当于1Gbps的链路只用到了270kbps</p>
<h3 id="流水线协议">流水线协议</h3>
<p><strong>流水线协议 <em>pipeline protocol</em></strong> ：一次发送多个未经确认的分组</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415180455259.png" alt="image-20220415180455259"></p>
<h4 id="滑动窗口协议">滑动窗口协议</h4>
<p><em>Sliding-window protocol</em></p>
<table>
<thead>
<tr>
<th></th>
<th>发送窗口大小</th>
<th>接收窗口</th>
</tr>
</thead>
<tbody>
<tr>
<td>停止等待协议</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>流水线协议——GBN</td>
<td>&gt;1</td>
<td>1</td>
</tr>
<tr>
<td>流水线协议——SR</td>
<td>&gt;1</td>
<td>&gt;1</td>
</tr>
</tbody>
</table>
<h4 id="发送窗口">发送窗口</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415180604097.png" alt="image-20220415180604097"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415181334075.png" alt="image-20220415181334075"></p>
<p><strong>发送窗口是发送缓冲区的子集，是指发送但未确认的分组</strong><br>
上层应用可以继续将要发送的分组存放在发送缓冲区，当发送后发送窗口的<strong>前沿便移动一格</strong>，最大可以到发送缓冲区的大小</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415181718493.png" alt="image-20220415181718493"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415195728321.png" alt="image-20220415195728321"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415195859092.png" alt="image-20220415195859092"></p>
<h4 id="接收窗口">接收窗口</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415201457064.png" alt="image-20220415201457064"></p>
<p><strong>接收窗口=接收缓冲区</strong></p>
<p>【<strong>SR和GBN原理一样，都是序号最小的到来才移动，并且窗口中要包含到来的分组序号才会接收并返回ACK，否则丢弃</strong>】</p>
<h5 id="Go-Back-N">Go-Back-N</h5>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415200400877.png" alt="image-20220415200400877"></p>
<p>GBN接收窗口大小是1，0，1分别到来，然后接收方分别接收<strong>解封装，并将数据data交给上层</strong>，再返回ACK<sub>0</sub>，ACK<sub>1</sub>，<strong>接收窗口向右移动</strong>，但如果下一个到来的是3而不是2，说明乱序，那么接收方会把3号分组丢弃，然后<strong>发送顺序到来的序号最大的分组的确认</strong>【<em><strong>累计确认</strong>，表明这个序号及以前的分组已经接收</em>】即ACK<sub>1</sub>，接下来又来了4号分组，同样丢弃并且返回ACK<sub>1</sub></p>
<h5 id="Selective-repeat">Selective repeat</h5>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415200308739.png" alt="image-20220415200308739"></p>
<p>SR中滑动窗口大于1，比如上面为5，先到了0，那么接收窗口右移一格，包含12345，然后返回ACK<sub>0</sub>，顺序到来1，接收窗口再右移一格，包含23456，返回ACK<sub>1</sub>，但接下来到来3，说明乱序，但由于接收窗口中可以包含3，说明可以接收3，那么会返回ACK<sub>3</sub>【<em><strong>非累计确认</strong>，仅仅是这个分组的</em><em>独立确认</em>**】，但接收窗口不移动，仍然包含23456，接下来到来4，返回ACK<sub>4</sub>,，接收窗口仍不移动，只有接收窗口中序号最小的到来才会导致移动。<strong>如果</strong>这时候来了2，会返回ACK<sub>2</sub>，因为此时234都到了，那么<strong>接收方会将234一起有序的交给上层</strong>（<em>要<strong>有序</strong>交给上层，因此在<strong>乱序时要缓存</strong></em>），并且接受窗口右移3格</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415201858858.png" alt="image-20220415201858858"></p>
<h4 id="异常情况">异常情况</h4>
<h5 id="Go-Back-N-重发N">Go-Back-N 重发N</h5>
<p>出现了前面的2号没有收到，收到3时接收方返回ACK<sub>1</sub>，那么发送方的<strong>发送窗口不能移动</strong><br>
【<em>但是注意，如果此时发送窗口&lt;发送缓冲区，那么<strong>发送缓冲区内的分组是可以被发送的</strong>，被发送后进入发送窗口</em>。<em>同理如果缓冲区中的分组未满，那么上层是可以将新的分组放到发送缓冲区的</em>】那么<strong>2号分组的计时器会超时timeout</strong>，因此发送方需要将<strong>发送窗口</strong>（即已发送但未确认的分组）<strong>全部再顺序发送一遍</strong>【因为GBN中2号分组没到，那么后面的所有分组都会被丢弃】</p>
<p>【注意：GBN中只有一个计时器，即在滑动窗口<strong>大小从0变成1时启动一个计时器</strong>，同时也只需要<strong>对最小序号的分组计时</strong>即可。当收到最小序号的ACK时，那么会把<strong>计时器重置，发送窗口右移动</strong>；如果收到ACK后，窗口大小变成0，那么关闭计时器；在超时重发时也会重置计时器】👉详见下面的FSM</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415205342634.png" alt="image-20220415205342634"></p>
<h5 id="Selective-repeat-选择性重发">Selective repeat 选择性重发</h5>
<p>出现了前面2号分组没收到的情况，但34号分组已经收到，<strong>那么2号分组会超时timeout，那么2号分组会被单独重发</strong>，但34号分组的计时器因为收到了确认ACK，所以不会被重发但注意发送方的<strong>发送窗口仍然是不能移动的</strong>，因为2没有被确认，<strong>2被确认后，发送窗口同样移动3格</strong></p>
<p>【注意：SR的<strong>每一个分组</strong>发送后都会有一个计时器<strong>分别计时</strong>，因此较为复杂】</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415205709242.png" alt="image-20220415205709242"></p>
<hr>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415204005412.png" alt="image-20220415204005412"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415204834260.png" alt="image-20220415204834260"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415205133761.png" alt="image-20220415205133761"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415205831311.png" alt="image-20220415205831311"></p>
<h4 id="思考题">思考题</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220415210649113.png" alt="image-20220415210649113"></p>
<p>对于SR，会出现如上图b的情况，因此在最坏的情况下即发送方发出的所有报文均被接收方接收，但ACK报文全部没有返回【关键是最小序号的ACK没有返回到发送方】，这时发送窗口不变，接收窗口右移发送窗口的大小，一旦超过了报文的序号，那么就会出现问题，一段的序号0的报文发给了下一段0的报文</p>
<p><strong>因此要求的是N<sub>S</sub>+N<sub>R</sub>≤2<sup>n</sup>（其中序列号为0~2<sup>n</sup>-1）</strong><br>
[因此如果<strong>SR中两个窗口大小一样</strong>的话，<strong>每个最大只能是2<sup>n</sup>/2=2<sup>n-1</sup></strong>；<strong>GBN中N<sub>R</sub>=1，因此发送窗口最大为2<sup>n</sup>-1</strong>]</p>
<h2 id="3-5-面向连接的传输：TCP">3.5 面向连接的传输：TCP</h2>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422094901539.png" alt="image-20220422094901539"></p>
<p><strong>MSS</strong> <em>maximum segment size</em> **最大报文段大小 **</p>
<p>MSS是TCP层交互给IP层最大分段大小，不包含TCP报头，只包含数据。</p>
<p>对于以太网，数据的MTU最大传输单元是1500B，因此应用进程的数据太大是无法被链路层的帧封装的，所以需要拆分。</p>
<p>应用进程的数据到了TCP实体后要根据MSS划分成不同的报文段，并且在每一个前面加上TCP头部</p>
<p><strong>全双工</strong>（<em>Full Duplex</em>）全双工指可以同时（瞬时）进行信号的<strong>双向传输</strong>（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p>
<blockquote>
<p>单工就是在只允许甲方向乙方传送信息</p>
</blockquote>
<h3 id="TCP报文段结构">TCP报文段结构</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422142240682.png" alt="image-20220422142240682"></p>
<p>TCP头部长度<strong>至少20 B</strong>，但还有一些可选项以一起构成头部，其中的<strong>首部长度</strong>就记录了头部的长度，用以区分出数据部分</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422143005451.png" alt="image-20220422143005451"></p>
<ul>
<li>
<p><strong>序号</strong>指的是一个TCP数据报的数据部分的第一个字节在整个字节流中的偏移量，字节为单位。</p>
<p>即指的是segment中第一个字节的在整个字节流中的编号，<strong>而不是segment的编号</strong></p>
<p>此外序号通常不是从0开始，而是开始建立TCP连接时，<strong>双方随机选择序列号</strong>。防止被攻击者猜到，或与其他冲突，所以设置随机</p>
</li>
<li>
<p><strong>确认号</strong>是指确认n-1及以前的字节，比如ACK 555，那么就表示554及之前的都已经收到了，期待555，<em>类似GBN</em>，也是<strong>累计确认</strong>：该序列号之前的所有字节均已被正确接收到</p>
</li>
</ul>
<p>Q：接收方如何处理乱序到达的Segment？</p>
<p>A：TCP规范中没有规定，由TCP的实现者做出决定，<strong>可以缓存，也可以直接抛弃</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422143513814.png" alt="image-20220422143513814"></p>
<h3 id="TCP往返延迟RTT和超时">TCP往返延迟RTT和超时</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422143750280.png" alt="image-20220422143750280"></p>
<p>动态自适应地改变计时器的时间</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422144241845.png" alt="image-20220422144241845"></p>
<p>1-α&lt;1，因此随着测量的增加，前面的SampleRTT对平均值的影响会越来越小，而逐步过渡到后面的SampleRTT</p>
<p>$EstimatedRTT= (1- \alpha)<em>EstimatedRTT+\alpha</em>SampleRTT$</p>
<p>右边的平均RTT是指之前计算出来的平均RTT</p>
<p><strong>推荐值α=0.125</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422144637496.png" alt="image-20220422144637496"></p>
<p>计算平均值的同时计算<strong>SampleRTT偏离平均值的平均情况</strong>，类似一种方差，称为安全边界时间DevRTT</p>
<p>$DevRTT= (1-\beta)<em>DevRTT+\beta</em>|SampleRTT-EstimatedRTT|$</p>
<p><strong>推荐值β=0.25</strong></p>
<p>最终得到合适的超时时间间隔为平均RTT+<strong>4倍</strong>的安全边界</p>
<p>$TimeoutInterval = EstimateRTT+4*DevRTT$</p>
<h3 id="TCP可靠数据传输">TCP可靠数据传输</h3>
<p><strong>TCP采用pipe-line 是GBN和SR的混合体</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422145815666.png" alt="image-20220422145815666"></p>
<p>RDT:</p>
<ul>
<li><strong>流水线机制</strong></li>
<li><strong>累计确认</strong>：是对这个字节的期待</li>
<li><strong>TCP使用单一重传定时器</strong>：仅一个计时器</li>
</ul>
<p>触发重传：</p>
<ul>
<li>
<p><strong>超时</strong>：只发生最早的那个未确认的段，即发生超时的这个段</p>
<p>【超时定时器是比较保守的，在4倍偏差，因此如果超时，可以有极大的把握确定报文丢失】</p>
</li>
<li>
<p><strong>重复的ACK</strong>：收到了<strong>1个正确</strong>ACK，然后又收到<strong>3个冗余</strong>的重复ACK，那么重传，而此时超时定时器还没超时，因此称为<strong>快速重传</strong></p>
</li>
</ul>
<h4 id="简化的TCP-不考虑重复ACK-流量控制-拥塞控制">简化的TCP:不考虑重复ACK,流量控制,拥塞控制</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422151122843.png" alt="image-20220422151122843"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422151356578.png" alt="image-20220422151356578"></p>
<p>NextSeqNum相当于滑动窗口的前沿</p>
<p>SendBase相当于滑动窗口的后沿。</p>
<p>只不过TCP中的窗口<strong>以字节为单位</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422151826809.png" alt="image-20220422151826809"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422151903338.png" alt="image-20220422151903338"></p>
<p><strong>累计确认</strong>，因此即使ACK=100没到，也没关系，ACK=120就能代表ACK=100</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422152059304.png" alt="image-20220422152059304"></p>
<ol>
<li>
<p>到了一个报文段后等待500 ms，如果第二个报文段在500 ms没来，那么发送第一个的ACK</p>
</li>
<li>
<p>如果上面等待过程中<strong>第二个连续</strong>的报文段到达，立即发送第二个报文段的累计确认，<strong>同时确认两个报文段</strong></p>
</li>
<li>
<p><strong>乱序到达</strong>，需要的一个报文段比如第一个字节位置为y<sub>0</sub>，而到达了第一个字节大于y<sub>0</sub>的，说明乱序，<strong>立即发送重复的ACK=y<sub>0</sub>，表示对y<sub>0</sub>的期待，让发送方重发</strong></p>
</li>
<li>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422152825411.png" alt="image-20220422152825411">如果在3的情况中，到达了能够完全补充gap，即y<sub>0</sub>到乱序报文起始处的报文，那么立即发送乱序到达的报文的后面一个字节的的位置ACK，累计确认</p>
<p>如果是部分补齐，如上，在立即发送部分补齐的报文的后一个字节的ACK，让发送方快点补齐</p>
</li>
</ol>
<h4 id="快速重传">快速重传</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422153256354.png" alt="image-20220422153256354"></p>
<p><strong>快速重传</strong>：在定时器超时之前重传</p>
<p>收到1个正确ACK后又收到<strong>3个</strong>重复ACK，那么说明丢失的可能性非常大，需要重传</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422153708762.png" alt="image-20220422153708762"></p>
<blockquote>
<p>Q：为什么是三次？</p>
<p>A：因为无法判断是因为乱序还是丢失，重传1到2次更可能是乱序，3次及以上更可能是因为丢失</p>
</blockquote>
<h3 id="TCP流量控制">TCP流量控制</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422154219979.png" alt="image-20220422154219979"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422154228603.png" alt="image-20220422154228603"></p>
<p><strong>接收buffer</strong>通常默认为<strong>4096</strong></p>
<p>接收方返回ACK时在receive window中记录其空闲的buffer的大小，从而发送方会<strong>限制其发送缓冲区中未确认的字节个数≤receive window值</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422154354055.png" alt="image-20220422154354055"></p>
<p><strong>piggyback捎带技术</strong>，即发送方和接收方是随时变化的，客户端发送数据给服务器，服务器也会发送数据给客户端，所以如果发送一次对方要返回一个确认，然后又发送数据回来，会比较麻烦，因此可以将确认放在数据中一起发送回来，即捎带</p>
<h3 id="TCP连接管理">TCP连接管理</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422154951753.png" alt="image-20220422154951753"></p>
<p><strong>连接建立的本质</strong>：知道和要对方通信，准备好资源，控制变量做置位（特别是连接的初始序号#seq，对方的receive buffer的大小）</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422155548014.png" alt="image-20220422155548014"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422155913681.png" alt="image-20220422155913681"></p>
<p>二次连接不可行</p>
<h4 id="三次握手">三次握手</h4>
<p><strong>理论上3次是最少需要的</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422162117847.png" alt="image-20220422162117847"></p>
<ol>
<li>
<p>Client发送连接建立请求SYN=1并携带它将要从序号为x处开始传Seq=x</p>
</li>
<li>
<p><strong>服务器会分配缓存</strong></p>
<p>server需要对这个信息进行ACK，ACKNum=x+1【期望x+1及之后的数据】</p>
</li>
<li>
<p>然后server需要SYN=1并将自己从序号为y处开始传Seq=y告诉client</p>
<p><strong>这两个信息2，3可以合并在一起</strong>SYN&amp;ACK**(piggyback)**</p>
</li>
<li>
<p>然后client对server的y进行确认ACKNum=y+1【期望y+1及之后的数据】</p>
<p><strong>这个ACK通常会和第一次数据传递放在一起</strong></p>
</li>
</ol>
<blockquote>
<p>Q：会不会在三次握手的第二步服务器就会分配资源？</p>
<p>A：会分配，会保留一段时间直到确认这个ACK不会再建立了（SYN泛洪攻击，DDoS）</p>
</blockquote>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422161237312.png" alt="image-20220422161237312"></p>
<ol>
<li>第一种情况，因为需要3次握手，因此不会存在半连接</li>
<li>第二种情况，因为不会存在半连接，所以连接不存在，延迟到达的data会被丢弃</li>
<li>此外第三种情况：假设客户端使用555端口与服务器80端口建立连接，在第二种情况的基础上，如果data卡了很久才到达服务器，而此时正好客户端又用555端口和服务器80端口建立连接了，那么连接存在，且收到数据。
<ul>
<li><strong>如果序号都是从0开始的话</strong>，那么这个老数据会被当成当前需要的数据，<strong>而产生错误</strong>。</li>
<li>因此<strong>每次选择随机的开始序号</strong>，可以避免老的滞留的数据对连接的影响，比如老数据从x开始，而新的开始序号是x+1，那么老的数据肯定会被抛弃，因为都不在连接的序号范围内(≥x+1)</li>
<li>当然有可能随机选择的序号正好又包含老数据，但概率极小，那这就没有办法了👉”<strong>网络不能解决所有问题</strong>“</li>
</ul>
</li>
</ol>
<h4 id="四次挥手">四次挥手</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422162647488.png" alt="image-20220422162647488"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220422162755541.png" alt="image-20220422162755541"></p>
<p><strong>对称释放，并不完美</strong></p>
<p>四次挥手是由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了<strong>连接的一端在结束它的发送后还能接收来自另一端数据的能力</strong></p>
<p>[<strong>结束发送指的是不再发送数据，但可以对对方的请求作出应答</strong>]</p>
<p>TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(Four-way handshake)，<strong>客户端或服务端均可主动发起挥手动作</strong>。</p>
<p><img src="https://pics7.baidu.com/feed/8435e5dde71190ef08c7447eca4fb81efdfa602b.jpeg?token=74e81457ce3c2f49b48814839e548194&amp;s=5EA83C6229C6E0CA5A7454CA0000E0B1" alt="img"></p>
<p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。</p>
<blockquote>
<p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</p>
<blockquote>
<p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。</p>
<blockquote>
<p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p>
</blockquote>
<p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。</p>
<blockquote>
<p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong>TIME_WAIT</strong> <strong>（时间等待）状态</strong>。</p>
<blockquote>
<p>TIME-WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<p>注意 ：这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入</strong> <strong>CLOSED</strong> <strong>状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，<strong>服务端会重新发送 FIN 报文给客户端</strong>，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。**服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。**因此服务器到客户端的连接关闭，整个 TCP 连接关闭</p>
<blockquote>
<p><strong>两次挥手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次挥手</strong>。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。</p>
</blockquote>
<h2 id="3-6-拥塞控制原理">3.6 拥塞控制原理</h2>
<h3 id="拥塞的原因-代价">拥塞的原因/代价</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425205612515.png" alt="image-20220425205612515"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425210620116.png" alt="image-20220425210620116"></p>
<p>无限大的缓存，则报文不会丢失</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425210802389.png" alt="image-20220425210802389"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425210939064.png" alt="image-20220425210939064"></p>
<p>掌握路由器空闲空间，代价太大</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425211229636.png" alt="image-20220425211229636"></p>
<p>当网络拥塞时，会出现超时重传，丢失重传等，因此此时想要达到更高的传输速率，输入的带宽要增大，比如为了能每秒传输100个分组，那么输入到链路的分组数目会大于100个</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425211410601.png" alt="image-20220425211410601"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425211614033.png" alt="image-20220425211614033"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425211804919.png" alt="image-20220425211804919"></p>
<p>当分组经过了很多路由器，但在后面的一个路由器被抛弃了，那么它在前面所做的努力都会被浪费，这在网络拥塞时更加可惜，因为资源有限，有限的资源还被浪费了</p>
<h3 id="拥塞控制方法">拥塞控制方法</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425211920911.png" alt="image-20220425211920911"></p>
<h4 id="ATM-采用网络辅助的拥塞控制">ATM 采用网络辅助的拥塞控制</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220425214145348.png" alt="image-20220425214145348"></p>
<p><strong>ATM</strong> <em>Asynchronous Transfer Mode</em> 异步传输模式。具有分组交换和电路交换的优点，对应于OSI协议参考模型的第2层。</p>
<p>数据交换的单位是<strong>信元</strong>，可以认为是小分组，<strong>53B，5B的头部，48B的载荷</strong>，因此存储转发的时间非常短即可完成。</p>
<p>在电路交换中，每个节点花费1bit的存储时间，在分组交换中每个节点花费一个分组的存储时间，而在 ATM 中信元比 1bit 大，比一个分组小，只花费53B的存储时间。<strong>所以网络调度很容易，兼具两种交换网络的特性</strong></p>
<p>ATM 网络具有很多模式，如 <strong>ABR</strong> <em>available bit rate</em> <strong>弹性服务</strong>：如果网络轻载，那么用户可以使用网络的可用带宽，但当网络拥塞时，用户只能使用网络承诺的带宽，不能超过如1 Mbps</p>
<p>发送方在发送数据信元中<strong>间隔插入</strong>资源管理信元 <strong>RM</strong> ，其中的 bit 被交换机设置：</p>
<ul>
<li><strong>NI bit</strong> : <em>no increase in rate</em> 轻微拥塞时</li>
<li><strong>CI bit</strong> : <em>congesting indication</em> 拥塞提升
<ul>
<li>也可能交换机将 RM 信元前面的数据信元的 <strong>EFCI bit</strong> <em>Explicit Forward Congestion Indication</em>  <code>显性前向拥塞指示</code> 置为1，那么将由接收端把 RM 信元的 CI bit 置1</li>
</ul>
</li>
<li><strong>ER</strong> 2 Byte : <em>explicit rate</em> 记录两个主机通讯过程中的交换机所能支持的最小带宽[<em>每经过一个就看是否更小，更小就修改，更大则不改</em>]，因此发送方根据最小带宽发送，就不会发送拥塞</li>
</ul>
<p>接收端不修改 RM 信元，并将其返回给发送方，从而发送方可用知道网络状况，控制发送速率</p>
<h2 id="3-7-TCP-拥塞控制">3.7 TCP 拥塞控制</h2>
<h4 id="TCP-采用端到端的拥塞控制">TCP 采用端到端的拥塞控制</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426080902560.png" alt="image-20220426080902560"></p>
<p>端系统自己感知拥塞，网络核心负担低</p>
<h3 id="如何检测拥塞">如何检测拥塞</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426081045830.png" alt="image-20220426081045830"></p>
<p><strong>超时即认为是拥塞</strong></p>
<ul>
<li><strong>网络拥塞</strong>，段被丢弃：概率大，判断正确</li>
<li><strong>段出错</strong>，段被丢弃： 概率小，判断错误，但概率小，对整个影响不大</li>
</ul>
<p>出现**3次重复的冗余 **ACK <strong>即认为轻微拥塞</strong>，即出现丢失，但还有一定传输能力(<em>后面3个段都到达了，此时还没超时，因为超时时间比较保守，加上4倍偏差</em>)</p>
<ul>
<li>第一个 ACK 正确</li>
<li>后续 1~2 个 ACK ，会被认为是乱序，<strong>乱序的可能性更大</strong></li>
<li>出现第 3 个 ACK ，<strong>大概率是段丢失</strong></li>
</ul>
<h3 id="速率控制方法">速率控制方法</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426082135576.png" alt="image-20220426082135576"></p>
<p>$rate = \frac{CongWin}{RTT} Byte/sec$</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426091116543.png" alt="image-20220426091116543"></p>
<p>MSS 是最大报文长度</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426091444944.png" alt="image-20220426091444944"></p>
<p>保证发送窗口是<strong>拥塞窗口和对方接收窗口的最小值</strong>，从而同时满足拥塞控制和流量控制</p>
<h4 id="策略">策略</h4>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426091628679.png" alt="image-20220426091628679"></p>
<p><strong>SS</strong> <em>slow start</em> 慢启动</p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426091752613.png" alt="image-20220426091752613"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426091901163.png" alt="image-20220426091901163"></p>
<p>每收到一个 ACK，拥塞窗口加 1 == 下一次的拥塞窗口是上一次的两倍</p>
<p><strong>初始速率很慢，但是快速攀升</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426092734182.png" alt="image-20220426092734182"></p>
<ul>
<li><strong>AI</strong> <em>Additive Increase</em> <strong>加性增</strong>：到达 SS 的阈值后，每个RTT将 CongWin 增大一个 MSS 线性地探测-----<strong>拥塞避免阶段</strong></li>
<li><strong>MD</strong> <em>Multiplicative Decrease</em> <strong>乘性减</strong>：
<ul>
<li>当<strong>发送超时</strong>后，将 CongWin 降为 1 MSS，开始 SS 并将 CongWin / 2 作为 SS 倍增的阈值。</li>
<li>当<strong>收到 3 个冗余 ACK</strong> 时，直接将<strong>阈值降为 CongWin / 2，并将 CongWin 设置为 阈值 + 3</strong>【<em>+3是因为返回 3 个 ACK 所以后面有三个已经确认了</em>】，然后直接线性增加 1【<em>此时 CongWin &gt; 阈值</em>】，而无需从 1 开始 SS。</li>
<li>当收到重复 ACK 时，什么都不做，<strong>只是对重复的个数进行计数</strong>，为上面的情况做好准备</li>
</ul>
</li>
</ul>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426093527640.png" alt="image-20220426093527640"></p>
<h3 id="TCP-吞吐量">TCP 吞吐量</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426094855058.png" alt="image-20220426094855058"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426094628828.png" alt="image-20220426094628828"></p>
<p>不考虑 SS 阶段，因为指数增加，时间可以忽略不计</p>
<p>因此平均吞吐量为 <strong>0.75 W / RTT</strong></p>
<h3 id="TCP-公平性">TCP 公平性</h3>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426095036146.png" alt="image-20220426095036146"></p>
<p>TCP 是公平的，<strong>均分瓶颈带宽</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426165108114.png" alt="image-20220426165108114"></p>
<p>以两个连接 1 和 2 共享链路为例：</p>
<p>短时间是可能超过斜线的，因为路由器存在缓存，但长期是不可能的，分组会被抛弃。</p>
<p>当检测到拥塞后（这里不看 SS 只看拥塞避免阶段，SS 时间很短），两者都会回到斜线内部，然后 45° 地增加带宽(即两者都逐步增加1 MSS[假设两者的 MSS 是一样的])，<strong>最终可以达到两者均分带宽</strong></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426165337244.png" alt="image-20220426165337244"></p>
<p>上述两种情况就体现了一定的不公平性，还有一种情况，如果 AA’ 的 MSS 小于 BB’ 的 MSS 那么最终两者也无法达到均分带宽</p>
<p><strong>因此 TCP 的公平是大致上的公平</strong></p>
<h2 id="总结">总结</h2>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426165814628.png" alt="image-20220426165814628"></p>
<p><img src="https://screen-shot.obs.cn-north-4.myhuaweicloud.com/image-20220426165945346.png" alt="image-20220426165945346"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处。
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://wbl-z.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/3%20%E4%BC%A0%E8%BE%93%E5%B1%82/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/1%E6%A6%82%E8%BF%B0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            1概述
          
        </div>
      </a>
    
    
      <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/readme/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">readme</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i>  zzb
      </li>
    </ul>
    <ul>
      <li>
        R<i class="ri-heart-fill heart_icon"></i>Z
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="wbl-z&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    
      <li class="nav-item">
          <a href="https://github.com/wbl-z" target="_blank" class="my_link_li">
              <img src="/images/github.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://blog.csdn.net/m0_51691879" target="_blank" class="my_link_li">
              <img src="/images/csdn.png">
          </a>
      </li>
      
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>