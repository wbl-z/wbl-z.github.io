<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="技术，编程，代码，教程，Java" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>web前端复习提纲 |  wbl-z&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/logo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?edcb9d2dbc760f6eeab5900f9b363881";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-web前端复习提纲+2023回忆"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  web前端复习提纲
</h1>
 

      
    <div class="article-author"  style="text-align: center ;font-size:20px" >
        作者： wbl
    </div>


    </header>
     
    <div class="article-meta">
      <a href="/web%E5%89%8D%E7%AB%AF/web%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2+2023%E5%9B%9E%E5%BF%86/" class="article-date">
  <time datetime="2023-02-23T14:02:10.000Z" itemprop="datePublished">2023-02-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">19.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">72 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="web前端复习提纲-2023回忆">web前端复习提纲+2023回忆</h2>
<blockquote>
<p>参考自 zhy 的博客 <a target="_blank" rel="noopener" href="https://spricoder.github.io/2021/01/19/2020-Web-Front-End-development/2020-Web-Front-End-development-Exam01-Summary/">2020-Web前端开发-Exam01-Summary - SpriCoder的博客</a></p>
<p>feat: 新增若干内容</p>
</blockquote>
<h1>1. 基础知识</h1>
<h2 id="1-1-Internet">1.1. Internet</h2>
<p>Internet 是在一个通信网络中连接的计算机的大规模集合，通过装置连接起来，相互之间可以通信。</p>
<h3 id="1-1-1-IP">1.1.1. IP</h3>
<p>根据端到端的设计原则，IP 只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。</p>
<h3 id="1-1-2-URI、URL、URN">1.1.2. URI、URL、URN</h3>
<ol>
<li class="lvl-3">
<p>URI(统一资源标识符，Uniform Resource Identifier) 允许资源驻留在 Internet 上的任何位置</p>
</li>
<li class="lvl-3">
<p>URL(统一资源定位符，Uniform Resource Locator) 显示资源副本的位置</p>
</li>
<li class="lvl-3">
<p>URN(统一资源名称，Uniform Resource Name) 是资源的唯一名称</p>
</li>
<li class="lvl-3">
<p><strong>URL、URN 是 URI 的子集，其中 URL 和 URN 有交集。</strong></p>
</li>
</ol>
<span id="more"></span>
<h3 id="1-1-3-DNS">1.1.3. DNS</h3>
<ol>
<li class="lvl-3">
<p>DNS 之前，转换是通过 FTP 到中央服务器上下载 hosts.txt 文件</p>
</li>
<li class="lvl-3">
<p>DNS(Domain Name System) 是一个分布式数据库，本地负责控制整个数据库的部分段，客户向 DNS 服务器请求，得到从域名到 IP 地址的转化。</p>
</li>
<li class="lvl-3">
<p>DNS 是<strong>唯一同时使用 TCP 和 UDP 的</strong></p>
<ul class="lvl-2">
<li class="lvl-5">在 DNS 域中的<strong>主备冗余机制</strong>中，进行<strong>同步通信时使用 TCP 协议</strong>，原因在于其可靠性</li>
<li class="lvl-5">在用户通过浏览器访问 DNS 服务器<strong>请求 IP 地址</strong>时使用 <strong>UDP</strong> 协议</li>
</ul>
</li>
<li class="lvl-3">
<p>工作过程：</p>
<ol>
<li class="lvl-6">客户向域名服务器发起查询请求</li>
<li class="lvl-6">域名服务器本地查询结果
<ol>
<li class="lvl-9">如果找到，则返回</li>
<li class="lvl-9">如果未找到则发送到根域名服务器，根域名服务器查询根域名解析，将包含下一级域名信息的 DNS 地址返回给客户的域名服务器。</li>
</ol>
</li>
<li class="lvl-6">客户的域名服务器根据根域名服务器解析的地址访问下一级 DNS，如此递归逐级查询，直到找到位置。<strong>【迭代查询和递归查询】</strong></li>
<li class="lvl-6">客户的域名 DNS 服务器将查询结果返回客户机。</li>
<li class="lvl-6">客户根据 IP 地址访问目标机。</li>
</ol>
</li>
</ol>
<h3 id="1-1-4-Http1-1、-2、-3-协议">1.1.4. Http1.1、/2、/3 协议</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP1.0</td>
<td><strong>非持续</strong>连接，每一次请求/响应建立并拆除一次连接，即短链接，2 个 RTT 时间，使用 TCP 链接；http 1.0中默认是关闭的，需要在http头加入**“Connection: Keep-Alive”**，才能启用Keep-Alive</td>
</tr>
<tr>
<td>HTTP1.1</td>
<td>支持 keepalive <strong>持久连接</strong>，即长连接，在<strong>相同 TCP</strong> 上通讯，http 1.1中默认启用Keep-Alive，如果加入**&quot;Connection: close &quot;<strong>，才关闭；支持流水线请求，可以不等反馈发送很多信息，不应该与任何服务器或代理保持超过2个连接，目前的主要版本<br />报文</strong>头部不会被压缩**【body 可以】，即使两个 header 非常相似也在重复传输</td>
</tr>
<tr>
<td>HTTP2.0</td>
<td>⼆进制协议而不是⽂本协议；支持 HTTP1.1，在<strong>数据如何封装成帧上有区别</strong>，<strong>头部压缩</strong>，请求和响应<strong>多路复用</strong></td>
</tr>
<tr>
<td>HTTP3.0</td>
<td>和 HTTP2 完全不同，使用 <strong>UDP 协议</strong>，通过重传保证效率<br />**为什么需要 3：**TCP队头阻塞问题；TCP握手时长；IP地址会发生变化 TCP 协议是根据四元组来确定⼀个连接的，需要重新建立连接</td>
</tr>
</tbody>
</table>
<h4 id="1-1-4-1-结构">1.1.4.1. 结构</h4>
<p>HTTP 请求和响应具有相似的结构，由以下部分组成：</p>
<ol>
<li class="lvl-3">
<p>⼀行起始行用于描述要执行的<strong>请求类型</strong>，或者是<strong>对应的状态</strong>，成功或失败。这个起始行总是单行的。</p>
</li>
<li class="lvl-3">
<p>⼀个可选的 <strong>HTTP 头</strong>集合指明请求或描述消息正文。</p>
</li>
<li class="lvl-3">
<p>⼀个<strong>空行指示</strong>所有关于请求的<strong>元数据已经发送完毕</strong>。</p>
</li>
<li class="lvl-4">
<p>⼀个<strong>可选</strong>的包含请求相关数据的<strong>正文</strong> (比如 HTML 表单内容)，或者响应相关的文档。正文的大小有起始行的 HTTP 头来指定。</p>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223163423238.png" alt="image-20230223163423238"></p>
</li>
</ol>
<h4 id="1-1-4-2-请求方法">1.1.4.2. 请求方法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>GET ：从服务器获取URL对应的资源</p>
</li>
<li class="lvl-2">
<p>HEAD ：除了服务器响应中<strong>不能包含消息体</strong>，该方法与GET⼀样。HEAD请求方法作用是<strong>只请求头部</strong></p>
</li>
<li class="lvl-2">
<p>POST ：被设计用来注解、修改URL所对应的资源</p>
</li>
<li class="lvl-2">
<p>PUT ：被设计用来修改或创建资源。当URL对应的资源存在时，则提交的作为新版本，否则新建资源</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2">区别：PUT 方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个 POST 可能会带来额外的影响，比如多次提交订单。</li>
</ul>
</blockquote>
</li>
<li class="lvl-2">
<p>DELETE ：被设计用来删除URL对应的资源</p>
</li>
<li class="lvl-2">
<p>TRACE ：主要用来测试。服务器将最终接收到的请求本身发送回来，作为客户端诊断依据</p>
</li>
<li class="lvl-2">
<p>OPTIONS ：客户端<strong>查询</strong>服务器对与某 URL <strong>允许的通信选项</strong></p>
</li>
<li class="lvl-2">
<p>CONNECT ：保留的方法名，用于代理切换隧道</p>
</li>
</ul>
<h4 id="1-1-4-3-HTTP-头域-头部">1.1.4.3. HTTP 头域/头部</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>通用头标：即可用于请求，也可用于响应，是作为⼀个整体而不是特定资源与事务相关联。</p>
</li>
<li class="lvl-2">
<p>请求头标：允许客户端传递关于自身的信息和希望的响应形式。</p>
</li>
<li class="lvl-2">
<p>响应头标：服务器和于传递自身信息的响应。</p>
</li>
<li class="lvl-2">
<p>实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。</p>
</li>
</ul>
<h4 id="1-1-4-4-响应状态行">1.1.4.4. 响应状态行</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>http协议版本</p>
</li>
<li class="lvl-2">
<p>状态码（三位数字）</p>
</li>
<li class="lvl-2">
<p>状态描述</p>
</li>
</ul>
<p>如 <code>HTTP/1.1 200 OK</code></p>
<p><strong>状态码</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信息响应 (100–199)</p>
</li>
<li class="lvl-2">
<p>成功响应 (200–299)</p>
</li>
<li class="lvl-2">
<p>重定向消息 (300–399)</p>
</li>
<li class="lvl-2">
<p>客户端错误响应 (400–499)</p>
</li>
<li class="lvl-2">
<p>服务端错误响应 (500–599)</p>
</li>
</ul>
<p><strong>常用状态码</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>200 OK</p>
</li>
<li class="lvl-2">
<p>301 Moved Permanently 搜索引擎会删除原页面，收录重定向的页面，并转移权重</p>
</li>
<li class="lvl-2">
<p>302 Found 是一种临时性的重定向，大部分搜索引擎把它作为内部的重定向，不会缓存重定向的结果</p>
</li>
<li class="lvl-2">
<p>400 Bad Request</p>
</li>
<li class="lvl-2">
<p>401 Unauthorized</p>
</li>
<li class="lvl-2">
<p>403 forbidden</p>
</li>
<li class="lvl-2">
<p>404 Not Found 搜索引擎放弃对该链接的索引</p>
</li>
<li class="lvl-2">
<p>500 Internal Server Error</p>
</li>
</ul>
<h2 id="1-2-网络机器人">1.2. 网络机器人</h2>
<ol>
<li class="lvl-3">
<p>网络爬虫是以<strong>自动方式</strong>爬取万维网上信息的计算机程序；主要是用来从网页搜集信息/支持搜索引擎/开展数据分析等等</p>
</li>
<li class="lvl-3">
<p>传统爬虫：传统爬虫从一个或若干初始网页的 URL 开始，获得初始网页上的 URL ，在抓取网页的过程中不断从<strong>当前页面上抽取新的 URL 放入队列</strong> 直到满足系统的一定停止条件</p>
</li>
<li class="lvl-3">
<p><strong>网络爬虫排除标准</strong>：</p>
<p>Robots Exclusion Protocol，网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些不能抓取。</p>
<p>robots 是一个协议。robots.txt 文件是一个文本文件，放置在网站根目录下</p>
</li>
</ol>
<h2 id="1-3-web">1.3. web</h2>
<h3 id="1-3-1-Web-的发展">1.3.1. Web 的发展</h3>
<ol>
<li class="lvl-3">
<p>Web x.0 表示 的是一个阶段，是促成这个阶段的各种技术和相关产品服务的一个称呼</p>
</li>
<li class="lvl-3">
<p>Web1.0 网站提供给用户的内容是网站编辑<strong>进行编辑处理后提供的</strong>，用户阅读网站提供的内容。这个过程是<strong>网站到用户的单向行为</strong>，比如搜狐等，静态网页为主。</p>
</li>
<li class="lvl-3">
<p>Web2.0 则是以加强了<strong>网站与用户</strong>之间的互动，网站内容<strong>基于用户提</strong>供，网站的诸多功能也由<strong>用户参与建设</strong>，实现了网站与用户<strong>双向的交流与参与</strong>，比如博客中国等。</p>
</li>
<li class="lvl-3">
<p>web3.0 是以<strong>主动性、数字最大化、多维化</strong>等为特征的，以<strong>服务</strong>为内容的第三代互联网系统。</p>
</li>
</ol>
<h3 id="1-3-2-Web-前端的发展趋势">1.3.2. Web 前端的发展趋势</h3>
<ol>
<li class="lvl-3">
<p>静态页面 到 动态页面</p>
</li>
<li class="lvl-3">
<p>Ajax 到 JIT(即时编译)，REST，SPA(单页Web应用)</p>
</li>
<li class="lvl-3">
<p>交互、UI、逻辑 到 Nodejs 大前端、同构（同一份代码在浏览器端和服务器端都可以运行）趋势</p>
</li>
</ol>
<h3 id="1-3-3-MEAN">1.3.3. MEAN</h3>
<ol>
<li class="lvl-3">
<p>Mean：Mongo Express Angular Node，是一个 Javascript 平台的现代 Web 开发框架总称</p>
<ol>
<li class="lvl-6">MongoDB 是一个使用JSON 风格存储的数据库，非常适合 javascript。(JSON 是 JS 数据格式 )</li>
<li class="lvl-6">ExpressJS 是一个 Web 应用框架，提供有帮助的组件和模块帮助建立一个网站应用。</li>
<li class="lvl-6">AngularJS 是一个前端 MVC 框架。</li>
<li class="lvl-6">Node.js 是一个<strong>并发异步</strong> <strong>事件驱动</strong>的 Javascript 服务器后端开发平台。</li>
</ol>
</li>
</ol>
<h1>2. 浏览器端</h1>
<h2 id="2-1-HTML-XHTML">2.1. HTML/XHTML</h2>
<ol>
<li class="lvl-3">
<p>HTML：标记语言，结构化特征。</p>
</li>
<li class="lvl-3">
<p><a href = "https://www.cnblogs.com/web-wjg/p/7240985.html">优雅降级与渐进增强</a></p>
<ol>
<li class="lvl-6"><strong>渐进增强（Progressive Enhancement）</strong>：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</li>
<li class="lvl-6"><strong>优雅降级（Graceful Degradation）</strong>：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 <strong>CSS3 的特性构建了一个应用</strong>，然后逐步针对各大浏览器进行 hack 使其可以在<strong>低版本浏览器上正常浏览。</strong></li>
<li class="lvl-6"><strong>向上兼容</strong>和<strong>向下兼容</strong>的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容</li>
</ol>
</li>
</ol>
<h3 id="2-1-1-结构、表现、行为">2.1.1. 结构、表现、行为</h3>
<p><strong>结构：</strong></p>
<ol>
<li class="lvl-3">
<p>DOCTYPE：声明了使用的文档类型定义（DTD）</p>
</li>
<li class="lvl-3">
<p>Head：包含元数据，一般只需要 title 标签</p>
</li>
<li class="lvl-3">
<p>Body：需要渲染的文本</p>
</li>
</ol>
<p><strong>HTML 工作流程</strong>：</p>
<ol>
<li class="lvl-3">
<p>HTML 通过标记符标记要显示的网页的各个部分，通过添加标记符来确定内容格式，从而令浏览器知道如何显示网页</p>
</li>
<li class="lvl-3">
<p>浏览器按顺序阅读 HTML 文件，然后<strong>根据 HTML 标记符解释和显示各种内容</strong>，这就是语法分析过程</p>
</li>
<li class="lvl-3">
<p>HTML 中的超链接功能使得网页之间能够链接起来从而提供跳转功能</p>
</li>
</ol>
<h3 id="2-1-2-基本语法、常用标记">2.1.2. 基本语法、常用标记</h3>
<p><strong>常用标记</strong>：</p>
<p><strong>块级元素</strong>：<code>&lt;h1&gt;~&lt;h6&gt;,&lt;p&gt;,&lt;div&gt;,&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;</code></p>
<p><strong>行内元素</strong>：<code>&lt;a&gt;,&lt;strong&gt;,&lt;b&gt;,&lt;em&gt;,&lt;del&gt;,&lt;span&gt;</code></p>
<ol>
<li class="lvl-3">
<p>注释</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>上线产品不要包含注释：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>注释（明文传播）会提高页面被解读的风险</p>
</li>
<li class="lvl-5">
<p>注释会增加传输带宽消耗</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>title</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>描述网页标题</p>
</li>
<li class="lvl-5">
<p>位于 head 标签之间</p>
</li>
<li class="lvl-5">
<p>精简且语义化强的描述能吸引爬虫</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>meta</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>描述网页<strong>元数据</strong></p>
</li>
<li class="lvl-5">
<p>位于 head 标签之间</p>
</li>
<li class="lvl-5">
<p>其 Charset 属性在实际中非常重要</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>p</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>用于表示段落，位于 body 之间</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>br</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>在 HTML 中，&lt;br&gt;标签没有结束标签。</p>
</li>
<li class="lvl-5">
<p>在 XHTML 中，&lt;br&gt; 标签必须被正确地关闭，比如这样：&lt;br /&gt;。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>a</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>指向其他页面的链接</p>
</li>
<li class="lvl-5">
<p>使用 href 属性来指定目的 url，可以是绝对路径或相对路径</p>
</li>
<li class="lvl-5">
<p>行级元素，<strong>要在 p 或 h1 等块级元素中</strong></p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>img</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-5">
<p>向页面中插入图片</p>
</li>
<li class="lvl-5">
<p>src 属性指定了图片 url</p>
</li>
<li class="lvl-5">
<p>xhtml 还需要 alt 属性</p>
</li>
<li class="lvl-5">
<p>在 a 标签之间放置会变为链接</p>
</li>
<li class="lvl-5">
<p>.git 和 .png 无损，.jpeg 和 .webp 有损</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>table，tr，td，th，caption</p>
<ul class="lvl-2">
<li class="lvl-5">table 代表表体</li>
<li class="lvl-5">caption 是标题</li>
<li class="lvl-5">tr 表示一行，th 表示表头，td 表示值</li>
</ul>
</li>
<li class="lvl-3">
<p>quotation</p>
<ul class="lvl-2">
<li class="lvl-5">blockquote 是段落引用，可以用于 p 标签外将段落变为引用格式（斜体）</li>
<li class="lvl-5">q 是行内引用，可以用于单词两边，效果是添加上双引号</li>
</ul>
<p><strong>为什么不直接用引号而用 &lt;q&gt;</strong>：</p>
<ol>
<li class="lvl-6">
<p><strong>XHTML</strong> 不应该包含字面引号字符，它们应该被写成 &amp;quot</p>
</li>
<li class="lvl-6">
<p>用 &lt;q&gt; 能让我们将 <strong>CSS 样式应用于引号</strong></p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>form</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>用于在网页上创建 GUIs，目的通常是向用户请求信息</p>
</li>
<li class="lvl-6">
<p>其参数指定 js 如何将信息传至服务器</p>
<ul class="lvl-4">
<li class="lvl-8"><strong>action</strong> 指定 submit 按下后数据送往的<strong>地点</strong></li>
<li class="lvl-8"><strong>method</strong> 默认为 <strong>GET</strong>，能以 ?{form_data} 形式传出，data 全为 ASCII 码且不超过 100 字符；POST 将 data 放置于 body 部分</li>
<li class="lvl-8"><strong>target</strong> 指定<strong>响应页面的打开方式（当前或新窗口）</strong></li>
</ul>
</li>
<li class="lvl-6">
<p>form 元素有 button，checkbox，text，radio</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>input</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>强大，但从语义化角度讲<strong>不是好的设计</strong>，因为<strong>具体样式渲染要等读到 type 属性值</strong>才能确定</p>
</li>
<li class="lvl-6">
<p>不需要 JS，H5 新增原生日期、颜色选择器以及其他新类型，提供客户端表单验证机制和旋转框、滑块</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>canvas</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>提供本地绘画功能</p>
</li>
<li class="lvl-6">
<p>可用于图表、图像、动画和像素处理等</p>
</li>
<li class="lvl-6">
<p>支持 2D 和 3D 效果</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>video&amp;audio</p>
<ul class="lvl-2">
<li class="lvl-6">提供非插件式视频&amp;音频支持，可以用 JS 进行操作，CSS 进行渲染</li>
<li class="lvl-6">能像添加图片一样添加</li>
<li class="lvl-6">可以使用内容，有完整的 JS API 供使用</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-html-语义化">2.1.3. html 语义化</h3>
<ol>
<li class="lvl-3">
<p><strong>语义化：根据结构化内容选择合适标签</strong></p>
<ol>
<li class="lvl-6">简单来说就是用特定的标签体现相对应的功能</li>
<li class="lvl-6">将内容和功能展示分离</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>为什么？</strong></p>
<ol>
<li class="lvl-6">有利于 SEO(Search Engine Optimization)</li>
<li class="lvl-6">开发维护体验好</li>
<li class="lvl-6">用户体验好</li>
<li class="lvl-6">更好的可访问性，方便任何设备对代码解析。</li>
</ol>
</li>
</ol>
<h3 id="2-1-4-html5-新特性——为什么选择-H5">2.1.4. html5 新特性——为什么选择 H5</h3>
<ol>
<li class="lvl-3">
<p><strong>语义化</strong>的元素（如header，nav，article，aside，footer标签）</p>
</li>
<li class="lvl-3">
<p><strong>表单验证</strong>功能：<code>&lt;input type=email required&gt;</code></p>
</li>
<li class="lvl-3">
<p><strong>语法简化</strong>：简化了解析的标题<code>&lt;!DOCTYPE html&gt;</code></p>
</li>
<li class="lvl-3">
<p><strong>统一</strong>：支持所有语言。</p>
</li>
<li class="lvl-3">
<p><strong>减少对外部插件的需求</strong> ( 比如 Flash)：支持很多复杂的特性 ( 视频音频图像 ) 而不需要安装插件，<strong>原生支持</strong></p>
<ol>
<li class="lvl-6">插件可能安装失败、被禁用、被屏蔽，或者成为被攻击的对象。</li>
</ol>
</li>
<li class="lvl-3">
<p>默认的<strong>安全性</strong>：HTML 为 iframe 元素添加了 sandbox 属性，防止不信任的 Web 页面某些操作。</p>
</li>
<li class="lvl-3">
<p>平滑降级：旧浏览器中新的表单控件会<strong>平滑降级</strong>，将 input $\rightarrow$ text</p>
</li>
<li class="lvl-3">
<p>不建议过多的使用 div，因为其是无语言元素</p>
</li>
<li class="lvl-3">
<p><strong>新输入类型-color、date</strong></p>
</li>
<li class="lvl-4">
<p><strong>audio&amp;video</strong> 标签</p>
</li>
<li class="lvl-4">
<p><strong>Canvas</strong> 像素级操作，放大缩小会变形</p>
</li>
<li class="lvl-4">
<p><strong>SVG</strong> 矢量量图</p>
</li>
<li class="lvl-4">
<p>新元素：article section footer nav mark</p>
</li>
<li class="lvl-4">
<p>更优秀的<strong>错误处理</strong></p>
</li>
<li class="lvl-4">
<p>早前本地存储使用的是 <strong>cookie</strong>，但是Web 存储更加的安全与快速</p>
<p><strong>客户端存储数据的两个对象</strong>为：【js可以从这里面获取需要的数据】</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>localStorage</strong> - 用于<strong>长久</strong>保存整个网站的数据，保存的数据<strong>没有过期时间</strong>，直到手动去除。</p>
</li>
<li class="lvl-6">
<p><strong>sessionStorage</strong> - 用于<strong>临时</strong>保存同一窗口(或标签页)的数据，在<strong>关闭窗口</strong>或标签页之后将会<strong>删除</strong>这些数据。</p>
</li>
</ul>
<p>HTML5 引⼊了<strong>应用程序缓存</strong>，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。通过创建 <strong>cache manifest</strong> 文件，可以轻松地创建 <strong>web 应用的离线版本</strong></p>
</li>
</ol>
<h3 id="2-1-5-向前兼容-IE">2.1.5. 向前兼容 IE</h3>
<p>越来越多的站点开始使用HTML5标签。但情况是还有很多人在使用IE6，IE7，IE8。为了让所有网站浏览者都能正常的访问网站，有两种解决办法：</p>
<ol>
<li class="lvl-3">
<p>为<strong>网站创建多套模板</strong>，通过程序对User-Agent的判断给<strong>不同的浏览器用户显示不同的页面</strong>，比如<strong>优酷网</strong>就是采用的这种模式。</p>
</li>
<li class="lvl-3">
<p>使用<strong>Javascript</strong>来<strong>使不支持HTML5的浏览器支持HTML标签</strong>。很多网站采用的这种方式。</p>
</li>
</ol>
<p>针对IE浏览器比较好的解决方案是<strong>html5shiv</strong>。<strong>html5shiv主要解决HTML5提出的新的元素不被IE6-8识别</strong>。</p>
<h2 id="2-2-CSS">2.2. CSS</h2>
<p>Cascading Style Sheets</p>
<p>$css \rightarrow css2 \rightarrow css2.1 \rightarrow css3$</p>
<p>css 由<strong>选择器+声明块</strong>组成。</p>
<h3 id="2-2-1-CSS-优势">2.2.1. CSS 优势</h3>
<ol>
<li class="lvl-3">
<p>丰富的<strong>样式定义</strong></p>
</li>
<li class="lvl-3">
<p><strong>灵活</strong>：易于使用和修改</p>
</li>
<li class="lvl-3">
<p><strong>简洁、清晰</strong></p>
</li>
<li class="lvl-3">
<p>多页面应用</p>
</li>
<li class="lvl-3">
<p><strong>多设备兼容性</strong>：样式表允许针对多种不同类型的设备进行优化内容。</p>
</li>
<li class="lvl-3">
<p><strong>减少开发成本与维护成本</strong></p>
</li>
<li class="lvl-3">
<p><strong>提高页面性能</strong></p>
</li>
</ol>
<h3 id="2-2-2-CSS-2-1，3-新特性">2.2.2. CSS 2.1，3 新特性</h3>
<ol>
<li class="lvl-3">
<blockquote>
<p>CSS 2.1：<strong>选择器、媒体类型、盒模型</strong>、tables、分级媒体。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>CSS 3：<strong>模块化、使用特定于浏览器的前缀</strong>[<em>确保这种属性只在特定的浏览器渲染引擎下才能识别和生效</em>]、<strong>web字体、显著提高性能</strong>，比如<strong>圆角、渐变、变换和过渡</strong>等。</p>
</li>
</ol>
<h3 id="2-2-3-选择器">2.2.3 选择器</h3>
<ol>
<li class="lvl-3">
<p><strong>id选择器</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>标有特定 id 的 HTML 元素指定特定的样式。</p>
<ul class="lvl-2">
<li class="lvl-5">下面的样式规则将应用于有<strong>属性id=“para1&quot;的元素</strong>
<ul class="lvl-4">
<li class="lvl-7"><code>#para1 &#123;text-align:center;color:red;&#125;</code></li>
<li class="lvl-7"><code>&lt;p id='para1'&gt;&lt;/p&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>class选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>class 选择器在 <strong>HTML</strong> 中以 <strong>class 属性</strong>表示, 在 CSS  中，<strong>类选择器以一个点 . 号显示</strong></p>
<ul class="lvl-4">
<li class="lvl-7">在以下的例⼦中，所有拥有 center 类的 HTML 元素均为居中
<ul class="lvl-6">
<li class="lvl-9">.center {text-align:center;}</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-5">
<p>可以在前面加上<strong>标签限定</strong></p>
<ul class="lvl-4">
<li class="lvl-7">
<p>如 <code>span.classy &#123;&#125;</code> 就只作用于下面的 HTML 代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;classy&quot;</span>&gt;</span>Here&#x27;s a span with some text.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>标签选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">指定所有的该标签的样式</li>
</ul>
<ul class="lvl-2">
<li class="lvl-5">
<p>p{color:red;text-align:center;}选择 p 标签</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>属性选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>这组选择器根据一个元素上的某个标签的属性<strong>是否存在</strong>以选择元素的不同方式：</p>
<ul class="lvl-4">
<li class="lvl-7">[title]{color:blue;}</li>
</ul>
</li>
<li class="lvl-5">
<p>或者根据一个<strong>标签</strong>的特定属性是否存在来选择：</p>
<ul class="lvl-4">
<li class="lvl-7">&lt;h1 title=“Hello world”&gt;Hello world&lt;/h1&gt;</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>伪类选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>使用 <code>:</code></p>
</li>
<li class="lvl-5">
<p>CSS伪类是用来添加一些<strong>选择器的特殊效果</strong>（如 hover、点击等）</p>
</li>
<li class="lvl-5">
<p>如下设置不同状态的链接的颜色</p>
<ul class="lvl-4">
<li class="lvl-7">a:link {color:#000000;} /* 未访问链接*/</li>
<li class="lvl-7">a:visited {color:#00FF00;} /* 已访问链接 */</li>
<li class="lvl-7">a:hover {color:#FF00FF;} /* ⿏标移动到链接上 */</li>
<li class="lvl-7">a:active {color:#0000FF;} /* ⿏标点击时 */</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>伪元素选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>使用 <code>::</code></p>
</li>
<li class="lvl-5">
<p>伪元素，选择一个元素的<strong>某个部分</strong>而不是元素自己。例如，<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 每一个 &lt;p&gt; 元素的第一行。 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>组合选择器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>后代选择器(以空格分隔)，所有的后代</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163406345.png" alt="image-20230222163406345"></p>
</li>
<li class="lvl-5">
<p>子元素选择器(以大于号分隔）【标签元素的<strong>第一代子元素</strong>】</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163325138.png" style="zoom:50%;" />
<blockquote>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221126211305232.png" alt="image-20221126211305232"></p>
<p>div input后代选择器会把放在 <p> 中的 input 也选中，而div&gt;input子元素选择器只会选中 input type=text</p>
</blockquote>
</li>
<li class="lvl-5">
<p>相邻兄弟选择器（以加号分隔）</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163629160.png" alt="image-20230222163629160" style="zoom: 50%;" />
</li>
<li class="lvl-5">
<p>后续兄弟选择器（波浪号分隔)</p>
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222163638709.png" alt="image-20230222163638709" style="zoom:50%;" />
</li>
</ul>
<p>相邻只选择后面的<strong>一个</strong>，后续则选择后续的<strong>所有</strong></p>
</li>
</ol>
<h3 id="2-2-4-层叠">2.2.4 层叠</h3>
<ol>
<li class="lvl-3">
<p>样式表的三个层次，按照从底层到高层的顺序，分别为</p>
<ol>
<li class="lvl-6"><strong>行内样式表</strong></li>
<li class="lvl-6"><strong>嵌入样式表</strong></li>
<li class="lvl-6"><strong>外部样式表</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>浏览器能够像获取其他文档那样获取样式表文件。标签<code>&lt;link&gt;</code>用于指定外部样式表。</p>
</li>
<li class="lvl-3">
<p><strong>规则</strong>：</p>
<ol>
<li class="lvl-6">使用建议：外部 &gt; 内部 &gt; 内联</li>
<li class="lvl-6">一般不使用内联，因为只能声明一个元素，<strong>不能复用</strong></li>
<li class="lvl-6"><strong>外部样式表是最好的</strong>，可复用</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>CSS 来源优先级</strong>：【从上到下是由低到高】</p>
<ol>
<li class="lvl-6">用户代理样式表中的常规声明（<strong>例如，浏览器的默认样式，在没有设置其他样式时使用</strong>）</li>
<li class="lvl-6">用户样式表中的常规声明（<strong>由用户设置的自定义样式</strong>）</li>
<li class="lvl-6">作者样式表中的常规声明（<strong>这些是我们 web 开发人员设置的样式</strong>）。</li>
<li class="lvl-6">作者样式表中的 !important 声明</li>
<li class="lvl-6">用户样式表中的 !important 声明</li>
<li class="lvl-6">用户代理样式表中的 !important 声明</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>样式冲突的处理规则</strong>：</p>
<ol>
<li class="lvl-6">
<p><strong>资源顺序</strong></p>
<ul class="lvl-4">
<li class="lvl-8">当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，<strong>CSS 中最后的那个声明将会被应用到元素上</strong></li>
</ul>
</li>
<li class="lvl-6">
<p><strong>优先级</strong></p>
<ul class="lvl-4">
<li class="lvl-8">
<p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的<strong>每一种选择器的类型的数值</strong>决定。</p>
</li>
<li class="lvl-8">
<p><strong>左面的最大</strong>，数位之间没有进制，级别之间不可超越。</p>
</li>
<li class="lvl-8">
<p><strong>ID属性</strong>的数量——<strong>类</strong>和<strong>属性选择器</strong>和<strong>伪类</strong>的数量——<strong>元素名</strong>和<strong>伪元素</strong>的数量</p>
</li>
<li class="lvl-8">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221128151322960.png" alt="image-20221128151322960"></p>
<p>(上图最后：<code>:not()</code> 伪类的优先级将由其逗号分割的参数中<strong>优先级最高的选择器指定</strong>)</p>
</li>
<li class="lvl-8">
<p><strong>每个!important值：无穷大</strong></p>
<blockquote>
<p>内联样式和 !important 都被认为是非常不好的做法，但是有时你可以在 CSS 文件里用 !important 去覆盖内联样式。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>继承</strong>：</p>
<p>可以被继承： <code>color</code>、<code>text-align</code> 和 <code>font-family</code></p>
<p>不会被继承：<code>width</code>、<code>margin</code>、<code>padding</code> 和 <code>border</code></p>
</li>
</ol>
<h3 id="2-2-5-CSS-盒模型">2.2.5. CSS 盒模型</h3>
<ol>
<li class="lvl-3">
<p>所有元素都是一个盒子</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221123110911988.png" alt="image-20221123110911988"></p>
</li>
<li class="lvl-3">
<p>元素总宽度 $=width + border_{left} + border_{right} + magin_{left} + magin_{right} + padding_{left} + padding_{right}$</p>
</li>
<li class="lvl-3">
<p>元素总高度 $=height + border_{top} + border_{bottom} + magin_{top} + magin_{bottom} + padding_{top} + padding_{bottom}$</p>
</li>
<li class="lvl-3">
<p>Internet Explorer 默认使用的<strong>怪异盒模型</strong>，与上面的不同的是 height 和 weight 包含了填充和边框。</p>
<p>通过设置 <code>box-sizing: border-box</code> 可以告诉浏览器使用怪异盒模型</p>
</li>
</ol>
<h3 id="2-2-6-布局">2.2.6. 布局</h3>
<p><strong>正常流：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从左到右，从上到下</p>
</li>
<li class="lvl-2">
<p>如果两个相邻的元素都设置了 margin 并且两个 margin 有重叠，那么更大的设置会被保留，小的则会消失 — 这被称为<strong>外边距叠加。</strong></p>
</li>
</ul>
<p><strong>脱离正常流</strong>：</p>
<ol>
<li class="lvl-3">
<p>absolute：相对<strong>最近绝对定位的祖先</strong>，如果没有那么选择文档主体</p>
</li>
<li class="lvl-3">
<p>relative：相对其正常流中的位置进行定位</p>
</li>
<li class="lvl-3">
<p>fixed：相对视口定位，滚动页面也不改位置</p>
</li>
<li class="lvl-3">
<p>static：HTML 元素默认 static，静态定位元素不受 top 等的影响</p>
</li>
<li class="lvl-3">
<p>sticky：它的行为就像 <strong>position:relative;</strong> 而当<strong>页面滚动超出目标区域</strong>时，它的表现就像 <strong>position:fixed;</strong>，它会固定在目标位置。</p>
</li>
<li class="lvl-3">
<p>float：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222174237171.png" alt="image-20230222174237171"></p>
</li>
</ol>
<h3 id="2-2-7-Formatting-Context-格式化上下文">2.2.7. Formatting Context 格式化上下文</h3>
<p>页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作 用。</p>
<ol>
<li class="lvl-3">
<p><strong>Block Formatting Context</strong> 块级格式化上下文 ref:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6950082193632788493">什么是BFC</a></p>
<p><code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素<strong>不会影响到外面</strong>的布局</p>
<ol>
<li class="lvl-6">
<p>触发<code>BFC</code>的<code>CSS</code>属性</p>
<ul class="lvl-4">
<li class="lvl-8">overflow 值不为 visible、clip 的块元素</li>
<li class="lvl-8">display: inline-block</li>
<li class="lvl-8">position: absolute</li>
<li class="lvl-8">position: fixed</li>
<li class="lvl-8">display: table-cell</li>
<li class="lvl-8">display: flex</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>BFC 规则</strong>：</p>
<ul class="lvl-4">
<li class="lvl-8">
<p><code>BFC</code>内部块级元素会在垂直方向一个接一个的排列</p>
</li>
<li class="lvl-8">
<p><code>BFC</code>就是页面中的一个<strong>隔离的独立容器</strong>，容器里的标签不会影响到外部标签</p>
</li>
<li class="lvl-8">
<p>垂直方向的距离由margin决定， 属于同一个<code>BFC</code>的两个相邻的标签<strong>外边距会发生重叠</strong></p>
</li>
<li class="lvl-8">
<p>计算<code>BFC</code>的高度时，<strong>浮动元素也参与计算</strong></p>
</li>
<li class="lvl-8">
<p>BFC的区域<strong>不会与float box重叠</strong></p>
</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>用途</strong>：</p>
<ul class="lvl-4">
<li class="lvl-8"><strong>高度塌陷</strong>：将父元素设置为 BFC【如设置 display: inline-block】可以解决了父元素未设置高度，而子元素设置浮动后，造成子元素脱离文档流无法把父元素撑开，父元素高度为 0 的问题。</li>
<li class="lvl-8"><strong>外边距重叠</strong>：如果想要消除两个相邻标签的外边距重叠，那么可以为其中一个元素包裹一个盒子形成一个完全独立的空间【如用 div 包裹】，里面元素不受外面布局影响</li>
<li class="lvl-8"><strong>排开外部浮动，避免重叠</strong>【实现多栏布局】：由于 BFC 不会和浮动块重叠，当一个块浮动时会覆盖原本在那个位置的，把原本那个位置的块设置为 BFC【如 display:flex】可以使原来的块移动到浮动元素的右边而不重叠</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<blockquote>
<p><strong>Inline Formatting Contexts 行内格式化上下文</strong> ref:<a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122">IFC</a></p>
<ol>
<li class="lvl-3">
<p>触发条件：块级元素中仅包含行内元素</p>
</li>
<li class="lvl-3">
<p>规则：</p>
<ol>
<li class="lvl-6"><strong>横向</strong>的margin、border、padding属性对于这些行内元素都是有效的</li>
<li class="lvl-6">一个IFC内的元素都是⽔平排列的</li>
</ol>
</li>
<li class="lvl-3">
<p>IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</p>
</li>
<li class="lvl-3">
<p>用途：</p>
<ol>
<li class="lvl-6">
<p>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</p>
</li>
<li class="lvl-6">
<p>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。<strong>如下面的文本就能和图片垂直居中</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222190957264.png" alt="image-20230222190957264"></p>
</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="2-2-8-响应式网页设计，主要手段">2.2.8. 响应式网页设计，主要手段</h3>
<ol>
<li class="lvl-3">
<p>响应式网页设计 (RWD，Responsive Web Design)，可以自动识别屏幕宽度、并作出相应调整网页。</p>
</li>
<li class="lvl-3">
<p>曾经流行，不再是必不可少，原因：</p>
<ul class="lvl-2">
<li class="lvl-5">公司研发⼈员越来越充足，可以在pc端和移动端实现<strong>两套布局</strong>，分项目进行维护。</li>
</ul>
<p>仍有存在的价值：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>物联网领域，任何设备界面的响应布局。</p>
</li>
<li class="lvl-5">
<p>体现了CSS的<strong>灵活性</strong>。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>优点</strong>：网站可用性大大提升、简化服务器端、易维护、只提供给搜索引擎一个入口、可<strong>支持未知</strong>设备。</p>
</li>
<li class="lvl-3">
<p><strong>缺点</strong>：<strong>兼容设备导致性能低下</strong>、代码<strong>冗余</strong> ( 加载时间变长 )，<strong>限制应用复杂性</strong> ( 折衷的设计方案 )、<strong>用户混淆</strong> ( 改变了网站布局 )</p>
</li>
<li class="lvl-3">
<p>主要手段：</p>
<ol>
<li class="lvl-6">CSS <strong>媒体查询</strong> ( 不同屏幕分辨率，不同 CSS 规则 )</li>
<li class="lvl-6">不使用绝对大小，而使用<strong>相对大小</strong>:<code>width:20%/auto</code>、<code>px/em</code>【em 相对于当前对象内文本的字体尺寸。如当前对文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸 16px。】</li>
<li class="lvl-6"><strong>流动布局</strong></li>
<li class="lvl-6">图片<strong>自动缩放</strong></li>
</ol>
</li>
</ol>
<h2 id="2-3-javascript-重要">2.3. javascript 重要</h2>
<h3 id="2-3-1-基本语法">2.3.1. 基本语法</h3>
<blockquote>
<p>可以写在 body 中、head 中或外部文件中</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- body --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- head --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;My First JavaScript Function&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">   ! script commands and comments</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>JavaScript 拥有动态类型：这意味着相同的变量可用作不同的类型</p>
</li>
<li class="lvl-3">
<p><strong>大小写敏感</strong> (HTML 大小写不敏感)</p>
</li>
<li class="lvl-3">
<p>不指定类型，但有类型：<strong>Number, Boolean, String, Array, Object, Function, Null, Undefined</strong></p>
<ul class="lvl-2">
<li class="lvl-5">typeof()可以知道类型</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Number</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">数值在内部都是通过<strong>IEEE 754 64位双精度浮点型的形式</strong>表示的 (没有 int  double 的区别)</li>
<li class="lvl-5">运算符有<strong>自动的类型转换</strong>，Ex. “2” * 3 is 6</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>String</strong></p>
<ol>
<li class="lvl-6">没有 char 类型，一个字符也是存成 String</li>
<li class="lvl-6">+可以用来连接字符串</li>
<li class="lvl-6"><strong>1+1 is 2, but “1”+1 is “11”</strong></li>
<li class="lvl-6">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130104151749.png" alt="image-20221130104151749" style="zoom:50%;" />
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>Boolean</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>任何值都可以用作布尔值</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>false：0, -0, 0.0, NaN, “”, null, undefined</p>
</li>
<li class="lvl-7">
<p>true：其他的所有</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>将值显式转换为布尔值</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>var boolValue = Boolean(otherValue);</p>
</li>
<li class="lvl-7">
<p>var boolValue = <strong>!!</strong>(otherValue);</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130104636619.png" alt="image-20221130104636619"></p>
</li>
<li class="lvl-3">
<p><strong>逻辑运算符</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>大多数逻辑运算符会<strong>自动转换类型</strong></p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221130104954720.png" alt="image-20221130104954720"></p>
<p>平常业务中比较建议尽量不要使用 == 和 !=。这两个比较的时候<strong>会做一些强制的类型转换</strong></p>
<p>务必使用 <strong>=== 和 !==</strong>。【严格的相等检查，不会进行类型转换，<strong>同时比较类型和值</strong>】</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>Ex. “5.0” === 5 is false</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Arrays</strong>：</p>
<ol>
<li class="lvl-6">两种初始化方式
<ul class="lvl-4">
<li class="lvl-8">var empty=[];</li>
<li class="lvl-8">var mycars=new Array();
<ul class="lvl-6">
<li class="lvl-10"><strong>var mycars=new Array(1, ‘22’, true)</strong>;也可以直接赋值，且数组中元素的类型可以不一样</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-6">不需要指定长度，在添加元素时根据需要自动增加</li>
</ol>
</li>
<li class="lvl-4">
<p><strong>Function</strong>：</p>
<ol>
<li class="lvl-7">
<p>function functionName(parameters) { // }</p>
</li>
<li class="lvl-7">
<p>箭头=&gt;函数，如：</p>
<p>(arg1, arg2) =&gt; {// code}</p>
</li>
<li class="lvl-7">
<p>匿名方法</p>
<p>(function (x,y) {return x+y}) (2,3);</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-3-2-严格模式">2.3.2. 严格模式</h3>
<ol>
<li class="lvl-3">
<p><strong>脚本或函数头</strong>使用添加<code>use strict;</code>的目的是指代码在严格条件下执行。</p>
</li>
<li class="lvl-3">
<p><strong>为什么使用严格模式</strong></p>
<ol>
<li class="lvl-6">消除 js 语法的一些<strong>不合理、不严谨的地方</strong>，减少怪异的行为</li>
<li class="lvl-6">消除代码运行的<strong>不安全</strong></li>
<li class="lvl-6">提供编译器效应，<strong>增加运行效率</strong></li>
<li class="lvl-6">为<strong>未来版本的 js 做好铺垫</strong></li>
</ol>
</li>
<li class="lvl-3">
<p>严格模式限制：</p>
<ol>
<li class="lvl-6"><strong>变量必须声明后使用</strong></li>
<li class="lvl-6"><strong>函数参数不可以同名</strong></li>
<li class="lvl-6"><strong>不可以使用 with 语句</strong></li>
<li class="lvl-6">不能<strong>对只读属性赋值</strong></li>
<li class="lvl-6">不能使用<strong>前缀 0 表示八进制</strong></li>
<li class="lvl-6"><strong>不可以删除不可删除属性</strong></li>
<li class="lvl-6">不可以使用 delete prop 删除变量，只能删除属性 delete global[prop]</li>
<li class="lvl-6">eval 不会从它的外层作用域引入变量</li>
<li class="lvl-6">eval 和 arguments 不可以被重新赋值</li>
<li class="lvl-7">arguments 不会自动反应函数参数变化</li>
<li class="lvl-7">不能使用 <code>arguments.callee</code>和<code>.caller</code></li>
<li class="lvl-7">禁止<code>this</code><strong>指向全局对象</strong></li>
<li class="lvl-7">不能使用 fn<code>.caller</code>和<code>.arguments</code>获取函数调用的堆栈</li>
<li class="lvl-7">增加了保留字<code>protected</code>、<code>static</code>和<code>interface</code></li>
</ol>
</li>
</ol>
<h3 id="2-3-3-函数">2.3.3. 函数</h3>
<ol>
<li class="lvl-3">
<p>头等函数 (first-class function) 是指在程序设计语言中，函数被当作头等公民。</p>
</li>
<li class="lvl-3">
<p>函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中。在这样的语言中，函数的名字没有特殊含义，它们被当作具有函数类型的普通的变量对待。</p>
</li>
<li class="lvl-3">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223102211209.png" alt="image-20230223102211209" style="zoom:50%;" />
</li>
<li class="lvl-3">
<p><strong>匿名函数</strong>：</p>
<ol>
<li class="lvl-6">
<p>匿名函数就是声明一个函数不起名字。</p>
</li>
<li class="lvl-6">
<p>如果匿名函数只要一处调用，那么在调用处声明，调用完就销毁了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子：声明</span></span><br><span class="line"><span class="keyword">var</span> double = <span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="keyword">return</span> <span class="number">2</span> * x;&#125;</span><br><span class="line"><span class="comment">// 声明后立即调用</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(x + y);</span><br><span class="line">&#125;)(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="2-3-4-事件驱动编程">2.3.4. 事件驱动编程</h3>
<ol>
<li class="lvl-3">
<p>JavaScript <strong>事件</strong>允许脚本<strong>响应用户与网页上元素的交互</strong>，通过<strong>回调编程</strong>。JS 是采用<strong>事件驱动的机制来响应用户操作的</strong></p>
</li>
<li class="lvl-3">
<p>事件驱动编程是一种<strong>编程范式</strong>，其中程序流由<strong>事件决定</strong>，诸如用户操作(鼠标点击、按键)、传感器输出或来自其他程序/线程的消息</p>
</li>
<li class="lvl-3">
<p>在事件驱动应用中，会有 <strong>listener</strong> 主循环<strong>监听</strong>事件【事件需要<strong>注册</strong>才会被监听】，并且在被触发时调用一个 **callback **方法</p>
</li>
<li class="lvl-3">
<p><strong>语法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><code>element.addEventListener(event, function, useCapture);</code></p>
<ul class="lvl-4">
<li class="lvl-7">第⼀个参数是事件类型 (如&quot;click&quot; 或&quot;mousedown&quot;).</li>
<li class="lvl-7">第⼆个参数是我们想在事件发生时调用的回调函数.</li>
<li class="lvl-7">第三个参数是⼀个布尔值，是否在<strong>捕获</strong>时执行事件处理函数【<em>详见 DOM</em>】，是可选参数，默认 <code>false</code> 表示在事件<strong>冒泡</strong>阶段调用事件处理函数；如果参数为<code>true</code>，则表示在事件<strong>捕获</strong>阶段调用处理函数。</li>
</ul>
</li>
<li class="lvl-5">
<p><code>removeEventListener()</code> 方法删除已由 <code>addEventListener()</code> 方法注册的事件处理程序</p>
</li>
<li class="lvl-5">
<pre><code class="language-js">document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,  myFunction, true); document.getElementById(&quot;myDiv&quot;).removeEventListener(&quot;mousemove&quot;, myFunction);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3.5. 面向对象</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223104423246.png&quot; alt=&quot;image-20230223104423246&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">1. 用 JavaScript 实现类 JavaScritpt 没有专门的机制实现类，这里是借助**它的函数允许嵌套**的机制来实现类的。一个函数可以包含变量，又可以包含其它函数，这样，变量可以作为属性，内部的函数就可以作为成员方法了。因此外层函数本身就可以作为一个类了。</span><br><span class="line">2. 类声明：`function myClass() &#123; //此处相当于构造函数 &#125;`，这里 myClass 就是一个类。其实可以把它看成类的构造函数。至于非构造函数的部分，以后会详细描述。</span><br><span class="line">3. 类新建：`var obj1 = new myClass();`，JavaScript 提供了一个方法可以获得对象实例。即 new 操作符。其实 JavaScript 中，类和函数是同一个概念，当用 new 操作一个函数时就返回一个对象。</span><br><span class="line">4. 对象的成员的引用在 JavaScript 中引用一个类的属性或方法的方法有以下三种。</span><br><span class="line">   1. 点号操作符：这是一种最普遍的引用方式，就不累赘。即如下形式：`对象名.属性名; 对象名.方法名;`</span><br><span class="line">   2. 方括号引用：JavaScript 中允许用方括号引用对象的成员。如下：`对象名[&quot;属性名&quot;]; 对象名[&quot;方法名&quot;];`</span><br><span class="line">      1. 这里方括号内是代表属性或方法名的字符串，不一定是字符串常量。也可以使用变量。这样就可以使用**变量**传递属性或方法名。为编程带来了方便。在某些情况下，代码中不能确定要调用那个属性或方法时，就可以采用这种方式。否则，如果使用点号操作符，还需要使用条件判断来调用属性或方法。</span><br><span class="line">      2. 另外，使用方括号引用的属性和方法名还可以以**数字**开头，或者出现**空格**，而使用点号引用的属性和方法名则遵循标示符的规则。但一般不提倡使用非标示符的命名方法。</span><br><span class="line">   3. 迭代器遍历：`for item in obj`</span><br><span class="line">5. prototype 属性：每个构造函数有一个`prototype`属性，指向另一个**原型对象**，这个对象的所有属性和方法会被**所有对象实例所共享**</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// 每个实例对象的 type 和 eat 都是一样的，每次生成一些示例其实是重复的内容，多占用内存</span><br><span class="line">functlon Cat(name,color)&#123;</span><br><span class="line">   this.name = nane;</span><br><span class="line">   this.color = color;</span><br><span class="line">   this.type = &quot;猫科动物&quot;;</span><br><span class="line">   this.eat = function()&#123;alert(&quot;吃老鼠&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">// 使用 prototype 对象，那么创建的每个对象就不会重复相同的内容</span><br><span class="line">function Cat(name ,color)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.color = color ;</span><br><span class="line">)</span><br><span class="line">Cat.prototype.type = &quot;猫科动物&quot;;</span><br><span class="line">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-6-作用域、作用域链、闭包及其用途">2.3.6. 作用域、作用域链、闭包及其用途</h3>
<ol>
<li class="lvl-3">
<p>作用域是在<strong>运行时</strong>代码中的某些特定部分中变量、函数和对象的<strong>可访问性</strong>。<strong>子作用域可以访问父作用域， 反过来则不行</strong></p>
<ol>
<li class="lvl-6">
<p>最大作用：隔离变量，不同作用域下同名变量不会有冲突。</p>
</li>
<li class="lvl-6">
<p><strong>JS 作用域类型</strong></p>
<ol>
<li class="lvl-9">
<p><strong>全局作用域</strong>：</p>
<ul class="lvl-6">
<li class="lvl-11">最外层函数和最外层函数外声明的变量</li>
<li class="lvl-11"><strong>所有未定义直接赋值的变量</strong>，即自动全局</li>
<li class="lvl-11">所有 window 对象的属性</li>
</ul>
</li>
<li class="lvl-9">
<p><strong>模块作用域</strong>：</p>
<ul class="lvl-6">
<li class="lvl-11">模块模式中运行代码的作用域</li>
</ul>
</li>
<li class="lvl-9">
<p><strong>函数作用域</strong>：</p>
<ul class="lvl-6">
<li class="lvl-11">
<p>只能在函数中访问</p>
</li>
<li class="lvl-11">
<p>函数中可以访问全局等外部的，但是外部不可以访问内部的</p>
</li>
<li class="lvl-11">
<p><strong>ES6 之前</strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们<strong>不会创建一个新的作用域</strong>。在块语句中定义的变量将<strong>保留在它们当前存在的作用域中</strong>。即 <strong>变量提升</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name1 = <span class="string">&#x27;Tim&#x27;</span>;<span class="comment">// 是在全局作用域中的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1);<span class="comment">// &#x27;Tim&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name2 = <span class="string">&#x27;Ray&#x27;</span>;<span class="comment">// 是在函数作用域中的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-11">
<p><strong>函数提升</strong>：<strong>函数声明会被提升到顶部，但函数表达式不会</strong>，只是函数表达式左边的变量会被提升，在声明之前访问 baz 是 undefined，因此报错不是一个函数</p>
<ul class="lvl-8">
<li class="lvl-13">
<pre><code class="language-js">/* 函数声明 */
foo(); // &quot;bar&quot;
function foo() &#123;
 console.log(&quot;bar&quot;);
&#125;
/* 函数表达式 */
baz(); // 类型错误：baz 不是⼀个函数
var baz = function() &#123;
 console.log(&quot;bar2&quot;);
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. **ES6**出现：**块级作用域**：&#123;&#125;创建</span><br><span class="line"></span><br><span class="line">   - 块级作用域可通过**新增命令 let 和 const 声明**，所声明的变量在指定块的作用域外无法被访问。</span><br><span class="line"></span><br><span class="line">   - **TDZ 暂时性死区**（英temporal dead zone），即代码块开始到变量声明语句完成之间的区域，不像 var，let 拥有暂时性死区，在这个区域内不能使用这个变量。</span><br><span class="line"></span><br><span class="line">   - ```js</span><br><span class="line">     //1. TDZ</span><br><span class="line">     &#123; </span><br><span class="line">      console.log(bar); // undefined，可以访问但是是未定义的，因为当前没有赋值 </span><br><span class="line">      console.log(foo); // ReferenceError，不能访问，有暂时性死区</span><br><span class="line">      var bar = 1;</span><br><span class="line">      let foo = 2; // End of TDZ (for foo)</span><br><span class="line">     &#125;</span><br><span class="line">     // 但下面这样是可以的，即暂时性的意思是取决于执行的顺序，而不是编写代码的顺序，func在暂时性死区外执行，因此可以</span><br><span class="line">     &#123;</span><br><span class="line">      // TDZ starts at beginning of scope</span><br><span class="line">     const func = () =&gt; console.log(letVar);</span><br><span class="line">     let letVar = 3; // End of TDZ (for letVar)</span><br><span class="line">     func();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //2. 声明变量不会提升到代码块顶部</span><br><span class="line">     function getValue(condition) &#123;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">           let value = &quot;blue&quot;;</span><br><span class="line">           return value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           // value 在此处不可用</span><br><span class="line">           return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // value 在此处不可用</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //3. 禁止重复声明，如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误，而声明var则可以</span><br><span class="line">     var count = 30;</span><br><span class="line">     let count = 40; // Uncaught SyntaxError: Identifier &#x27;count&#x27; has already been declared</span><br><span class="line">     </span><br><span class="line">     // 在嵌套作用域中不会抛出错误</span><br><span class="line">     var count = 30;</span><br><span class="line">     var condition = 1;</span><br><span class="line">     if (condition) &#123;</span><br><span class="line">        let count = 40;</span><br><span class="line">        // 其他代码</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //4. 循环中的绑定块作用域的妙用，如果使用 var 声明 i 的话，就会导致 i 成为全局变量，点击任何按钮都是输出4，因为i都变成了 4</span><br><span class="line">     for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">         button[i].onclick = function () &#123;</span><br><span class="line">           console.log(&#x27;第&#x27; + (i + 1) + &#x27;个&#x27;)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>作用域链</strong></p>
<ol>
<li class="lvl-6">
<p><strong>自由变量</strong>：当前的作用域没有定义的变量，找值则需要向（创建函数的）父级作用域查找，一直往上。</p>
<p>但<strong>注意</strong>：无论函数将在哪里调用，要到<strong>创建函数的那个父作用域中取</strong></p>
</li>
<li class="lvl-6">
<p>这种一层一层的查找父作用域的关系，就是<strong>作用域链</strong></p>
</li>
<li class="lvl-6">
<pre><code class="language-js">// 例 1
var x = 10
function fn() &#123;
  console.log(x)
&#125;
function show(f) &#123;
  var x = 20
  (function() &#123;
    f() //10，而不是 20
  &#125;)()
&#125;
show(fn)
// 例 2
var a = 10
function fn() &#123;
  var b = 20
  function bar() &#123;
    console.log(a + b) //30
  &#125;
  return bar
&#125;
var x = fn()
b = 200
x() //bar()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   4. &gt; 作用域和执行上下文之间最大的区别是：</span><br><span class="line">      &gt;</span><br><span class="line">      &gt; **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。</span><br><span class="line"></span><br><span class="line">3. **闭包**</span><br><span class="line"></span><br><span class="line">   1. 是可以读取其他函数内部变量的函数</span><br><span class="line"></span><br><span class="line">   2. 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&quot;**定义在一个函数内部的函数**&quot;。</span><br><span class="line"></span><br><span class="line">   3. ```js</span><br><span class="line">      function f1()&#123;</span><br><span class="line">      　　var n=999;</span><br><span class="line">         // 匿名函数，本质也是闭包，nAdd是全局变量</span><br><span class="line">      　　nAdd=function()&#123;n+=1;&#125;</span><br><span class="line">         // f2 闭包函数</span><br><span class="line">         function f2()&#123;</span><br><span class="line">      　　　alert(n);</span><br><span class="line">      　　&#125;</span><br><span class="line">         return f2;</span><br><span class="line">      &#125;</span><br><span class="line">      // f2 被赋值被全局变量，因此 f2 一直在内存中，而 f2 依赖于 f1，于是 f1 也在内存中，而不会在调用结束后被垃圾回收机制回收。</span><br><span class="line">      var result=f1();</span><br><span class="line">      result(); // 999</span><br><span class="line">      nAdd();</span><br><span class="line">      result(); // 1000</span><br><span class="line">      </span><br><span class="line">      // 关于 this 的例子</span><br><span class="line">      // this 和调用时有关，而不是创建时</span><br><span class="line">      var name=&quot;XL&quot;;</span><br><span class="line">      var person=&#123;</span><br><span class="line">         name:&quot;xl&quot;,</span><br><span class="line">         showName:function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      person.showName();//  xl</span><br><span class="line">      //这里是 person 对象调用 showName 方法，很显然 this 关键字是指向 person 对象的，所以会输出 name</span><br><span class="line">      </span><br><span class="line">      var showNameA=person.showName;</span><br><span class="line">      showNameA();     //输出  XL</span><br><span class="line">      //这里将 person.showName 方法赋给 showNameA 变量，此时 showNameA 变量相当于 window 对象的一个属性，因此 showNameA() 执行的时候相当于 window.showNameA(),即 window 对象调用 showNameA 这个方法，所以 this 关键字指向 window</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li class="lvl-6">
<p>闭包用途</p>
<ol>
<li class="lvl-9">
<p>实现私有成员</p>
</li>
<li class="lvl-9">
<p>保护命名空间</p>
</li>
<li class="lvl-9">
<p>避免污染全局变量</p>
</li>
<li class="lvl-9">
<p>变量需要长期驻留内存</p>
</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>with</strong>——<strong>不使用</strong></p>
<ol>
<li class="lvl-6">
<p>不推荐使用with，在 ECMAScript 5 <strong>严格模式中该标签已被禁止</strong>。【出现 with js 引擎不进行任何优化，性能差，且可能会导致数据泄露问题】</p>
<p>推荐的替代方案是声明⼀个临时变量来承载你所需要的属性，如下面例子中的重复写 obj</p>
</li>
<li class="lvl-6">
<p>with 语句的原本用意是<strong>为逐级的对象访问提供命名空间式的速写方式</strong></p>
</li>
<li class="lvl-6">
<p>with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的<strong>某个属性同名</strong>，则这个<strong>局部变量会指向 obj 对象属性</strong>。</p>
</li>
<li class="lvl-6">
<pre><code class="language-js">// 例子
var obj = &#123;
	a: 1,
	b: 2,
	c: 3
&#125;;
// 重复写了3次的“obj”
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 如果使用with，则可以不用写
with (obj) &#123;
	a = 3;
	b = 4;
	c = 5;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. **this**：</span><br><span class="line"></span><br><span class="line">   **显式绑定**：通过call、apply、bind、new 确定指向</span><br><span class="line"></span><br><span class="line">   &gt; **call、apply、bind 都是用来改变 this 的指向的，第一个参数都是 this 要指向的对象。**</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; - call 只是临时改变一次 this 指向，并立即执行函数。但后面参数形式是 `obj.myFun.call(db,&#x27;成都&#x27;,&#x27;上海&#x27;)；`</span><br><span class="line">   &gt; - apply 只是临时改变一次 this 指向，并立即执行函数。但后面参数是 `obj.myFun.apply(db,[&#x27;成都&#x27;,&#x27;上海&#x27;]); `</span><br><span class="line">   &gt; - bind 返回一个永久改变 this 指向的函数，不会立即执行函数，它的参数形式和 call 一样。</span><br><span class="line"></span><br><span class="line">   **隐式绑定**：根据调用关系确定this指向</span><br><span class="line"></span><br><span class="line">   - 在函数体中，非显式或隐式地简单调用函数时，在**严格**模式下，函数内的this会被绑定到 **undefined **上，在**非严格模式下则会被绑定到全局对象 window **上【例子1，2】</span><br><span class="line"></span><br><span class="line">   - ⼀般通过上下文对象调用函数时，函数体内的 this 会被绑定到该对象上【例子3，4】</span><br><span class="line"></span><br><span class="line">     ```js</span><br><span class="line">      // 例子1</span><br><span class="line">      function f1() &#123;</span><br><span class="line">       console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">      function f2() &#123;</span><br><span class="line">       &quot;use strict&quot;;</span><br><span class="line">       console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">      f1(); // window</span><br><span class="line">      f2(); // undefined</span><br><span class="line">     </span><br><span class="line">     // 例子2</span><br><span class="line">     var foo = &#123;</span><br><span class="line">      bar: 10,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     var fn1 = foo.fn</span><br><span class="line">     fn1()// window，因为是用window来调用的</span><br><span class="line">     </span><br><span class="line">     // 例子3</span><br><span class="line">     var foo = &#123;</span><br><span class="line">      bar: 10,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      console.log(this.bar)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     foo.fn()// &#123;bar:10,fn:f&#125;，这里是由foo调用</span><br><span class="line">     </span><br><span class="line">     // 例子4</span><br><span class="line">     var o1 = &#123;</span><br><span class="line">      text: &#x27;o1&#x27;,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      	return this.text</span><br><span class="line">      &#125; &#125;</span><br><span class="line">     var o2 = &#123;</span><br><span class="line">      text: &#x27;o2&#x27;,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      	return o1.fn()</span><br><span class="line">      &#125; &#125;</span><br><span class="line">     var o3 = &#123;</span><br><span class="line">      text: &#x27;o3&#x27;,</span><br><span class="line">      fn: function() &#123;</span><br><span class="line">      var fn = o1.fn</span><br><span class="line">      	return fn()</span><br><span class="line">      &#125; &#125;</span><br><span class="line">     console.log(o1.fn())// o1，o1调用</span><br><span class="line">     console.log(o2.fn())// o1，在o2中o1进行调用，因此o1中的this指向o1</span><br><span class="line">     console.log(o3.fn())// undefined，return fn()，直接调用函数，不指名this，则this默认指向window，即fn就是由window来调用的，而window中没有text属性，因此是undefined</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<ul class="lvl-2">
<li class="lvl-5">
<p>通过 <strong>call/apply/bind 方法显示调用函数</strong>时，函数体内的 this 会被绑定到<strong>指定参数的对象</strong>上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Tim&#x27;</span>,</span><br><span class="line"> <span class="attr">logName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;mike&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">logName</span>.<span class="title function_">call</span>(bar)<span class="comment">// mike</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>⼀般使用 new 方法调用构造函数时，<strong>构造函数内的 this 会被绑定到新创建的对象上</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="string">&quot;Tim&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">bar</span>)<span class="comment">// Tim</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>箭头函数<strong>不适用上面的规则</strong>，而是根据<strong>外层（函数或者全局）上下文</strong>来决定 this 的指向，始终指向外部对象，因为箭头函数没有<code>this</code>，因此它自身不能进行<code>new</code>实例化，同时也不能使用<code>call, apply, bind</code>等方法来改变<code>this</code>的指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名类似上面的例子2</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line"> <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">     (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">     &#125;)()<span class="comment">// 匿名函数直接执行，因此是window</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">fn</span>())<span class="comment">// window</span></span><br><span class="line"><span class="comment">// 取决于外层上下文，箭头函数位于foo内，那么this指向foo</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line"> <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">     (<span class="function">() =&gt;</span> &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">     &#125;)()<span class="comment">// 箭头函数立即执行</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">fn</span>())<span class="comment">// &#123;fn:f&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">call</span>(obj2))<span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>foo.call(obj1) 使得使得 foo 中的 this 指向 obj1【因此箭头函数的 this 指向 obj1】，并立即执行 foo，因此 foo.call(obj1) 会返回一个<strong>箭头函数</strong>即 a =&gt; {console.log(this.a)}，并保存在 bar 中，而箭头函数不能直接对其修改 this 指向，因此 bar.call(obj2) 执行时，this 仍然是 指向 obj1。另外 call 不返回函数，因此 console.log(bar.call(obj2)) 输出 undefind</p>
<p>ref</p>
<ol>
<li class="lvl-3">
<p><a href = "https://www.cnblogs.com/fundebug/p/10535230.html">作用域、作用域链</a></p>
</li>
<li class="lvl-3">
<p><a href = "http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">学习 Javascript 闭包 (Closure)</a></p>
</li>
<li class="lvl-3">
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lisha-better/p/5684844.html">JS中this关键字详解</a></p>
</li>
<li class="lvl-3">
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zwkkkk1/article/details/79725934">JavaScript中 with的用法</a></p>
</li>
<li class="lvl-3">
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82340026">彻底弄懂bind，apply，call三者的区别 </a></p>
</li>
<li class="lvl-3">
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/js-call-apply-bind.html">JavaScript 中 call()、apply()、bind() 的用法</a></p>
</li>
</ol>
<h2 id="2-4-DOM-BOM">2.4. DOM BOM</h2>
<h3 id="2-4-1-XHTML-XML-与-DOM-树">2.4.1. XHTML/XML 与 DOM 树</h3>
<blockquote>
<h4 id="2-4-1-1-XHTML-XML">2.4.1.1. XHTML/XML</h4>
<ol>
<li class="lvl-3">HTML 语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对 于传统的电脑来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由 DTD 定义规则，语法要求更加严格的 XHTML。</li>
<li class="lvl-3">最大的变化在于<strong>所有标签必须闭合</strong>，也就是说开始标签要有相应的<strong>结束</strong>标签。另外，XHTML 中所有的<strong>标签必须小写</strong>。在 XHTML 中，<strong>所有的参数值，包括数字，必须用双引号括起来</strong>。</li>
</ol>
</blockquote>
<h4 id="2-4-1-2-DOM">2.4.1.2. DOM</h4>
<ol>
<li class="lvl-3">
<p>当一个网页被<strong>加载</strong>时，浏览器会创建一个页面的<strong>文档对象模型</strong>（Document Object Model，DOM)</p>
<p>HTML DOM模型被构造成一个<strong>对象树</strong></p>
</li>
<li class="lvl-3">
<blockquote>
<p>在应用程序中，基于 DOM 的 XML/HTML 分析器将一个 XML/HTML 文档转换成一个对象模型的集合 ( 通常称 DOM 树 )，应用程序正是通过对这个对象模型的操作，来实现对 XML/HTML 文档数据的操作</p>
</blockquote>
</li>
<li class="lvl-3">
<blockquote>
<p>XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法。</p>
</blockquote>
</li>
<li class="lvl-3">
<blockquote>
<p>HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><mark><strong>HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素以及处理和新建 HTML 事件的标准。</strong></mark></p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/2.png" alt=""></p>
<ol start="7">
<li class="lvl-3">
<p><strong>DOM编程接口</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>HTML DOM可以使用JavaScript</p>
</li>
<li class="lvl-5">
<p>所有 HTML 元素被<strong>定义为对象</strong></p>
</li>
<li class="lvl-5">
<p>编程接口是<strong>每个对象的属性和方法</strong></p>
<ul class="lvl-4">
<li class="lvl-7">
<p>属性是可以获取或设置的值(如<strong>更改</strong>HTML元素的<strong>内容</strong>)。</p>
<p>使用 <code>objectName.attributeName</code> 访问/修改 DOM 对象的属性</p>
</li>
<li class="lvl-7">
<p>方法是可以执行的操作(如<strong>添加</strong>或<strong>删除</strong>HTML元素)。</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>找元素</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">by id<br>
<code>document.getElementById(&quot;intro&quot;);</code></li>
<li class="lvl-5">by tag name<br>
<code>document.getElementsByTagName(&quot;p&quot;);</code></li>
<li class="lvl-5">by class name<br>
<code>document.getElementsByClassName(&quot;intro&quot;);</code></li>
<li class="lvl-5">by CSS selectors<br>
<code>document.querySelectorAll(&quot;p.intro&quot;);</code></li>
<li class="lvl-5">by HTML object collections<br>
<code>document.forms[&quot;frm1&quot;];</code></li>
</ul>
</li>
<li class="lvl-3">
<p>DOM <strong>树节点类型</strong>：</p>
<ol>
<li class="lvl-6">
<p>每个节点都有 nodeType，nodeName，nodeValue</p>
</li>
<li class="lvl-6">
<p>nodeType： Element、Text、Attr(属性节点)、Comment(注释节点)、Document(文档节点)</p>
</li>
<li class="lvl-6">
<p>如<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222200728788.png" alt="image-20230222200728788"></p>
<p>DOM 树就是：</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230222200950221.png" alt="image-20230222200950221"></p>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-2-DOM0，DOM2-事件流-捕获、目标和冒泡">2.4.2. DOM0，DOM2 事件流 ( 捕获、目标和冒泡 )</h3>
<h4 id="2-4-2-1-DOM0">2.4.2.1. DOM0</h4>
<ol>
<li class="lvl-3">
<p><strong>将一个函数赋值给一个事件处理属性</strong>。为所有浏览器所支持。</p>
<ol>
<li class="lvl-6">优点：简单高效，移除事件非常简单只要 element.onclick=null即可但</li>
<li class="lvl-6">缺点：多次赋值会覆盖之前的回调函数，如 <code>onclick=f;onclick=g</code>，因此<strong>一个事件处理程序只能对应一个处理函数。</strong></li>
</ol>
</li>
<li class="lvl-3">
<p><code>onxxx</code> 如 <code>onclick</code> 是 <code>DOM0</code> 级别的事件</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消绑定</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-2-DOM2">2.4.2.2. DOM2</h4>
<ol>
<li class="lvl-3">
<p>DOM2 事件引进了一种全新的绑定事件方法，添加了一些新的事件。现在的浏览器都支持这种绑定方式，也建议使用这种绑定方式。</p>
</li>
<li class="lvl-3">
<p><code>addEventListener</code>添加的事件处理程序，并通过<code>removeEventListener</code>来删除。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> hander = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数：事件处理属性名称、处理函数、是否在捕获时执行事件处理函数</span></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,handler,<span class="literal">false</span>/<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>,handler,<span class="literal">false</span>/<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>DOM2 级的事件规定<strong>事件流</strong>包含<strong>三个阶段</strong> ref:<a target="_blank" rel="noopener" href="https://juejin.cn/post/7192584563799883832">JS中的事件冒泡、事件捕获、事件委托  推荐阅读</a></p>
<blockquote>
<p>当一个 HTML 元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为 DOM 事件流</p>
</blockquote>
<ol>
<li class="lvl-6">
<p><strong>捕获阶段</strong>：事件从Document节点<strong>自上而下向目标节点传播</strong>的阶段。</p>
</li>
<li class="lvl-6">
<p><strong>目标阶段</strong>：找到了被触发事件的元素对象，触发事件函数</p>
</li>
<li class="lvl-6">
<p><strong>冒泡阶段</strong>：从被触发事件的元素对象<strong>向上</strong>冒泡传递事件*（注意这里传递的仅仅是事件，而不是绑定的事件函数）*</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p>事件处理过程</p>
<ol>
<li class="lvl-6">
<p>document 首先接收到 click 事件，然后顺着 DOM 树逐级<strong>向下</strong>传递事件，如果在途中经过的节点<strong>定义了相同事件</strong>的处理函数且 <code>addEventListener</code> 第 3 个参数设定为 <code>true</code>【即在事件捕获阶段处理调用处理函数】，那么会调用这个节点的处理函数</p>
</li>
<li class="lvl-6">
<p>事件最终传递到目标节点，调用处理函数</p>
</li>
<li class="lvl-6">
<p>事件逐级向上传播回 document。同捕获阶段，但是第 3 个参数要设置为 <code>false</code>，默认 <code>false</code>。</p>
<p>有些时候我们不希望产生事件冒泡，所以可以<strong>在子事件中加入 <code>e.stopPropagation()</code></strong> 取消冒泡</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7e3d995dee743f8ac61fd09a4b2b3e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p>
</li>
<li class="lvl-6">
<p><strong>事件委托</strong>：</p>
<ol>
<li class="lvl-9">
<p>就是利用<strong>事件冒泡</strong>，把子元素的事件都<strong>绑定到父元素</strong>上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p>
</li>
<li class="lvl-9">
<p>比如给 1000 个按钮注册点击事件，可以采用给这个 1000 个按钮的父节点添加点击元素，并利用事件的 target 获取按钮的相关信息。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69430357f5d4101a7d423d42f723d22~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d4cf8b887a74bd5acf85290557b22e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-3-观察者模式">2.4.3. 观察者模式</h3>
<ol>
<li class="lvl-3">
<p>察者模式定义了一种一对多的依赖关系，<strong>让多个观察者 Observer 对象同时监听某一个主题 Subject 对象</strong>。这个主题对象在状态上发生变化时，会<strong>通知所有观察者对象</strong>，使它们能够自动更新自己。它主要用于<strong>实现分布式事件处理系统。</strong></p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/5.png" alt=""></p>
<h3 id="2-4-4-BOM">2.4.4. BOM</h3>
<p>ref: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Renyi-Fan/p/8077854.html#_label1_0">浏览器对象模型(BOM)是什么?推荐阅读</a></p>
<p><strong>浏览器对象模型</strong>（Browser Object Model，简称 BOM）是 JavaScript 的组成部分之一，BOM 赋予了 JavaScript 程序<strong>与浏览器交互的能力</strong></p>
<blockquote>
<p>能利用BOM做什么？</p>
<ul class="lvl-1">
<li class="lvl-2">BOM提供了一些访问窗口对象的一些方法，我们可以用它来<strong>移动窗口位置</strong>，<strong>改变窗口大小</strong>，<strong>打开新窗口和关闭窗口</strong>，<strong>弹出对话框</strong>，进行导航以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率。但BOM最强大的功能是它提供了一个<strong>访问HTML页面的一入口——document对象</strong>，以使得我们可以通过这个入口来使用DOM的强大功能！</li>
</ul>
<p>DOM对象和BOM对象的关系？</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>DOM对象是BOM对象的大儿子。所以DOM对象的那些<strong>操作都是浏览器来执行的</strong></p>
</li>
</ul>
<p>BOM中的顶级对象是什么，代表什么意思？</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>BOM中的顶级对象是window，代表的是浏览器打开的一整个窗口</p>
</li>
</ul>
</blockquote>
<p>每个浏览器的 Javascript 程序都可以引用以下全局对象：document、history、location、navigator、screen、window</p>
<p><img src="https://images2018.cnblogs.com/blog/1163900/201805/1163900-20180530160230458-211891518.png" alt="img"></p>
<p><strong>document</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个载入浏览器的 HTML 文档都会成为 Document 对象</p>
</li>
<li class="lvl-2">
<p>Document 对象是 HTML 文档的根节点</p>
</li>
</ul>
<p><strong>window</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有浏览器都支持window对象。</p>
</li>
<li class="lvl-2">
<p>它表示浏览器的窗口所有JavaScript全局对象、函数和变量都自动成为窗口对象的成员。window 也是全局对象，可以直接使用</p>
</li>
</ul>
<p><strong>location</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Location 对象包含有关当前 URL 的信息</p>
</li>
</ul>
<p><strong>navigator</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>navigator 对象包含有关浏览器的信息</p>
</li>
<li class="lvl-2">
<p>来自navigator对象的信息通常会产生误导，不应该用于检测浏览器版本：因为所有者可以任意更改</p>
</li>
</ul>
<p><strong>screen</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>screen对象包含有关客户端显示屏幕的信息</p>
</li>
</ul>
<p><strong>history</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>history对象包含用（在浏览器窗口中）访问过的 URL</p>
</li>
</ul>
<h2 id="不考——2-5-Ajax">不考——2.5. Ajax</h2>
<h3 id="2-5-1-RIA-Rich-Internet-Applications-富互联网应用">2.5.1. RIA Rich Internet Applications 富互联网应用</h3>
<ol>
<li class="lvl-3">
<p>是一种具有近似于传统桌面应用软件系统<strong>功能和特性</strong>的网络应用系统。</p>
</li>
<li class="lvl-3">
<p>RIA 系统最大的<strong>特点</strong>是将大部分处理任务都从<strong>用户界面端移植到客户端</strong>，仅保留一些必要数据与服务器端进行信息交互。</p>
</li>
<li class="lvl-3">
<p>RIA 系统的特性：</p>
<ol>
<li class="lvl-6">运行于浏览器中，不需要额外安装支持软件</li>
<li class="lvl-6">在本地运行时，受安全沙箱全程保护。</li>
</ol>
</li>
<li class="lvl-3">
<p>优点</p>
<ol>
<li class="lvl-6">无需安装</li>
<li class="lvl-6">容易升级</li>
<li class="lvl-6">可以通过 Internet/intranet 轻易获得</li>
<li class="lvl-6">更加丰富的用户界面</li>
<li class="lvl-6">响应速度更快的用户界面</li>
<li class="lvl-6">客户端/服务端 负载平衡</li>
<li class="lvl-6">异步通讯</li>
<li class="lvl-6">网络效率</li>
</ol>
</li>
<li class="lvl-3">
<p>缺点</p>
<ol>
<li class="lvl-6">搜索引擎不可见</li>
<li class="lvl-6">专有 ( 与开放标准相反 )</li>
<li class="lvl-6">完整性丧失 (RIA 通常无法与 HTML 很好地融合在一起 )</li>
<li class="lvl-6">软件开发的复杂性 ( 什么东西要被缓存或不缓存再客户端计算机中？)</li>
<li class="lvl-6">RIA 体系结构打破了网页范例</li>
<li class="lvl-6">受限于安全沙箱</li>
</ol>
</li>
<li class="lvl-3">
<p>实现方式</p>
<ol>
<li class="lvl-6">浏览器插件
<ul class="lvl-4">
<li class="lvl-8">Flash/Flex, Java Swing, Silverlight</li>
<li class="lvl-8">潜在的更强的交互性，更⾼的应用障碍</li>
<li class="lvl-8">关注开放/控制</li>
</ul>
</li>
<li class="lvl-6">在浏览器中，不需要插件
<ul class="lvl-4">
<li class="lvl-8">AJAX</li>
<li class="lvl-8">更低的采用门槛</li>
<li class="lvl-8">跨浏览器问题?</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-5-2-同步、异步通信">2.5.2. 同步、异步通信</h3>
<h4 id="2-5-2-1-同步">2.5.2.1. 同步</h4>
<ol>
<li class="lvl-3">
<p>同步请求/响应通信模型中，总是浏览器 ( 与 Web 服务器、应用服务器或 Web 应用程序相对 ) 发起请求 ( 通过 Web 用户 )。接着，Web 服务器、应用服务器或 Web 应用程序响应进入的请求。在处理同步请求/响应对期间，用户不能继续使用浏览器。</p>
</li>
<li class="lvl-3">
<p>基本上所有新数据都需要刷新页面</p>
</li>
<li class="lvl-3">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223160754341.png" alt="image-20230223160754341" style="zoom:50%;" />
</li>
</ol>
<h4 id="2-5-2-2-异步">2.5.2.2. 异步</h4>
<ol>
<li class="lvl-3">
<p>Web 用户在当前异步请求被处理时还可以继续使用浏览器。一旦异步请求处理完成，异步响应就被通信 ( 从 Web 服务器、应用服务器或 Web 应用程序 ) 回客户机页面。典型情况下，在这个过程中，调用对 Web 用户没有影响；他们不需要等候响应。</p>
</li>
<li class="lvl-3">
<p>交换数据并修改页面但是不需要刷新页面</p>
</li>
<li class="lvl-3">
<img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223160809598.png" alt="image-20230223160809598" style="zoom:50%;" />
</li>
</ol>
<h3 id="2-5-3-Ajax-请求">2.5.3. Ajax 请求</h3>
<p>Asynchronous JavaScript And XML 是⼀种使用 <strong>XMLHttpRequest</strong> 技术构建更复杂，动态的网页的编程实践。</p>
<p>尽管 X 在 Ajax 中代表 XML，但由于JSON的许多优势，比如更加轻量以及作为 Javascript  的⼀部分，目前 JSON 的使用比 XML 更加普遍。<strong>JSON 和 XML 都被用于在 Ajax 模型中打包信息</strong></p>
<ol>
<li class="lvl-3">
<p>通过在后台与服务器进行<strong>少量数据交换</strong>，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，<strong>对网页的某部分进行更新。</strong></p>
</li>
<li class="lvl-3">
<p>传统的网页 ( 不使用 AJAX) 如果需要更新内容，必需重载整个网页面。</p>
</li>
</ol>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/6.png" style="zoom: 33%;" />
<h3 id="2-5-4-Ajax-优缺点">2.5.4. Ajax 优缺点</h3>
<ol>
<li class="lvl-3">
<p>优点</p>
<ol>
<li class="lvl-6">更好的交互性和响应能力，使用起来更让人愉快。</li>
<li class="lvl-6">由于部分渲染，减少了与 Web 服务器的连接。</li>
<li class="lvl-6">因为只加载需要更新页面的数据，而不是刷新整个页面，所以可以节省带宽，减少网络流量。</li>
</ol>
</li>
<li class="lvl-3">
<p>缺点</p>
<ol>
<li class="lvl-6">返回和刷新按钮变得无用。</li>
<li class="lvl-6">为此页面添加书签将变得无用。</li>
<li class="lvl-6">需要在 Web 浏览器上启用 JavaScript。</li>
<li class="lvl-6">网络延迟可能会破坏可用性。</li>
<li class="lvl-6">通过 AJAX 加载的数据不会被任何主要的搜索引擎索引。因此，<strong>使 SEO 不友好</strong>。违背 URL 和资源定位的初衷</li>
</ol>
</li>
</ol>
<h3 id="2-5-5-XMLHttpRequest">2.5.5. XMLHttpRequest</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>XMLHttpRequest 对象是 AJAX 最重要的组件</p>
</li>
<li class="lvl-2">
<p>用于使用 <strong>HTTP</strong> 在 Web 服务器之间<strong>传输和操作 XML/JSON/文本数据</strong></p>
</li>
<li class="lvl-2">
<p>执行操作：</p>
<ul class="lvl-2">
<li class="lvl-4">在后台从客户端发送数据</li>
<li class="lvl-4">从服务器接收数据</li>
<li class="lvl-4">更新网页，无需重新加载</li>
</ul>
</li>
</ul>
<h3 id="2-5-6-Ajax请求流程">2.5.6. Ajax请求流程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端事件发生，如按钮点击</p>
</li>
<li class="lvl-2">
<p>创建 XHMHttpResquest 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);<span class="comment">//老版本IE</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>创建 XMLHttpRequest 对象后，需要决定在收到服务器对请求的响应后要做什么。</p>
<p>设置 XHMHttpResquest 回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//process the server response</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>XHMHttpResquest 发送异步请求给服务器端，需要调用 XMLHttpRequest 对象的 open() 和 send() 方法</p>
<p>open() 方法的参数:</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>第⼀个参数是 HTTP 请求方法，例如 GET、POST 和 HEAD。</p>
</li>
<li class="lvl-4">
<p>第⼆个参数是请求的 Web 页面的 URL。</p>
</li>
<li class="lvl-4">
<p>第三个参数(可选)设置请求是否是异步的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HTTP GET request without querystring</span></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">GET</span>’,’serverpage.<span class="property">php</span>’,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//HTTP GET request with querystring</span></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">GET</span>’,’serverpage.<span class="property">php</span>?</span><br><span class="line">username=’+<span class="title class_">Math</span>.<span class="title function_">random</span>(),<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">GET</span>’,’serverpage.<span class="property">php</span>?</span><br><span class="line">username=user1&amp;pass=password’,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//HTTP POST request</span></span><br><span class="line">xmlhttp.<span class="title function_">open</span>(‘<span class="variable constant_">POST</span>’,’serverpage.<span class="property">php</span>’,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(‘username=user1&amp;pass=password’);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>服务器端发送结果</p>
</li>
<li class="lvl-2">
<p>XHMHttpResques t传送结果给客户端：</p>
<p>首先，响应函数需要检查请求的就绪状态。如果就绪状态的值为 4，则可以进⼀步执行。</p>
<p>接下来，需要检查HTTP服务器响应的响应代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// everything is good, the response is received</span></span><br><span class="line">    &#125;<span class="keyword">if</span> (xmlhttp.<span class="property">status</span> === <span class="number">200</span>) &#123; </span><br><span class="line">        <span class="comment">// process the response </span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// request encountered some problem,</span></span><br><span class="line">        <span class="comment">// for example, the response may contain a HTTP</span></span><br><span class="line">        <span class="number">404</span> (<span class="title class_">Not</span> <span class="title class_">Found</span>) response code</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// still not ready </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-5-7-安全相关，SOP，跨域">2.5.7. 安全相关，SOP，跨域</h3>
<h4 id="2-5-7-1-安全相关">2.5.7.1. 安全相关</h4>
<blockquote>
<p>XSS 威胁</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>跨站脚本 (Cross site scripting，通常简称为 XSS) 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。 它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。指攻击者在网页中嵌入客户端脚本 ( 例如 JavaScript),当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
</li>
<li class="lvl-3">
<p><strong>AJAX 无法从本地存储的网页上运行，只能在存储在 Web 服务器上的网页上运行</strong></p>
</li>
</ol>
<h4 id="2-5-7-2-SOP">2.5.7.2. SOP</h4>
<ol>
<li class="lvl-3">
<p>同源政策：限制浏览器可以获取的资源，只能从同源网站获取内容 ( 除了资源文件 ) 同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<ol>
<li class="lvl-6">Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li class="lvl-6">DOM 无法获得。</li>
<li class="lvl-6">AJAX 请求不能发送。</li>
</ol>
</li>
</ol>
<h4 id="2-5-7-3-跨域问题">2.5.7.3. 跨域问题</h4>
<ol>
<li class="lvl-3">
<p>当<strong>协议、域名、端口号</strong>中任意一个不同时，都算作不同域</p>
</li>
<li class="lvl-3">
<p>实现跨域的方法</p>
<ol>
<li class="lvl-6">CORS：服务器设置 HTTP 响应头中 Access-Control-Allow-Origin 值，解除跨域限制。</li>
<li class="lvl-6">nginx：反向代理</li>
<li class="lvl-6">Docker</li>
</ol>
</li>
</ol>
<h3 id="2-5-6-数据格式">2.5.6. 数据格式</h3>
<h4 id="2-5-6-1-JSON">2.5.6.1. JSON</h4>
<ol>
<li class="lvl-3">
<p>由 Douglas Crockford 形式化和推广，它是一种<strong>轻量级的、易于简化</strong>的数据格式，使用 JavaScript 对象和数组文本语法编写。</p>
</li>
</ol>
<h4 id="2-5-6-2-JSON-P-JSON-with-Padding">2.5.6.2. JSON-P JSON with Padding</h4>
<ol>
<li class="lvl-3">
<p>带填充的 JSON</p>
</li>
<li class="lvl-3">
<p>当使用动态脚本标记插入时，JSON 数据被视为另一个 JavaScript 文件，并作为本机代码执行。为了实现这一点，数据必须包装在回调函数中。</p>
</li>
<li class="lvl-3">
<p>由于数据被当作原生 JS，<strong>因此它以原生 JavaScript 的速度被解析</strong>。</p>
</li>
<li class="lvl-3">
<p>避免使用与性能无关的 JSON-P 有一个原因：由于 JSON-P 必须是可执行的 JavaScript，因此任何人都可以调用它，并使用动态脚本标记插入将其包含在任何网站中。</p>
</li>
<li class="lvl-3">
<p>不要在 JSON-P 中对任何敏感数据进行编码，因为您无法确保它保持私有，即使使用随机 url 或 cookie。</p>
</li>
</ol>
<h1>3. 服务器端</h1>
<h2 id="3-1-Node-js-重要">3.1. Node.js 重要</h2>
<ol>
<li class="lvl-3">
<p>Node.js <strong>不是⼀个web框架，也不是⼀种语言，而是一个运行时环境（类比 JVM）</strong></p>
</li>
<li class="lvl-3">
<p>Node.js 使用<strong>事件驱动</strong>的<strong>非阻塞异步 I/O 模型</strong>，在单⼀进程中可以处理成千上万的<strong>并发</strong>连接，非常适合处理<strong>高并发</strong>。Node所针对的应用程序有⼀个专门的简称：<strong>DIRT</strong>，表示<strong>数据密集型实时</strong>（data-intensive real-time）<strong>程序</strong>【但都对 cpu 使用少】</p>
</li>
</ol>
<h3 id="3-1-1-特点，应用场景">3.1.1. 特点，应用场景</h3>
<h4 id="3-1-1-1-优缺点-适用不适用场景">3.1.1.1. 优缺点/适用不适用场景</h4>
<ol>
<li class="lvl-3">
<p>优点：</p>
<ol>
<li class="lvl-6"><strong>高并发</strong>（最重要的优点）</li>
<li class="lvl-6">适合<strong>I/O密集型</strong>应用</li>
<li class="lvl-6">同样是 js 客户端和服务端<strong>切换成本低</strong></li>
<li class="lvl-6">npm 丰富</li>
<li class="lvl-6"><strong>可移植</strong>到不同平台</li>
</ol>
</li>
<li class="lvl-3">
<p>缺点：</p>
<ol>
<li class="lvl-6"><strong>不适合CPU密集型应用</strong>；CPU密集型应用给Node带来的挑战主要是：由于JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起</li>
<li class="lvl-6"><strong>大内存的应用</strong>：由于 V8 引擎有内存设计的限制，32 位环境中最大堆是 1G，64 位环境中最大堆也不到 2G</li>
<li class="lvl-6"><strong>静态服务器</strong>，和 Nginx 的处理静态资源还是有很大的差距</li>
<li class="lvl-6"><strong>不需要异步的应用</strong>，Nodejs 的异步调用可能会给编程带来⼀些麻烦</li>
</ol>
</li>
</ol>
<h4 id="3-1-1-2-应用场景">3.1.1.2. 应用场景</h4>
<ol>
<li class="lvl-3">
<p>网站</p>
</li>
<li class="lvl-3">
<p>聊天应用程序是最能体现 Node.js 优点的例子</p>
</li>
<li class="lvl-3">
<p>HTTP 代理</p>
</li>
<li class="lvl-3">
<p>前端构建工具 ( 脚手架 )</p>
</li>
<li class="lvl-3">
<p>写操作系统 (NodeOS)</p>
</li>
<li class="lvl-3">
<p>跨平台打包工具</p>
</li>
</ol>
<h3 id="3-1-2-基本原理">3.1.2. 基本原理</h3>
<p>ref:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6903165908815904775">深入理解Nodejs单线程实现高并发原理</a></p>
<p>nodejs运行环境 = 主线程(单线程,包括事件队列) + 线程池(工作线程池,执行其他工作-多线程)</p>
<ol>
<li class="lvl-3">
<p><strong>运行机制</strong></p>
<ul class="lvl-2">
<li class="lvl-5">V8 引擎解析 JavaScript 脚本。</li>
<li class="lvl-5">解析后的代码，调用 Node API。</li>
<li class="lvl-5">libuv 库<strong>负责</strong>Node API 的<strong>执行</strong>。它将不同的任务分配给不同的 worker 线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li class="lvl-5">V8 引擎再将结果返回给用户。</li>
<li class="lvl-5"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e2388393d845f0ae8de01090449370~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></li>
<li class="lvl-5"><strong>具体执行：<strong>事件机制都是用设计模式中</strong>观察者模式</strong>实现。
<ul class="lvl-4">
<li class="lvl-7">维护了一个<strong>事件队列（Event queue）</strong>，事件到来就加入事件队列。主线程从事件队列中取出事件，再从线程池中分配一个线程去执行这个事件，当有事件执行完毕后，会通知主线程，<strong>主线程把要执行回调的事件也加入事件队列，后续再执行</strong>，线程归还给线程池。</li>
<li class="lvl-7"><strong>异步操作是由线程池完成的</strong>，node 将所有的阻塞操作都交给了内部的线程池去实现，<strong>本身只负责不断的往返调度</strong>，并没有进行真正的I/O操作，<strong>从而实现异步非阻塞 I/O</strong></li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>4 个层次</strong></p>
<ul class="lvl-2">
<li class="lvl-5">应用层：   即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs</li>
<li class="lvl-5">V8 引擎层：  即利用 V8 引擎来解析JavaScript 语法，进而和下层 API 交互</li>
<li class="lvl-5">NodeAPI 层：  为上层模块提供<strong>系统调用</strong>，一般是由 C 语言来实现，和操作系统进行交互 。</li>
<li class="lvl-5">LIBUV 层： 是跨平台的<strong>底层封装</strong>，实现了 事件循环、文件操作等，是 Node.js <strong>实现异步的核心</strong></li>
</ul>
</li>
<li class="lvl-3">
<p><strong>单线程</strong></p>
<ol>
<li class="lvl-6">
<p>Node 遵循的是<strong>单线程单进程的模式</strong>，node 的单线程是指js的引擎只有一个实例，且在 nodejs 的主线程中执行，同时 node 以<strong>事件驱动</strong>的方式<strong>处理 IO 等异步操作</strong>。node的单线程模式，<strong>只维持一个主线程</strong>，大大减少了线程间切换的开销，但是<strong>会有多个 worker 线程，用于执行异步操作</strong>。</p>
</li>
<li class="lvl-6">
<p>但是 node 的单线程使得在<strong>主线程不能进行CPU密集型操作</strong>，否则会<strong>阻塞主线程</strong>。</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>异步 I/O</strong></p>
</li>
</ol>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/7.png" style="zoom:33%;" />
<ol start="5">
<li class="lvl-3">
<p><strong>事件循环驱动</strong></p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/8.png" alt=""></p>
<blockquote>
<ol start="6">
<li class="lvl-3">
<p>网上解释</p>
<ol>
<li class="lvl-6">Node.js：<strong>单线程，异步 I/O，事件驱动</strong></li>
<li class="lvl-6">应用程序的请求过程可以分为俩个部分：CPU 运算和 I/O 读写
<ol>
<li class="lvl-9">CPU 计算速度通常远高于磁盘读写速度，这就导致 CPU 运算已经完成，但是不得不等待磁盘 I/O 任务完成之后再继续接下来的业务。</li>
<li class="lvl-9">所以 I/O 才是应用程序的瓶颈所在，在 I/O 密集型业务中，假设请求需要 100ms 来完成，其中 99ms 花在 I/O 上。</li>
</ol>
</li>
<li class="lvl-6">如果需要优化应用程序，让他能同时处理更多的请求，我们会采用<strong>多线程</strong>，同时开启 100 个、1000 个线程来提高我们请求处理，当然这也是一种可观的方案。但是由于一个 CPU 核心在<strong>一个时刻</strong>只能做一件事情，操作系统只能通过将 CPU 切分为时间片的方法，让线程可以较为均匀的使用 CPU 资源。</li>
<li class="lvl-6">操作系统在内核切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。那么是否可以另辟蹊径呢？！</li>
<li class="lvl-6">我们先来看看单线程，《深入浅出 Node》一书提到&quot;单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销&quot;，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Web-Front-End-development/img/exam1/9.png" alt=""></p>
<ol start="5">
<li class="lvl-3">
<p>Node.js 的单线程并不是真正的单线程，只是开启了单个线程进行业务处理 (cpu 的运算 )，同时开启了其他线程专门处理 I/O。当一个指令到达主线程，主线程发现有 I/O 之后，直接把这个事件传给 I/O 线程，不会等待 I/O 结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是&quot;单线程&quot;、“异步 I/O”。</p>
</li>
<li class="lvl-3">
<p>I/O 操作完之后呢？Node.js 的 I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时 node 会创建一个类似于 While(true) 的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的&quot;事件驱动&quot;。这也从 Node 的角度解释了什么是&quot;事件驱动&quot;。在 node.js 中，事件主要来源于网络请求，文件 I/O 等，根据事件的不同对观察者进行了分类，有文件 I/O 观察者，网络 I/O 观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行 I/O 等待。</p>
</li>
</ol>
</blockquote>
<h2 id="3-2-模块">3.2. 模块</h2>
<p>两种<strong>模块规范</strong></p>
<ol>
<li class="lvl-3">
<p>ES6 模块，简称 ESM Node.js</p>
</li>
<li class="lvl-3">
<p>CommonJS 模块，简称 CJS</p>
</li>
<li class="lvl-3">
<p><strong>CommonJS 模块是 Node.js 专用的</strong>，与 ES6 模块不兼容。而<strong>ES6模块化在浏览器和node.js中都可以用。</strong></p>
</li>
</ol>
<h3 id="3-2-1-差异">3.2.1. <strong>差异</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>语法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">CommonJS 模块使用 <code>require()</code> 加载和 <code>module.exports</code> 输出</li>
<li class="lvl-5">ES6 模块使用 <code>import</code> 和 <code>export</code></li>
</ul>
</li>
<li class="lvl-3">
<p><strong>机制</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>输出</strong>：CommonJS 模块输出的是一个<strong>值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。</p>
</li>
<li class="lvl-5">
<p><strong>加载</strong>：CommonJS 模块是<strong>同步加载</strong>，ES6 模块是<strong>静态解析</strong>。</p>
<ul class="lvl-4">
<li class="lvl-7">原因：CommonJS 加载的是一个<strong>对象</strong>（即module.exports属性），该对象只有在脚本运行完才会生成。而 <strong>ES6 模块不是对象</strong>，它的对外接口只是一种<strong>静态定义</strong>，在代码<strong>静态解析阶段就会生成</strong>。</li>
</ul>
</li>
<li class="lvl-5">
<pre><code class="language-js">// 例子
// CJS
// lib.js
var counter = 3;
function incCounter() &#123;
 counter++;
&#125;
module.exports = &#123;
 counter: counter,
 incCounter: incCounter,
&#125;;
// main.js
var mod = require('./lib');
console.log(mod.counter); // 3
mod.incCounter();
console.log(mod.counter); // 3，值没有变化，因为是拷贝

// ES6
// lib.mjs
export let counter = 3;
export function incCounter() &#123;
 counter++;
&#125;
// main.mjs
import &#123; counter, incCounter &#125; from ‘./lib.mjs’;
console.log(counter); // 3
incCounter();
console.log(counter); // 4，增加，因为是值的引用
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-2-循环加载">3.2.2. 循环加载</h3>
<p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<ul class="lvl-0">
<li class="lvl-3">
<p>CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异</p>
</li>
<li class="lvl-3">
<p>ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from 'foo'</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</p>
</li>
<li class="lvl-3">
<p>详细解释见：[24. Module 的加载实现 - 循环加载 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack](<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-module-loader.md#:~:text=ES6">https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-module-loader.md#:~:text=ES6</a> 模块的循环加载 ES6 处理“循环加载”与 CommonJS 有本质的不同。 ES6,模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from ‘foo’ ），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。)</p>
</li>
</ul>
<h1>4. 优化 重要</h1>
<h2 id="4-1-基准测试-性能分析">4.1. 基准测试/性能分析</h2>
<ol>
<li class="lvl-3">
<p>通过设计科学的<strong>测试方法、测试工具和测试系统</strong>，实现对一类测试对象的某项性能指标进行定量和可对比的测试</p>
</li>
<li class="lvl-3">
<p>延迟(传播、传输、处理、排队) 和带宽</p>
</li>
<li class="lvl-3">
<p>Web <strong>性能要点</strong>⭐</p>
<ol>
<li class="lvl-6"><strong>延迟和带宽</strong>对 Web 性能的影响</li>
<li class="lvl-6"><strong>传输协议</strong> (TCP) 对 HTTP 的限制</li>
<li class="lvl-6"><strong>HTTP 协议自身</strong>的功能和缺陷</li>
<li class="lvl-6">Web <strong>应用</strong>的<strong>发展趋势及性能需求</strong></li>
<li class="lvl-6"><strong>浏览器局限性</strong>和优化思路</li>
</ol>
</li>
<li class="lvl-3">
<p>浏览器<strong>渲染</strong>过程：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">渲染页面：浏览器的工作原理 - Web 性能 | MDN (mozilla.org)</a></p>
</li>
<li class="lvl-3">
<p><strong>性能监控指标</strong></p>
<ol>
<li class="lvl-6"><strong>FP</strong>：First Paint 首次绘制，页面第一次绘制的<strong>时间点</strong>：只要出现视觉变化，<strong>无论什么</strong>。</li>
<li class="lvl-6"><strong>FCP</strong>：First Contentful Paint 首次内容绘制，完成对 DOM 中的一部分内容渲染的<strong>时间点</strong>：首次绘制来自 DOM 的内容。
<ul class="lvl-4">
<li class="lvl-8"><strong>注意</strong>：只有首次绘制<strong>文本、图片（包含背景图）、非白色的 canvas 或 SVG</strong> 时才被算作 FCP</li>
<li class="lvl-8">FP和FCP可能是相同的时间，也可能是先FP后FCP</li>
</ul>
</li>
<li class="lvl-6"><strong>FMP</strong>：First Meaningful Paint 首次有意义绘制，页面<strong>关键</strong>元素的渲染时间，没有标准定义，由<strong>开发者自行定义</strong>。</li>
<li class="lvl-6"><strong>首屏时间</strong>：应用渲染完<strong>整个屏幕的时间</strong>。</li>
<li class="lvl-6"><strong>用户可交互时间</strong>： Time to Interactive DOMReady 时间，即可以进行交互的时间点，如果涉及交互的 JS 没有加载好，那么就不能交互</li>
<li class="lvl-6"><strong>总下载时间</strong>：页面<strong>所有资源加载完成</strong>的时间，一般<strong>统计 window.onload 时间</strong>，也可以是异步渲染全部完成的时间。</li>
<li class="lvl-6"><strong>第一个字节加载时间</strong></li>
<li class="lvl-6">页面渲染时间：瀑布流中两个指标 Start Render 和 msFirstPaint
<ol>
<li class="lvl-9">Start Render：通过捕获页面加载的视频，实验室测量。</li>
<li class="lvl-9">msFirstPaint：是浏览器本身报告的测量。</li>
</ol>
</li>
<li class="lvl-6">自定义指标</li>
</ol>
</li>
<li class="lvl-3">
<p>相关工具</p>
</li>
</ol>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223174846570.png" alt="image-20230223174846570"></p>
<h2 id="4-2-基本原理">4.2. 基本原理</h2>
<ol>
<li class="lvl-3">
<p><strong>浏览器</strong>核心优化策略</p>
<ol>
<li class="lvl-6"><strong>资源预取和排定优先次序</strong>：声明每种资源的优先级</li>
<li class="lvl-6">推测性优化：
<ol>
<li class="lvl-9"><strong>DNS 预解析</strong>：对可能的域名进行提前解析。</li>
<li class="lvl-9"><strong>TCP 预连接</strong>：DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。</li>
<li class="lvl-9"><strong>页面预渲染</strong>：某些浏览器可以让我们提示下⼀个可能的目标，从而在隐藏的标签页中预先渲染整个页面。</li>
</ol>
</li>
</ol>
</li>
<li class="lvl-3">
<p>web 性能优化<strong>两个准则</strong></p>
<ol>
<li class="lvl-6"><strong>消除或减少</strong>不必要的<strong>网络延迟</strong></li>
<li class="lvl-6">将需要传输的<strong>数据</strong>压缩至<strong>最少</strong></li>
</ol>
</li>
</ol>
<h2 id="4-3-优化思路，技术，方法">4.3. 优化思路，技术，方法</h2>
<h3 id="4-3-1-优化思路">4.3.1. 优化思路</h3>
<ol>
<li class="lvl-3">
<p>减少 DNS 查找</p>
</li>
<li class="lvl-3">
<p>重用 TCP 连接</p>
</li>
<li class="lvl-3">
<p>减少 HTTP 重定向</p>
</li>
<li class="lvl-3">
<p>使用内容分发网络</p>
</li>
<li class="lvl-3">
<p>避免不必要的资源请求</p>
</li>
<li class="lvl-3">
<p>在客户端缓存部分资源</p>
</li>
<li class="lvl-3">
<p>资源传输前先压缩</p>
</li>
<li class="lvl-3">
<p>避免不必要的请求字节</p>
</li>
<li class="lvl-3">
<p>并行处理请求和响应</p>
</li>
<li class="lvl-4">
<p>针对协议版本采取优化措施</p>
</li>
</ol>
<h3 id="4-3-2-具体的优化方法">4.3.2. 具体的优化方法</h3>
<ol>
<li class="lvl-3">
<p>CSS：CSS 放置在 HTML 顶部，减少 CSS 文件，避免绝对 CSS。</p>
</li>
<li class="lvl-3">
<p>Image：合适的图片大小，而不是浏览器调整</p>
</li>
<li class="lvl-3">
<p>js：将 js 放在 html 的底部，尽量用外部 js</p>
</li>
<li class="lvl-3">
<p>服务器优化：减少域名查找，数据压缩</p>
</li>
<li class="lvl-3">
<p>html：标准兼容、去除空白符、结构尽量简单、做到浏览器和移动端的兼容</p>
</li>
<li class="lvl-3">
<p><strong>针对 HTTP1.x 的优化</strong></p>
<ol>
<li class="lvl-6">利用 <strong>http 管道</strong></li>
<li class="lvl-6">域名分片：将资源分散到多个来源</li>
<li class="lvl-6">打包资源以减少 HTTP 请求</li>
<li class="lvl-6">父文档中嵌入小资源：从而减少请求数量</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>HTTP2 优化</strong></p>
<ol>
<li class="lvl-6">少发数据，减少请求，减少传输数据量和不必要网络延迟，调整资源供给</li>
<li class="lvl-6">每个来源一个链接 ( 多个链接会抵消新协议中首部压缩和请求优先级的作用，域名分区在 HTTP2 下是反作用的 )</li>
<li class="lvl-6">去掉不必要资源打包 (资源打包不利于缓存，单个文件比较大 )</li>
<li class="lvl-6">利用服务器推送 ( 充分使用缓存的机制，即还没有收到浏览器的请求，服务器就把各种资源推送给浏览器；比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 )</li>
</ol>
</li>
</ol>
<h1>5. 前端鉴权</h1>
<h2 id="5-1-术语">5.1. 术语</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>认证</strong>(Identification)： 是指根据声明者所<strong>特有的识别信息</strong>，<strong>确认</strong>声明者的<strong>身份</strong>。如用户名密码，身份证</p>
</li>
<li class="lvl-2">
<p><strong>授权</strong>(Authorization)： 在信息安全领域是指资源所有者委派执行者，<strong>赋予</strong>执行者指定范围的<strong>资源操作权限</strong>，以便对资源的相关操作。如 session，cookie，token</p>
</li>
<li class="lvl-2">
<p><strong>鉴权</strong>(Authentication)：在信息安全领域是指对于⼀个声明者<strong>所声明的身份权利</strong>，对其所<strong>声明的真实性进行鉴别</strong>确认的过程。如确认 token 是否合法、是否到期</p>
<ul class="lvl-2">
<li class="lvl-4">鉴权是⼀个承上启下的⼀个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下⼀步的权限控制做好准备。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>权限控制</strong>(Access/Permission Control)：将可执行的<strong>操作</strong>定义为<strong>权限列表</strong>，然后判断操作<strong>是否允许/禁止</strong>。如通过 web 后端服务，来控制接口访问，允许或拒绝访问请求</p>
<p><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20230223192856091.png" alt="image-20230223192856091"></p>
</li>
</ul>
<h2 id="5-2-方案">5.2 方案</h2>
<p>见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7129298214959710244#heading-49">一文教你搞定所有前端鉴权与后端鉴权方案</a></p>
<h1>6. 登录注册</h1>
<h1>7. 前端主题切换</h1>
<p>见 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/J90TYDJGmo8KCTsawT-vIg">前端主题切换方案</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">方案/主题样式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>方案1：link标签动态引入</strong>（js 修改引入 css 的 link 标签；文件过大，切换延时，不推荐，但首屏时间短）</td>
</tr>
<tr>
<td style="text-align:left"><strong>方案2：提前引入所有主题样式，做类名切换</strong>（要为变换主题的每个内容写 css）</td>
</tr>
<tr>
<td style="text-align:left"><strong>方案3：CSS变量+类名切换</strong>（使用 css 变量，要用到的地方使用 var(–color)即可，不用给每个内容都写 css）【建议】</td>
</tr>
<tr>
<td style="text-align:left">方案4：Vue3新特性（v-bind）</td>
</tr>
<tr>
<td style="text-align:left">方案5：SCSS + mixin + 类名切换</td>
</tr>
<tr>
<td style="text-align:left">方案6：CSS变量+动态setProperty</td>
</tr>
</tbody>
</table>
<h1>6. 题型</h1>
<h2 id="6-1-基本概念-所有课件中涉及的，不限于总结">6.1. 基本概念 ( 所有课件中涉及的，不限于总结 )</h2>
<h2 id="6-2-简答题">6.2. 简答题</h2>
<h2 id="6-3-问答题">6.3. 问答题</h2>
<h1>7. 2023 web回忆</h1>
<h2 id="7-1-基本概念">7.1. 基本概念</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>URN</p>
</li>
<li class="lvl-2">
<p>CSSOM</p>
</li>
<li class="lvl-2">
<p>SVG</p>
</li>
<li class="lvl-2">
<p>CANVAS</p>
</li>
<li class="lvl-2">
<p>render tree</p>
</li>
<li class="lvl-2">
<p>WebAssembly</p>
</li>
</ul>
<h2 id="7-2-简答题">7.2. 简答题</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>web3.0 特点</p>
</li>
<li class="lvl-2">
<p>箭头函数和普通函数的区别</p>
</li>
<li class="lvl-2">
<p>NodeJs高并发原因</p>
</li>
<li class="lvl-2">
<p>js 数据类型</p>
</li>
<li class="lvl-2">
<p>前端智能的理解，前端智能的典型应用</p>
</li>
<li class="lvl-2">
<p>闭包的定义，优缺点，应用场景</p>
</li>
<li class="lvl-2">
<p>状态码含义：200、301、303，404，500</p>
</li>
</ul>
<h2 id="7-3-问答题">7.3. 问答题</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>列举前端流行框架，什么是 Vanilla JS，为什么要推广 Vanilla JS</p>
</li>
<li class="lvl-2">
<p>http1——http3的发展，各自特点，http3 解决了前面什么问题</p>
</li>
<li class="lvl-2">
<p>前端鉴权 4 种方式，优缺点（20 分）</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处。
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://wbl-z.github.io/web%E5%89%8D%E7%AB%AF/web%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2+2023%E5%9B%9E%E5%BF%86/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%89%8D%E7%AB%AF/" rel="tag">web前端</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">1 词法分析</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i>  zzb
      </li>
    </ul>
    <ul>
      <li>
        R<i class="ri-heart-fill heart_icon"></i>Z
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="wbl-z&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    
      <li class="nav-item">
          <a href="https://github.com/wbl-z" target="_blank" class="my_link_li">
              <img src="/images/github.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://blog.csdn.net/m0_51691879" target="_blank" class="my_link_li">
              <img src="/images/csdn.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://juejin.cn/user/13645532637448" target="_blank" class="my_link_li">
              <img src="/images/%E6%8E%98%E9%87%91.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="mailto:1214345406@qq.com" target="_blank" class="my_link_li">
              <img src="/images/envelope.png">
          </a>
      </li>
      
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>