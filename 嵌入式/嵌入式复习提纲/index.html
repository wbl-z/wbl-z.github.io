<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="技术，编程，代码，教程，Java" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>嵌入式复习提纲 |  wbl-z&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/logo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?edcb9d2dbc760f6eeab5900f9b363881";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-嵌入式复习提纲"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  嵌入式复习提纲
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" class="article-date">
  <time datetime="2022-08-26T14:02:10.000Z" itemprop="datePublished">2022-08-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">32 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-嵌入式系统">1. 嵌入式系统</h2>
<h3 id="1-1-定义">1.1. 定义</h3>
<ul>
<li>IEEE定义：用于控制、监控或者辅助操作机器和设备的装置</li>
<li>国内定义：嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专业计算机系统</li>
<li><strong>三要素：</strong>
<ul>
<li>嵌入性</li>
<li>专用性:专用型，软硬件按对象要求设计、裁剪</li>
<li>计算机:实现对象的智能化功能</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="1-2-特点">1.2. 特点</h3>
<ol>
<li>形式多样，面向特定应用</li>
<li>得到多种类型处理器和处理器体系结构的支持</li>
<li>关注成本</li>
<li>有实时性和可靠性要求</li>
<li>使用的操作系统是适应多种处理器、可裁剪、轻量型、实时可靠、可固化的嵌入式操作系统</li>
<li>需要专门工具和特殊方法开发</li>
</ol>
<h3 id="1-3-分类">1.3. 分类</h3>
<ul>
<li>
<p>按处理器位数：</p>
<ul>
<li><img src="https://wbl-z-pic.obs.cn-east-3.myhuaweicloud.com/image-20221031163604768.png" alt="image-20221031163604768"></li>
</ul>
</li>
<li>
<p>按应用：信息家电、汽车电子、通信、移动终端、工业控制</p>
</li>
<li>
<p>按速度：强实时系统、一般实时系统、弱实时系统</p>
</li>
<li>
<p>按确定性：</p>
<ul>
<li>硬实时系统：如果系统响应时间不能满⾜，就要引起系统崩溃或致命的错误</li>
<li>软实时系统：如果系统响应时间不能满⾜，不会导致系统出现致命的错误或崩溃</li>
</ul>
</li>
<li>
<p>按复杂程度：循环轮询系统、有限状态机系统、前后台机系统、单处理器多任务系统、多处理器多任务系统</p>
</li>
</ul>
<h3 id="1-4-典型应用">1.4. 典型应用</h3>
<p>工控设备、军用电子设备、航空航天、汽车电子、智能家居、智能驾驶、智能玩具、可穿戴设备</p>
<h3 id="1-5-嵌入式系统基本组成">1.5. 嵌入式系统基本组成</h3>
<p>由嵌入式硬件和软件组成</p>
<ul>
<li>硬件：微处理器为核心集成存储器和系统专用的输入输出设备</li>
<li>软件：初始化代码及驱动、嵌入式操作系统和应用程序有机结合，形成系统特定的一体化软件。</li>
</ul>
<h3 id="1-6-IOT基本组成">1.6. IOT基本组成</h3>
<p>物联网：物理设备之间的互联网络，相互之间可以收集和交换信息。</p>
<h3 id="1-7-CPS的基本组成">1.7. CPS的基本组成</h3>
<ol>
<li>CPS：信息物理系统（Cyber-Physical Systems）作为计算机进程和物理进程的统一体，是集成计算、通信与控制于一体的下一代智能系统。</li>
<li>嵌入式系统、互联网和控制器组成</li>
<li><strong>典型应用</strong>是汽车电子的GPS定位系统</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/1.png" alt=""></p>
<h2 id="2-嵌入式系统设计">2. 嵌入式系统设计</h2>
<h3 id="2-1-嵌入式系统面临挑战">2.1. 嵌入式系统面临挑战</h3>
<ul>
<li>可靠性：如何保证系统可靠地工作</li>
<li>实时性：如何满足时限要求</li>
<li>成本：需要多少硬件</li>
<li>功耗：如何降低系统的功耗</li>
<li>易升级：如何设计以保证系统可升级</li>
</ul>
<h3 id="2-2-传统开发过程">2.2. 传统开发过程</h3>
<ol>
<li>系统在一开始就被划分为软件和硬件两大部分</li>
<li>软件和硬件独立进行开发设计</li>
<li>硬件优先经常被采取</li>
</ol>
<h3 id="2-3-软硬件协同设计">2.3. 软硬件协同设计</h3>
<ol>
<li>增加了系统的灵活性</li>
<li>提高设计的可预测性</li>
</ol>
<h3 id="2-4-软硬件的划分">2.4. 软硬件的划分</h3>
<ol>
<li>嵌入式系统的设计涉及硬件与软件部分，<strong>设计中必须决定什么功能由硬件实现，什么功能由软件实现。</strong> <strong>【硬件速度快，软件可修改性强】</strong></li>
<li>硬件和软件具有<strong>双重性</strong>【既可以让硬件来实现，也可以让软件来实现】</li>
<li>软硬件变动对系统的决策造成影响</li>
<li>划分和选择需要考虑多种因素</li>
<li>硬件和软件的双重性是划分决策的<strong>前提</strong></li>
</ol>
<h2 id="3-嵌入式硬件系统基础">3. 嵌入式硬件系统基础</h2>
<h3 id="3-1-嵌入式微处理器体系结构">3.1. 嵌入式微处理器体系结构</h3>
<h4 id="3-1-1-冯诺依曼结构和哈佛结构">3.1.1. 冯诺依曼结构和哈佛结构</h4>
<ol>
<li>
<p><strong>冯诺伊曼结构</strong></p>
<p>数据和程序放在同一个存储单元，统一编址，指令和数据通过同一个总线访问。</p>
</li>
<li>
<p><strong>哈佛结构</strong></p>
<ol>
<li>数据和程序存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器。</li>
<li>每个存储器独立编址、独立访问。</li>
<li>与之相对应的是系统中设置的两条总线(程序总线和数据总线)， 允许同时进行两次内存提取，更大的带宽。</li>
<li>哈佛结构不能使用自我修改的代码。</li>
</ol>
</li>
</ol>
<h4 id="3-1-2-CISC与RISC">3.1.2. CISC与RISC</h4>
<ul>
<li>
<p>CISC：复杂指令集（许多地址格式，许多操作）</p>
</li>
<li>
<p>RISC：精简指令集（流水型指令）</p>
<table>
<thead>
<tr>
<th></th>
<th>CISC</th>
<th>RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td>价格</td>
<td>由硬件完成部分软件功能，硬件复杂性增加，芯片成本高</td>
<td>由软件完成部分硬件功能，软件复杂性增加，芯片成本低</td>
</tr>
<tr>
<td>性能</td>
<td>减少代码尺寸，增加指令的执行周期数</td>
<td>使用流水线降低指令的执行周期数，增加代码尺寸</td>
</tr>
<tr>
<td>指令集</td>
<td>大量的混杂指令集，有简单快速的指令，也有复杂多周期指令，符合HLL</td>
<td>简单的单周期指令，在汇编指令方面有相应的SISC伪代码指令</td>
</tr>
<tr>
<td>高级语言支持</td>
<td>硬件完成</td>
<td>软件完成</td>
</tr>
<tr>
<td>寻址模式</td>
<td>复杂的寻址模式，支持内存到内存寻址</td>
<td>简单的寻址模式，仅允许LOAD和STORE指令存取内存，<strong>其他所有的操作都基于寄存器到寄存器</strong></td>
</tr>
<tr>
<td>寄存器数目</td>
<td><strong>寄存器较少</strong></td>
<td><strong>寄存器较多</strong></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="3-1-3-流水线技术">3.1.3. 流水线技术</h4>
<p>RISC机器用来减少指令周期的一种技术，提高处理器和总线的使用率，在CPU中由<strong>若干个不同功能的电路单元组成一条指令处理流水线</strong>，然后将一条指令分成若干步后再由这些电路单元分别执行，<strong>这样就能实现在一个CPU时钟周期完成一条指令</strong>，因此提高CPU的运算速度。</p>
<p>优点：提高CPU利用率、并行计算，减少指令周期</p>
<h4 id="3-1-4-微处理器分类">3.1.4. 微处理器分类</h4>
<ol>
<li>嵌入式微处理单元(MPU)：功能和微处理器一样，具有较高的性能，具有体积小、功耗少、成本低、可靠性高的优点。具有<strong>32位及以上</strong>的处理器</li>
<li>嵌入式微控制器(MCU)：嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM/EPROM、RAM、总线, 总线逻辑、定时/计数器、Watchdog、I/O、串行口等各种必要功能和外设。<strong>是目前嵌入式工业的主流，50%的份额</strong>。<strong>多是8位和16位处理器，32位的也不多</strong></li>
<li>嵌入式DSP处理器(Data Signal Process)：嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</li>
<li>嵌入式SoC：嵌入式SoC是追求产品<strong>系统最大包容</strong>的集成器件，绝大多数系统构件都在一个系统芯片内部。</li>
</ol>
<p><strong>都具有体积小、功耗小、可靠性高、设计生产效率高的特点。</strong></p>
<h4 id="3-1-5-选型">3.1.5. 选型</h4>
<ol>
<li><strong>有效且经济</strong>地满足任务的计算需求
<ol>
<li>速度，ROM和RAM的数量，I / O端口和计时器的数量，大小，包装，功耗</li>
<li>容易升级</li>
<li>单位成本</li>
</ol>
</li>
<li>软件开发工具的可用性：汇编器，调试器，C编译器，仿真器，模拟器，技术支持(开源框架可能没有多少人维护)</li>
<li>微控制器的广泛可用性和可靠来源。</li>
</ol>
<h3 id="3-2-看门狗（Watch-Dog）">3.2. 看门狗（Watch Dog）</h3>
<ol>
<li>
<p>功能：</p>
<p>在<strong>对系统稳定性要求较高的场合</strong>，防止嵌入式控制系统运行时收到外部干扰或者系统错误，<strong>程序出现跑飞</strong>，<strong>导致整个系统瘫痪</strong>，加入看门狗电路，当系统跑飞进入死循环时，回复系统的运行</p>
</li>
<li>
<p>基本原理：</p>
<p>程序完整运行一周期的时间是tp，看门狗的定时周期为ti，且ti&gt;tp，在程序运行一周期后就修改定时器的计数值（即重新设定看门狗的定时周期）（喂狗），只要程序正常运行，定时器就不会溢出。若由于干扰等原因使系统不能再tp时刻修改定时器的计数值，<strong>定时器将在ti时刻溢出</strong>，引发系统复位，使系统得以重新运行，从而起到监控的作用。</p>
</li>
</ol>
<h3 id="3-3-嵌入式系统的存储体系">3.3. 嵌入式系统的存储体系</h3>
<h4 id="3-3-1-存储器系统：存储器系统的层次结构">3.3.1. 存储器系统：存储器系统的层次结构</h4>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/8.png" alt=""></p>
<h4 id="3-3-2-ROM的种类与选型">3.3.2. ROM的种类与选型</h4>
<ul>
<li>
<p>ROM：固定内容、掩膜工艺、无法修改</p>
<blockquote>
<p>只读存储器（Read-Only Memory）是一种只能读取资料的存储器。在制造过程中，将资料以一特制光罩（mask）烧录于线路中，其资料内容在写入后就不能更改，所以有时又称为“光罩式只读内存”（mask ROM）。</p>
</blockquote>
</li>
<li>
<p>PROM：一次编程ROM，一旦导入、无法改变</p>
<blockquote>
<p>可编程程序只读存储器（Programmable ROM，PROM）之内部有行列式的熔丝，是需要利用电流将其烧断，写入所需的资料，但仅能写录一次。 PROM在出厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0</p>
</blockquote>
</li>
<li>
<p>EPROM：加电可擦除，多次，字节级</p>
<blockquote>
<p>可抹除可编程只读存储器（Erasable Programmable Read Only Memory，EPROM）可利用高电压将资料编程写入，抹除时将线路曝光于紫外线下，则资料可被清空，并且可重复使用。通常在封装外壳上会预留一个石英透明窗以方便曝光。</p>
</blockquote>
</li>
<li>
<p>快闪存储器flash：电可擦，块级</p>
<blockquote>
<p>快闪存储器（Flash memory）的每一个记忆胞都具有一个“控制闸”与“浮动闸”，利用高电场改变浮动闸的临限电压即可进行编程动作。</p>
</blockquote>
</li>
</ul>
<h4 id="3-3-3-Flash的种类与选型">3.3.3. Flash的种类与选型</h4>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam2/7.png" alt=""></p>
<ol>
<li>NAND Flash与NOR Flash相比，具有读性能比较差、写性能较好、串行读取、成本低、容量大的特点</li>
<li>NAND Flash：需要BootLoader的引导模式</li>
<li>NOR Flash：不需要BootLoader的引导模式</li>
</ol>
<h4 id="3-3-4-RAM的种类与选型">3.3.4. RAM的种类与选型</h4>
<ul>
<li>
<p>RAM</p>
<blockquote>
<p>RAM也称随机存储器，那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。</p>
</blockquote>
</li>
<li>
<p>DRAM：(内存)速度稍慢，加电更新</p>
<blockquote>
<p>DRAM（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是DRAM。DRAM使用电容存储，DRAM 只能将数据保持很短的时间。</p>
</blockquote>
</li>
<li>
<p>SRAM：不用刷新，速度快，价格贵，容量小</p>
<blockquote>
<p>SRAM（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比DRAM复杂，可以做到不刷新电路即能保存它内部存储的数据。</p>
</blockquote>
</li>
<li>
<p>SDRAM：提升性能(时钟)</p>
<blockquote>
<p>SDRAM：（Synchronous Dynamic Random Access Memory，同步动态随机存取存储器），为DRAM的一种，同步是指Memory工作需要同步时钟，<strong>内部命令的发送与数据的传输都以时钟为基准</strong>；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是由指定地址进行数据读写。</p>
</blockquote>
</li>
<li>
<p>还有DDR SDRAM、DDR2 SDRAM、DDR3SDRAM不做过多赘述，感兴趣可以自己百度。</p>
</li>
</ul>
<h3 id="3-4-嵌入式系统总线">3.4. 嵌入式系统总线</h3>
<h4 id="3-4-1-总线结构，常见的总线及特点">3.4.1. 总线结构，常见的总线及特点</h4>
<ul>
<li>
<p>单总线结构</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/10.png" alt=""></p>
<blockquote>
<p>使用一条单一的系统总线来链接CPU、主存和IO设备。总线只能分时工作，是信息的传送的吞吐量受到限制。四次握手(1 enq， 2 ack, 2 low_ack, 1 low_enq)</p>
</blockquote>
</li>
<li>
<p>双总线结构</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/11.png" alt=""></p>
<blockquote>
<p>在CPU和主存之间专门设置了一组高速的存储总线，使CPU可通过专用总线与存储器交换信息，并减轻了系统总线的负担。主存仍可通过系统总线与外设之间实现DMA操作，而不经过CPU</p>
</blockquote>
</li>
<li>
<p>多总线结构</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/12.png" alt=""></p>
<blockquote>
<p>在双总线系统的基础上增加IO总线，其中系统总线是CPU、主存和通道（IOP）之间进行数据传送的公共通路，而IO是多个外部设备与通道之间进行数据传送的公共通路。通道实际上是一台具有特殊功能的处理器，他分担了一部分CPU的功能，以实现对外设的统一管理及外设与主存之间的数据传送。</p>
</blockquote>
</li>
</ul>
<h4 id="3-4-2-输入输出编程：忙等IO和中断IO">3.4.2. 输入输出编程：忙等IO和中断IO</h4>
<ol>
<li>
<p>忙等IO：用指令来检查设备是否就绪【即轮询看设备是否就绪】</p>
<ul>
<li>最简单的设备驱动方式</li>
<li>CPU不能在检查设备的过程中执行其他指令</li>
<li>很难处理同时发生的IO操作</li>
</ul>
</li>
<li>
<p>中断IO：基于子程序调用，使下一条指令为一个子程序调用的预定位置，返回位置被保存确保执行前台程序。【即采用中断机制来 IO】</p>
<ul>
<li>CPU和设备之间通过总线连接</li>
<li>CPU和设备之间进行握手</li>
<li>设备发出中断请求</li>
<li>当CPU能处理中断时发出中断确认请求。</li>
</ul>
<p>两种机制确保中断更加有效：</p>
<ul>
<li>优先级决定哪个中断先获得CPU；</li>
<li>中断向量决定每个中断对应的执行代码。</li>
</ul>
</li>
</ol>
<h4 id="3-4-3-Programming-I-O：Independent-I-O-port-memory-mapped-I-O">3.4.3. Programming I/O：Independent I/O port. memory-mapped I/O</h4>
<p><strong>可编程I/O</strong></p>
<ol>
<li>通信期间选择控制寄存器或数据缓冲区的三种方法
<ol>
<li><strong>独立的I/O端口</strong>：需要专门的指令来完成。</li>
<li><strong>内存映射的I/O</strong>。</li>
<li><strong>混合解决方案(统一编址)</strong>。混合模型包括内存映射的I/O数据缓冲区和用于控制寄存器的单独的I/O端口。</li>
</ol>
</li>
<li>英特尔x86提供了输入输出说明。<strong>大多数其他CPU使用内存映射</strong>的I/O。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec5/4.png" alt=""></p>
<p>a. 独立的I/O和内存空间。</p>
<p>b. 内存映射的I/O。</p>
<p>c. 混合解决方案。</p>
<h2 id="4-嵌入式系统软件知识【重点】">4. 嵌入式系统软件知识【重点】</h2>
<h3 id="4-1-嵌入式软件基础知识">4.1. 嵌入式软件基础知识</h3>
<h4 id="4-1-1-嵌入式软件的特点">4.1.1. 嵌入式软件的特点</h4>
<ol>
<li>
<p>独特的实用性</p>
<blockquote>
<p>每种嵌入式软件都有自己独特的应用环境和实用价值</p>
</blockquote>
</li>
<li>
<p>灵活的适用性</p>
<blockquote>
<p>嵌入式软件通常可以认为是一种模块化软件，它应该能非常方便灵活地运用到各种嵌入式系统中，而不能破坏或更改原有的系统特性和功能</p>
</blockquote>
</li>
<li>
<p>程序代码精简</p>
<blockquote>
<p>由于嵌入式系统本身的应用有小体积、小存储空间、低成本、低功耗等要求，嵌入式软件和大型机上的软件相比，具有代码精简、执行效率高等特点</p>
</blockquote>
</li>
<li>
<p>可靠性、稳定性高</p>
<blockquote>
<p>嵌入式系统应用要求一般较为苛刻，特别是在涉及安全相关的领域，如汽车电子、工业控制、航空航天等</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-2-嵌入式软件的分类">4.1.2. 嵌入式软件的分类</h4>
<ol>
<li>
<p>系统软件</p>
<blockquote>
<p>即OS，负责嵌入系统的全部软、硬件资源的分配、调度工作，控制、协调并发活动；它必须体现其所在系统的特征，能够通过装卸某些模块来达到系统所要求的功能</p>
</blockquote>
</li>
<li>
<p>支撑软件</p>
<blockquote>
<p>支撑软件是用于帮助和支持软件开发的软件，通常包括<strong>数据库和开发工具</strong>，其中以<strong>数据库最为重要</strong></p>
</blockquote>
</li>
<li>
<p>应用软件</p>
<blockquote>
<p>嵌入式应用软件是针对特定应用领域，基于某一固定的硬件平台，用来达到用户预期目标的计算机软件。由于用户任务可能有时间和精度上的要求，因此有些嵌入式应用软件需要特定嵌入式操作系统的支持</p>
</blockquote>
</li>
</ol>
<h4 id="4-1-3-嵌入式软件体系结构">4.1.3. 嵌入式软件体系结构</h4>
<ol>
<li>轮询</li>
<li>有限状态机</li>
<li>带中断的轮询</li>
<li>仅有中断</li>
<li>功能队列调度</li>
<li>实时操作系统(RTOS)</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>优先级</th>
<th>响应时间</th>
<th>变动的影响</th>
<th>共享数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>轮询</td>
<td>无，一切按序运行</td>
<td>所有任务之和</td>
<td>非常大，增加任务或修改任务时间影响所有任务</td>
<td>无</td>
</tr>
<tr>
<td>状态机</td>
<td>无，当前状态决定下一个状态优先级，非顺序执行</td>
<td>所有任务之和</td>
<td>同上</td>
<td>同上</td>
</tr>
<tr>
<td>带中断轮询</td>
<td>中断比主循环优先级高，中断有优先级</td>
<td>所有任务之和和中断执行时间和</td>
<td>主循环同轮序一样，对中断服务例程影响不大</td>
<td>必须处理和中断服务例程分享的数据</td>
</tr>
<tr>
<td>纯中断</td>
<td>中断有优先级</td>
<td>中断执行时间</td>
<td>对中断服务例程影响不大</td>
<td>同上</td>
</tr>
<tr>
<td>函数队列</td>
<td>中断有优先级，其他任务按序进行</td>
<td>最长任务执行时间</td>
<td>低，中断管理优先级函数，队列管理较低优先级</td>
<td>同上</td>
</tr>
</tbody>
</table>
<ul>
<li>函数队列:函数指针被添加到队列中，主循环在队列中循环并执行任务，任务或中断将新任务添加到功能队列中。以中断优先为优先级</li>
</ul>
<h3 id="4-2-嵌入式操作系统基础知识-关注实时调度部分，关注和通用OS的差别">4.2. 嵌入式操作系统基础知识 (关注实时调度部分，关注和通用OS的差别)</h3>
<h4 id="4-2-1-RTOS-Real-time-operating-systems">4.2.1. RTOS  Real time operating systems</h4>
<p><strong>概念</strong></p>
<p>对外来事件能在<strong>限定的响应时间</strong>内做出<strong>预定质量处理</strong>的计算机系统</p>
<p><strong>特点</strong></p>
<p>可移植性、强调实时性能、内核精简、<strong>抢占式内核、使用可重入函数</strong>、可配置、可裁剪、高可靠性</p>
<p><strong>选型原则</strong></p>
<p>首先确认是否需要使用RTOS(系统对相应延迟时间有要求，对事件处理复杂度有要求，对RAM、ROM的占用有一定规模要求)：</p>
<ul>
<li>成本，可靠性，实时性，工具链，模块丰富，RTOS内核RAM、ROM占用量，支持</li>
</ul>
<h4 id="4-2-2-任务管理">4.2.2. 任务管理</h4>
<h5 id="进程、线程、任务的概念">进程、线程、任务的概念</h5>
<ol>
<li>
<p>进程概念</p>
<p><strong>一个程序的单次执行</strong>。（如果两次运行一个相同的程序，就创建了两个不同的进程）</p>
<p>进程是操作系统资源分配和调度的基本单位，<strong>进程之间的地址空间和资源相互独立</strong></p>
</li>
<li>
<p>线程概念</p>
<p>轻量级进程，是操作系统任务调度和执行的基本单位</p>
</li>
<li>
<p>任务概念</p>
<p>最抽象、软件完成一个活动，可以是进程可以是线程。</p>
</li>
</ol>
<h5 id="任务的实现">任务的实现</h5>
<ul>
<li>
<p><strong>任务控制块</strong></p>
<p>任务控制块(TCB)描述一个任务的核心数据包括任务堆栈指针、任务状态、优先级等，任务创建的时候创建TCB表</p>
</li>
</ul>
<h5 id="任务调度">任务调度</h5>
<ol>
<li>
<p>可抢占调度</p>
<p>系统总是选择优先级别的最高的算法进行调度，并且一旦高优先级别的任务准备就绪之后，它就会马上被调度而不等待低优先级的任务主动放弃CPU</p>
</li>
<li>
<p>不可抢占调度</p>
<p>让进程运行直到结束或阻塞的调度方式，主要用于批处理或某些实时性要求不严的实时系统。</p>
</li>
<li>
<p>先来先服务</p>
<p>将处理机分配给最先来的进程，只考虑先后。(FCFS: first come first service)是一种<strong>非抢占式</strong>策略</p>
</li>
<li>
<p>时间片轮转算法</p>
<p>系统把所有就绪进程按先入先出的原则排成一个队列。<strong>新来的进程加到就绪队列末尾</strong>。每当执行进程调度时,进程调度程序总是选出就绪队列的队首进程,让它在CPU上运行一个时间片的时间（时间片是一个小的时间单位,通常为10~100ms数量级）。<strong>当进程用完分给它的时间片后</strong>,系统的计时器发出时钟中断,调度程序便停止该进程的运行,<strong>把它放入就绪队列的末尾</strong>;然后,把CPU分给就绪队列的队首进程,同样也让它运行一个时间片。<strong>非抢占调度</strong></p>
</li>
<li>
<p>优先级算法</p>
<p>系统将处理器分配给就绪队列中优先数最高的进程(分为抢占式优先级算法和非抢占式优先级算法)</p>
</li>
</ol>
<h5 id="实时系统及任务调度⭐">实时系统及任务调度⭐</h5>
<ol>
<li>
<p>单一速率调度 **RMS **算法Rate Monotonic Scheduling</p>
<p><a target="_blank" rel="noopener" href="https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310410910.html">单调速率调度（RMS）算法（详解版） (cdsy.xyz)</a></p>
<p><strong>静态</strong>调度策略，分配给每个进程的优先级是固定不变的，基于单一速率分析。</p>
<p>周期（即最后期限）短的进程被指定为最高优先级。每个周期进去，p进去，根据优先级调度执行，执行结束就从就绪状态退出直到下一个周期开始</p>
</li>
<li>
<p>最早截止时限优先调度 <strong>EDF</strong> 算法 Earliest deadline first</p>
<p><a target="_blank" rel="noopener" href="https://www.cdsy.xyz/computer/system/OS/20210307/cd161510310310909.html">最早截止时间优先（EDF）算法详解 (cdsy.xyz)</a></p>
<p><strong>动态</strong>的优先级方案，在进程执行时当前所有进程的截止时限改变进程的优先级，截止时限最近的优先级最高</p>
<p>与单调速率调度不一样，EDF 调度不要求进程应是周期的，也不要求进程的 CPU 执行的长度是固定的。**唯一的要求是，进程在变成可运行（即就绪态）时，每个时刻应该宣布它的截止期限。**如果截止时限比当前的进程高，那就会抢占当前进程</p>
</li>
</ol>
<p>例子：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/exam3/3.png" alt=""></p>
<h5 id="任务间通信">任务间通信</h5>
<ol>
<li>
<p>共享内存</p>
<blockquote>
<p>两个组件（比如CPU和I/O设备），通过一个共享内存位置进行通信，这个内存区域可以被看作一个通信设备，这个设备上所有的数据都存储在通信链路/内存中</p>
</blockquote>
</li>
<li>
<p>消息</p>
<blockquote>
<p>消息传递通信机制是共享内存模型的一种补充</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>每个通信实体都具有自己的消息发送/接收单元。消息不在通信链路上存储，而是<strong>存储在端点的发送器/接收器</strong>。</p>
</blockquote>
<ol start="3">
<li>
<p>管道</p>
<blockquote>
<p>发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。<strong>本质是固定大小的内存缓冲区</strong></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>由于当前操作系统的不惟一性，各个系统都有其独自的通信协议，导致了不同系统间通信的困难。尽管TCP/IP协议目前已发展成为Internet的标准，但仍不能保证C/S应用程序的顺利进行。命名管道作为一种通信方法，有其独特的优越性，这主要表现在它不完全依赖于某一种协议，而是适用于任何协议——只要能够实现通信</p>
</blockquote>
<ol start="4">
<li>
<p>信号</p>
<blockquote>
<p>信号很简单，因为除了信号本身不会传递其他数据，信号类似于中断，但它完全由软件创建。一个信号是由进程产生的，并由操作系统传送给另一个进程</p>
</blockquote>
</li>
</ol>
<h5 id="同步与互斥">同步与互斥</h5>
<p><strong>同步可以通过开关中断实现，互斥使用信号量。</strong></p>
<ol>
<li>
<p>竞争条件</p>
<blockquote>
<p>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>竞争条件发生在当多个进程或者线程在读写数据时，其最终的的结果依赖于多个进程的指令执行顺序。</p>
</blockquote>
<ol start="2">
<li>
<p>代码临界区</p>
<p><strong>临界区</strong>指的是<strong>一个访问共用资源的程序片段</strong>，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待</p>
</li>
<li>
<p>互斥</p>
<blockquote>
<p>一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源</p>
</blockquote>
</li>
<li>
<p>信号量</p>
<p>信号量广泛用于进程或线程间的同步和互斥</p>
<blockquote>
<p>管理多进程运行的方式，信号量是一种变量类型，仅能由操作原语PV对其操作。P：将 信号量value值减1，若小于0，相关进程被阻塞，加入队列，若大于0相关进程继续执行 V:value+1，若不大于0，则从队列中释放一个进程进入就绪态，然后自己继续执行，否则自己继续执行，没有别的操作</p>
</blockquote>
</li>
<li>
<p>死锁</p>
<blockquote>
<p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</p>
<p>当一些进程被永久地阻止获取互斥锁时就发生了死锁</p>
<p>例如线程A持有lock1且被阻止lock2，线程B持有lock2但被阻止获取lock1，就会出现死锁</p>
</blockquote>
</li>
</ol>
<h4 id="4-2-3-存储管理">4.2.3. 存储管理</h4>
<h5 id="1-嵌入式系统静态内存管理">1. 嵌入式系统静态内存管理</h5>
<p>系统在启动前，所有的任务都获得了所需要的所有内存，<strong>运行过程中将不会有新的内存请求</strong></p>
<ul>
<li>
<p>在强实时系统中，减少内存分配在时间上可能带来的不确定性。</p>
</li>
<li>
<p>不需要操作系统进行专门的内存管理操作。</p>
</li>
<li>
<p>系统使用内存的效率比较低下，只适合于那些强实时，且应用比较简单，<strong>任务数量可以静态确定的系统</strong></p>
</li>
</ul>
<h5 id="2-嵌入式系统动态内存管理">2. 嵌入式系统动态内存管理</h5>
<p>应用通过分配（malloc）与释放（free）操作来使用内存</p>
<ul>
<li>
<p>堆（heap）会带来碎片</p>
</li>
<li>
<p>垃圾回收</p>
<p>对内存堆进行重新排列，把碎片组织成为大的连续可用内存空间。但垃圾回收的时间长短不确定：<strong>不适合于处理实时应用</strong></p>
</li>
<li>
<p><strong>在实时系统中，避免内存碎片的出现，而不是在出现内存碎片时进行回收</strong></p>
</li>
</ul>
<p><strong>malloc 和 free：</strong></p>
<ol>
<li>
<p>在嵌入式系统中不常用，因为容易<strong>产生碎片</strong>。</p>
</li>
<li>
<p>解决办法</p>
<p>由于内存管理算法的原因，malloc()和free()函数执行时间是不确定的【是指执行完malloc返回花费的时间，因为分配的内存块大小不确定】。μC/OS-II 对malloc()和free()函数进行了改进，使得它们可以<strong>分配和释放固定大小的内存块</strong>，同时也不会产生碎片。这样⼀来，malloc()和free()函数的执⾏时间也是<strong>固定</strong>的了</p>
</li>
</ol>
<h2 id="5-嵌入式系统程序设计">5. 嵌入式系统程序设计</h2>
<h3 id="5-1-嵌入式软件开发基础知识">5.1. 嵌入式软件开发基础知识</h3>
<h3 id="5-2-嵌入式软件开发环境">5.2. 嵌入式软件开发环境</h3>
<p>交叉开发</p>
<ol>
<li>
<p>为什么嵌入式软件要交叉开发？<strong>为了满足代码编写编译调试与运行环境有不同要求的情况。</strong></p>
<p>嵌入式系统是面向特定应用的一体化软件，不具备软件编写编译等功能，这么做可以降低嵌入式系统复杂度，降低成本</p>
</li>
<li>
<p>宿主机和目标机差异:</p>
<ol>
<li>宿主机是通用计算机系统，而目标机则多为嵌入式系统</li>
<li>宿主机具有完整的开发软件如IDE、Complier、Debugger等，用于软件的编写，生成的二进制可执行代码则通过串口传输，在专用的面向应用的目标机上运行，并采取交叉方式进行调试</li>
</ol>
</li>
<li>
<p>过程</p>
<ol>
<li>宿主机上开发，模拟调试</li>
<li>通过串口或网络传到目标机上</li>
<li>目标机上基于监视器和操作系统的调试</li>
<li>目标机脱离宿主机运行</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>特征</th>
<th>通用计算机</th>
<th>嵌入式系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>形式与类型</td>
<td>看得见的计算机、按照其体系结构、运算速度和结构规模等因素分为大中小型机和微机</td>
<td>看不见的计算机，形式多样，应用领域广泛，按应用来分</td>
</tr>
<tr>
<td>组成</td>
<td>通用处理器、标准总线和外设，软件和硬件相对独立</td>
<td>面向应用的嵌入式微处理器，总线和外部接口多集成在处理器内部。<strong>软件与硬件是紧密集成在一起的</strong></td>
</tr>
<tr>
<td>开发方式</td>
<td>开发平台和运行平台都是通用计算机</td>
<td>采用交叉开发方式，<strong>开发平台一般是通用计算机，运行平台是嵌入式系统</strong></td>
</tr>
<tr>
<td>二次开发性</td>
<td>应用程序可重新编制</td>
<td>一般不能再编程</td>
</tr>
</tbody>
</table>
<h2 id="6-嵌入式实时内核（以ucosII为例）">6. 嵌入式实时内核（以ucosII为例）</h2>
<h3 id="6-1-实时任务调度">6.1. 实时任务调度</h3>
<p>μC/OS_II进行任务调度的思想是 “近似地每时每刻总是让优先级最高的就绪任务处于运行状态” 。为了保证这一点，它在系统或用户任务<strong>调用系统函数及执行中断服务程序结束时总是调用调度器，来确定应该运行的任务并运行它 。</strong></p>
<p>μC/OS_II进行任务调度的<strong>依据就是任务就绪表</strong>，根据就绪表确定最高优先级</p>
<p><strong>μC/OS-II 实时调度机制：</strong></p>
<ol>
<li>
<p>存储管理采用固定分区存储管理，以固定块大小来分配，避免内存碎片的产生</p>
</li>
<li>
<p>任务调度时间采用固定优先级的优先级调度，为确保任务的实时性，μC/OS-II 要确保每次调度的耗时具有可预测性，最多可以管理64个任务，且保留了 4 个最高和 4 个最低优先级任务给自己使用，因此用户最多 56 个任务。</p>
<p><strong>不⽀持时间⽚轮转法</strong>，<strong>每个任务的优先级要求不⼀样且是唯⼀的</strong></p>
</li>
<li>
<p>使用查表法，具有确定的时间，增加了系统的可预测性。TaskUnMapTbl表格存储256种情况下出现1的最低位，在代码为</p>
<ol>
<li><code>Y = TaskUnMapTbl[TaskRdyGrp]</code></li>
<li><code>X = TaskUnMapTbl[TaskRdyTbl[Y]]</code></li>
<li><code>Prio = (Y &lt;&lt; 3) + X</code></li>
<li>由此找到相应进程，保证耗时固定</li>
</ol>
</li>
<li>
<p>允许中断与异常存在，使得系统允许实时的高优先级任务执行。</p>
</li>
<li>
<p>任务调度总是选择<strong>就绪任务</strong>中<strong>优先级最高的一个运行</strong></p>
</li>
<li>
<p>允许任务间的抢占</p>
</li>
<li>
<p>具有优先级的中断机制</p>
</li>
<li>
<p>μC/OS中所有的系统调用时间都是确定的</p>
</li>
</ol>
<h3 id="6-2-中断与时钟">6.2. 中断与时钟</h3>
<p>μC/OS-II系统响应中断的过程为：</p>
<p>系统接收到中断请求后，这时如果CPU处于中断允许状态（即中断是开放的），系统就会中止正在运行的当前任务，而按照中断向量的指向转而去运行中断服务子程序；当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行或者转向运行另一个具有更高优先级别的就绪任务。</p>
<p><strong>时钟节拍是一种特殊的中断</strong>，μC/OS需要⽤户提供周期性信号源，⽤于实现时间延时和确认超时。时钟节拍的实际频率取决于用户应用程序的精度</p>
<h3 id="6-3-同步与通信">6.3. 同步与通信</h3>
<p>所有的通信信号都被看成是事件(event), μC/OS-II通过**事件控制块(ECB)**来管理每⼀个具体事件。</p>
<p>同步可以通过开关中断实现。互斥使用信号量。</p>
<p>​	当处理临界段代码时，需要关中断，处理完毕后，再开中断</p>
<p>通信可以使用邮箱和消息队列实现。</p>
<h3 id="6-4-存储管理">6.4. 存储管理</h3>
<p>μC/OS中是实模式存储管理</p>
<p>不划分内核空间和用户空间，整个系统只有一个地址空间，即物理内存空间，应用程序和内核程序都能直接对所有的内存单元进行访问</p>
<p>系统中的“任务”，实际上都是线程–––只有运行上下文和栈是独享的，其他资源都是共享的。</p>
<h4 id="静态">静态</h4>
<p>所谓静态存储方式是指在程序编译期间分配固定的存储空间的方式。该存储方式通常是在变量定义时就分定存储单元并一直保持不变， 直至整个程序结束。<strong>全局变量，静态变量等就属于此类存储方式。</strong></p>
<h4 id="动态">动态</h4>
<p>μC/OS中的存储管理 μC/OS采用的是<strong>固定分区的存储管理方法</strong>，即malloc和free分配的是固定大小的</p>
<p>μC/OS把连续的大块内存按分区来管理，每个分区包含有整数个大小相同的块;</p>
<p>在一个系统中可以有多个内存分区，这样，用户的应用程序就可以从<strong>不同的内存分区中得到不同大小的内存块</strong>。但是，特定的内存块在释放时必须重新放回它以前所属于的内存分区;</p>
<p>采用这样的内存管理算法，动态分配的内存碎片问题就得到了解决。</p>
<h2 id="7-BSP，BootLoader【不重要，就几分】">7. BSP，BootLoader【不重要，就几分】</h2>
<h3 id="7-1-嵌入式系统的启动过程">7.1. 嵌入式系统的启动过程</h3>
<ol>
<li>上电复位</li>
<li>板级初始化</li>
<li>引导操作系统</li>
<li>操作系统初始化</li>
<li>应用程序初始化</li>
<li>多任务应用</li>
</ol>
<h3 id="7-2-BSP-Board-Support-Packages">7.2. BSP Board Support Packages</h3>
<ol>
<li>
<p><strong>概念</strong>:全称&quot;板级支持包&quot;(Board Support Packages)，<strong>就是⼀段启动代码</strong>，和计算机主板的BIOS差不多，但提供的功能区别就相差很大</p>
<p>位于上层应用和下层硬件之间的存在</p>
</li>
<li>
<p><strong>特点:</strong></p>
<ol>
<li>
<p>硬件相关性:</p>
<blockquote>
<p>因为嵌入式实时系统的硬件环境具有相关性，所以，作为高层软件与硬件之间的接口，BSP必须为操作系统提供操作和控制具体硬件的方法。</p>
</blockquote>
</li>
<li>
<p>操作系统相关性:</p>
<blockquote>
<p>不同的操作系统具有各自的软件层次结构，因此，不同的操作系统具有特定的硬件接口形式.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p><strong>功能:</strong></p>
<blockquote>
<ol>
<li>单板硬件初始化，主要是CPU的初始化，为整个软件系统提供底层硬件支持</li>
<li>为操作系统提供<strong>设备驱动程序</strong>和系统中断服务程序</li>
<li>定制操作系统的功能，为软件系统提供一个实时多任务的运行环境</li>
<li>初始化操作系统，为操作系统的正常运行做好准备</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>与bios、EFI区别:</strong></p>
<ol>
<li>BIOS: BIOS主要是负责在电脑开启时检测、初始化系统设备(设置栈指针，中断分配，内存初始化)、装入操作系统并调度操作系统向硬件发出的指令。</li>
<li>BSP是和操作系统绑在一起运行在主板上的，尽管BSP的开始部分和BIOS所做的工作类似，可是大部分和BIOS不同，作用也完全不同。程序员还可以编程修改BSP，在BSP中<strong>任意添加一些和系统无关的驱动或程序，甚至可以把上层开发的统统放到BSP中</strong>。而BIOS程序是用户不能更改，编译编程的，<strong>只能对参数进行修改设置</strong>。<strong>更不会包含一些基本的硬件驱动</strong>。</li>
<li>EFI:由于EFl框架比BIOS要大得多，其启动过程也比BIOS要复杂。于BIOS最大的区别就是EFI首先需要EBC虚拟机，然后再启动设备驱动和EFI应用程序，最后通过EFI boot manager加载操作系统引导程序。</li>
</ol>
</li>
</ol>
<h3 id="7-3-引导模式">7.3. 引导模式</h3>
<ul>
<li>
<p>操作系统<strong>引导概念</strong></p>
<p><strong>将操作系统装入内存并开始执行的过程</strong></p>
</li>
<li>
<p>按时间效率和空间效率不同的要求，分为两种模式：</p>
<ul>
<li>
<p>需要BootLoader的引导模式</p>
<p>NAND flash启动，节省空间，牺牲时间，适用于硬件成本低，运行速度快，但启动速度相对慢</p>
</li>
<li>
<p>不需要BootLoader的引导模式</p>
<p>时间效率高，空间占用大，直接在NOR flash或ROM系列非易失性存储介质中运行，但运行速度慢</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-4-BootLoader及其启动过程">7.4. BootLoader及其启动过程</h3>
<ul>
<li>概念：bootloader是嵌入式系统中的OS启动加载程序</li>
<li>启动过程
<ol>
<li>初始化硬件</li>
<li>从 kernel.bin 中读取内核，并放入内存</li>
<li>设置启动参数</li>
<li>然后跳转到内核所在的开始地址， 运行内核</li>
<li>消亡</li>
</ol>
</li>
</ul>
<h2 id="8-建模【重要，设计题】">8. 建模【重要，设计题】</h2>
<blockquote>
<p>对应前面的设计</p>
</blockquote>
<h3 id="8-1-有限状态机及其应用。">8.1. 有限状态机及其应用。</h3>
<ol>
<li>
<p><strong>定义：</strong></p>
<p>有限状态机表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</p>
</li>
<li>
<p><strong>分类：</strong></p>
<ol>
<li>Moore State models：输出信号仅与当前状态有关，即可以把Moore型有限状态的输出看成是<strong>当前状态的函数</strong></li>
<li>Mealy State models：输出信号不仅仅与当前状态有关，还与所有的输入信号有关，即可以把Mearly型有限状态看成是<strong>当前状态和输入信号的函数</strong></li>
</ol>
</li>
<li>
<p>**示例：**交通信号灯、电话、定时炸弹、自动贩卖机、电梯等</p>
</li>
</ol>
<p>层次型有限状态机：近似的状态归属为一个更大的状态</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec8/25.png" alt=""></p>
<p><strong>注意，不同层次也是可以直接到达具体的状态的，不一定要进入该层次再确定，如上面的 Z→A</strong></p>
<h3 id="8-2-有限状态机的实现。">8.2. 有限状态机的实现。</h3>
<ol>
<li>
<p>Switch-case</p>
</li>
<li>
<p>状态表</p>
<p><img src="https://pic3.zhimg.com/80/v2-de3a8e09c4e2d6c71b05656166a22f12_720w.webp" alt="img"></p>
</li>
<li>
<p>面向对象设计模式：相比于其他方式，更容易维护和扩展，降低了实际状态之间的耦合，通过抽象接口来实现，当需要修改或添加状态时，只需要修改内部实现而不需要改变接口，隐藏内部实现一定程度上分解了复杂度，使得代码容易理解。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处。
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://wbl-z.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/3%20%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            3 数据的机器级表示
          
        </div>
      </a>
    
    
      <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">2 计算机的顶层视图</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i>  zzb
      </li>
    </ul>
    <ul>
      <li>
        R<i class="ri-heart-fill heart_icon"></i>Z
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="wbl-z&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    
      <li class="nav-item">
          <a href="https://github.com/wbl-z" target="_blank" class="my_link_li">
              <img src="/images/github.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://blog.csdn.net/m0_51691879" target="_blank" class="my_link_li">
              <img src="/images/csdn.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="https://juejin.cn/user/13645532637448" target="_blank" class="my_link_li">
              <img src="/images/%E6%8E%98%E9%87%91.png">
          </a>
      </li>
      
      <li class="nav-item">
          <a href="mailto:1214345406@qq.com" target="_blank" class="my_link_li">
              <img src="/images/envelope.png">
          </a>
      </li>
      
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>